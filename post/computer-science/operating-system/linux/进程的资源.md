## 资料

代码：{demo-c}/demo-in-linux/process/
### 进程的内存数据

进程通过 execve() 将程序加载到内存中去执行，此时操作系统会它们分配相应的内存资源。分配的内存资源主要用于存储程序指令和程序数据。
还有额外的进程内存数据、进程标识、进程状态、哪个用户启动的、打开的文件等。这些数据主要存储在 /proc 目录中。

#### /proc 目录

> DESCRIPTION</br>
> The proc filesystem is a pseudo-filesystem which provides an interface to kernel data structures.
> It is commonly mounted at /proc.</br>
> Typically, it is mounted automatically by the system, but it can also be mounted manually
> using a command such as: `mount -t proc proc /proc`</br>
> Most of the files in the proc filesystem are read-only, but some files are writable,
> allowing kernel variables to be changed.</br>
> ...

proc 文件系统是一个伪文件系统，它提供了一个观察内核数据结构的接口。
一般来说，它会被操作系统自动挂载到 /proc 目录。proc 文件系统中的大多数文件都是只读的。
但是，有些文件是可写的，允许通过这些可写的文件改变内核变量。

> DESCRIPTION</br>
> ...</br>
> /proc/\[pid\] subdirectories</br>
> Each one of these subdirectories contains files and subdirectories exposing information
> about the process with the corresponding process ID.</br>
> ...

/proc 目录存储了操作系统上所有进程的内存数据。进程对应的目录用进程标识（pid）命名。
比如，进程标识（pid）为 42 的进程，对应的目录就是 /proc/42。

#### /proc/\[pid\] 目录

> cmdline</br>
> This read-only file holds the complete command line for the process, unless the process is a zombie.

cmdline，记录进程是用什么命令启动的。如果进程已经变成僵尸进程了，那么这个文件就是空的。

> environ</br>
> This file contains the initial environment that was set when
> the currently executing program was started via execve(2).

environ，记录进程启动的时候的环境参数。就是调用 execve() 启动程序的时候，传给 execve() 的环境参数。

> exe</br>
> Under Linux 2.2 and later, this file is a symbolic link
> containing the actual pathname of the executed command.</br>
> This symbolic link can be dereferenced normally;
> attempting to open it will open the executable.</br>
> You can even type /proc/\[pid\]/exe to run another copy of
> the same executable that is being run by process \[pid\].

exe，包含被执行命令的实际路径名的软连接。可以直接通过它启动程序。

> fd/</br>
> This is a subdirectory containing one entry for each file which the process has open,
> named by its file descriptor, and which is a symbolic link to the actual file.</br>
> Thus, 0 is standard input, 1 standard output, 2 standard error, and so on.

fd 目录，记录进程打开的文件。这里面的内容就是常说的文件标识符。
程序启动的时候一般都会打开 0（标准输入）、1（标准输出）、2（标准错误）这三个。
也就是说，程序里通过代码打开的文件的文件标识符一般都是从 3 开始的。

> limits</br>
> This file displays the soft limit, hard limit, and units of measurement for
> each of the process's resource limits (see getrlimit(2)).

limits，记录进程的资源限制。

> maps</br>
> A file containing the currently mapped memory regions and their access permissions.</br>
> See mmap(2) for some further information about memory mappings.

maps，记录进程的内存映射和对内存的访问权限。在里面可以找到，进程的堆栈对应的内存地址到底在哪。

> net/</br>
> This directory contains various files and subdirectories
> containing information about the networking layer.</br>
> The files contain ASCII structures and are, therefore, readable with cat(1).</br>
> However, the standard netstat(8) suite provides much cleaner access to these files.

net 目录，记录进程和网络有关的数据。比如，和 socket 有关的东西。

> stat</br>
> Status information about the process. This is used by ps(1).

stat，记录进程状态信息。比如，进程状态、线程、信号等。这个文件是给 ps 命令用的。

> statm</br>
> Provides information about memory usage, measured in pages.

statm，以页为单位提供关于内存使用的信息。

> status </br>
> Provides much of the information in /proc/\[pid\]/stat and
> /proc/\[pid\]/statm in a format that's easier for humans to parse.

status，整合了 stat 和 statm 的内容。不过这个文件是给人看的，可读性更强。

#### 进程内存布局

> todo hkn linux 内存相关的会单独开一篇

进程的内存空间被分为内核空间（kernel space）和用户空间。
用户空间里面主要关注：栈（stack）、文件映射（里面有动态库的映射）、堆（heap）、
读写数据区（主要是程序数据，.bss 段、.data 段等）、
只读数据区（主要是程序指令，.text 段；也有程序数据 .rodata 段等。

### 进程的资源限制

> DESCRIPTION</br>
> The getrlimit() and setrlimit() system calls get and set resource limits.</br>
> Each resource has an associated soft and hard limit,
> ...
> The soft limit is the value that the kernel enforces for the corresponding resource.
> The hard limit acts as a ceiling for the soft limit: an unprivileged process may set only its soft limit
> to a value in the range from 0 up to the hard limit, and (irreversibly) lower its hard limit.
> A privileged process (under Linux: one with the CAP_SYS_RESOURCE capability in the initial user namespace)
> may make arbitrary changes to either limit value.
> ...</br>

getrlimit() 可以查看资源限制， setrlimit() 可以调整资源限制。
进程的资源限制包括软限制、硬限制等。其中软限制必须小于等于硬限制。

> The resource argument must be one of:</br>
> ...</br>
> RLIMIT_NOFILE</br>
> This specifies a value one greater than the maximum file descriptor number
> that can be opened by this process.</br>
> Attempts (open(2), pipe(2), dup(2), etc.) to exceed this limit yield the error EMFILE.
> (Historically, this limit was named RLIMIT_OFILE on BSD.)</br>
> ...</br>

可以通过资源参数指定需要操作的资源。比如 RLIMIT_NOFILE 对应进程可以打开的文件个数。
这个参数很重要，因为 linux 上一切皆文件。

代码示例：{demo-c}/demo-in-linux/process/rlimit.c

另外，在生产环境中，应该优先在程序中动态修改资源限制，不要轻易修改操作系统的资源限制。
