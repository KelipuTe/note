

### 进程的创建

笔记主要涉及 fock()、vfock()。

#### fock()

> fork() creates a new process by duplicating the calling process.</br>
> The new process is referred to as the child process.</br>
> The calling process is referred to as the parent process.</br>
> ...</br>

fork() 通过复制调用进程创建一个新进程，新进程为子进程，调用进程为父进程。

> RETURN VALUE</br>
> On success, the PID of the child process is returned in the parent, and 0 is returned in the child.</br>
> On failure, -1 is returned in the parent, no child process is created, and errno is set to indicate the error.

- 成功时，父进程拿到子进程的 pid，子进程拿到 0。可以根据这个判断哪个是父进程，哪个是子进程。
- 失败时，父进程拿到-1，子进程不会被创建，errno 会被设置用于表示错误。

代码示例：{demo-c}/demo-in-linux/process/fork.c

#### pid 和 ppid

在终端里使用 `echo $$` 命令，可以打印当前进程的 pid。

getpid() 返回调用进程的 pid，getppid() 返回调用进程的父进程的 pid。
在使用时需要注意，必须让子进程先执行，父进程后执行，打印出来的 ppid 才是正确的。

代码示例：{demo-c}/demo-in-linux/process/pid_and_ppid.c

如果父进程在子进程执行前先跑完了，那么子进程打印出来的 ppid 就会变成 1。
因为父进程已经没了，子进程变成了孤儿进程。孤儿进程会被 1 号进程接管，有可能会变成后台进程。

1 号进程就是 init 进程。init 进程是所有其他进程的祖先进程，
它是 linux 系统启动过程中的第一个进程，也是系统在运行时的第一个用户级进程。
init 进程的 pid（进程标识符）是就是 1。

#### 子进程和父进程的内存空间

> DESCRIPTION</br>
> ...</br>
> The child process and the parent process run in separate memory spaces.</br>
> At the time of fork() both memory spaces have the same content.</br>
> Memory writes, file mappings (mmap(2)), and unmappings (munmap(2)) performed by
> one of the processes do not affect the other.</br>
> ...

两个进程运行在不同的内存空间，进程间是隔离的。在 fork() 时，两个进程的内存空间的内容是一样的（程序数据和程序指令）。
两个进程进行写内存操作（定义新的变量并赋值，修改已定义的变量的值，定义新的函数）或者文件映射（进程间通信）时互不影响。

代码示例：{demo-c}/demo-in-linux/process/fork_separate_memory.c

在 fork() 时，子进程和父进程代码是一样的，子进程会从 fork() 的下一行代码开始继续执行。
一般是父进程先被调度，除非父进程被阻塞了。

#### copy on write（写时复制）

在 fork() 执行之后 exec() 执行之前，两个进程用的是相同的物理空间，子进程的代码段、数据段、堆栈都是指向父进程的物理空间。
两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。

如果没有执行 exec()，内核会给子进程的数据段、堆栈段分配相应的物理空间（两者有各自的进程空间，互不影响）。
而代码段继续共享父进程的物理空间（两者的代码完全相同）。
而如果执行了 exec()，由于两者执行的代码不同，子进程的代码段也会被分配单独的物理空间。

#### 子进程和父进程的区别

> DESCRIPTION</br>
> ...</br>
> \* The child has its own unique process ID, and this PID does not match
> the ID of any existing process group (setpgid(2)) or session.</br>
> \* The child's parent process ID is the same as the parent's process ID.</br>
> \* The child does not inherit its parent's memory locks (mlock(2), mlockall(2)).</br>
> ...

- 子进程有自己独立的唯一的进程标识（pid）。
- 子进程的父进程的 pid（ppid）和父进程的 pid 是一样的。
- 子进程不会继承父进程的内存锁。

#### vfork()

> Linux description</br>
> vfork(), just like fork(2), creates a child process of the calling process.</br>
> For details and return value and errors, see fork(2).</br>
> ...</br>
> vfork() differs from fork(2) in that the calling thread is suspended
> until the child terminates (either normally, by calling_exit(2), or abnormally,
> after delivery of a fatal signal), or it makes a call to execve(2).</br>
> Until that point, the child shares all memory with its parent, including the stack.</br>
> ...

vfork() 和 fork() 用法一样。区别在于，vfork() 创建子进程后，父进程会被阻塞，直到子进程退出。

代码示例：{demo-c}/demo-in-linux/process/vfork.c

而且 vfork() 创建出来的子进程和父进程共享内存，包括栈。

代码示例：{demo-c}/demo-in-linux/process/vfork_share_memory.c

vfork() 有 bug。当使用 `return 0` 结束或者执行到最后一行代码结束时，
有可能会报 "Segmentation fault (core dumped)" 错误。但是使用 `exit(0)`或者 `_exit(0)` 结束的时候不会。

通过 strace 命令追踪可以发现：报错时，子进程调用 `exit_group(0)` 退出，但是，父进程没有调用 `exit_group(0)`；
不报错时，两个进程都调用 `exit_group(0)` 退出。

这里猜测应该是共享内存的问题，如果子进程退出的时候把栈干碎了，那父进程被拉起来的时候，就没有栈，肯定会报错。
