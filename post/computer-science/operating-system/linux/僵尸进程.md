## 资料

代码：{demo-c}/demo-in-linux/process/

#### 僵尸进程

> DESCRIPTION</br>
> In the case of a terminated child, performing a wait allows the system to release
> the resources associated with the child; if a wait is not performed,
> then the terminated child remains in a "zombie" state (see NOTES below).</br>

在子进程终止的情况下，调用进程执行等待可以让操作系统释放与子进程相关的资源。
如果调用进程不执行等待，那么被终止的子进程就会处于"僵尸"状态，也就是僵尸进程。
当父进程也结束的时候，操作系统会把父进程和回收僵尸进程一起回收。

代码示例：{demo-c}/demo-in-linux/process/for_zombie.c

这里运行一下，下面的是输出到终端上的内容。

```
> ./for_zombie.elf
[debug]:parent, getpid()=3592
[debug]:parent, getpid()=3592, forkResult=3593
[debug]:child, getpid()=3593, forkResult=0
```

然后通过 ps 命令看一下 for_zombie 的运行情况。进程 3593 后面那个 "Z+" 就表示，它已经是一个僵尸进程了。

```
qqq         3592  0.0  0.0   2772   944 pts/0    S+   20:14   0:00 ./for_zombie.elf
qqq         3593  0.0  0.0      0     0 pts/0    Z+   20:14   0:00 [for_zombie.elf] <defunct>
```

当进程变成僵尸进程时，它的内存数据还驻留在内存中，/proc 目录下的相关文件也不会移除，这些东西依然在占用系统资源。
如果僵尸进程过多，会导致系统资源紧张，会影响操作系统的运行。所以必须要回收退出的子进程。
