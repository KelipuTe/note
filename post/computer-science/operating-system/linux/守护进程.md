---
draft: false
date: 2023-06-10 08:00:00 +0800
title: "控制进程"
summary: "控制进程；"
toc: true

categories:
  - Linux

tags:
  - 计算机科学
  - 操作系统
  - Linux
---

## 反向链接

[作业](/post/computer-science/operating-system/linux/作业)；

## 资料

代码：{demo-c}/demo-in-linux/process02/

## 正文

### 守护进程

守护进程、Daemon 进程；

守护进程最基本的特点就是运行在后台，并且不和终端关联。
这里的运行在后台和后台作业或者后台进程组是有区别的。后台作业或者后台进程组，进程依然是和会话进程关联的。
而守护进程的父进程是 1 号 init 进程，和启动它的会话进程不关联。
这里的不和终端关联的意思是，守护进程不接受标准输入也不会产生标准输出或者标准错误输出。

从终端开始运行的进程都会依附于这个终端，这个终端称为这些进程的控制终端。
当控制终端被关闭时，相应的进程都会被自动关闭。对于一般的前台进程，可以用 "ctrl + c" 的方式来停止运行，也可以直接关闭终端。
但是对于守护进程来说它的生命周期需要突破这种限制，它会一直运行直到整个系统关闭才会退出，因此守护进程不能依赖于终端。

### 编写守护进程的步骤

- 创建一个子进程 b，父进程 a 退出。因为调用 setsid() 的进程不能是组长进程。
- 子进程 b 调用 setsid() ，创建一个新的会话。
  调用进程调用 setsid() 时，该调用进程会变成会话首进程，变成组长进程，而且不关联终端。
- 有些时候，在子进程 b 调用 setsid() 后，还会再创建一个子进程 c ，然后自己（会话首进程）退出。
- 修改子进程的工作目录，一般为根目录。fork() 使得子进程继承了父进程的工作目录。
- 调用 umask() 重设文件权限掩码。fork() 使得子进程继承了父进程的文件权限掩码，这会给子进程使用文件带来麻烦。
- 关闭不必要的文件描述符（主要是 0、1、2）。fork() 使得子进程继承了父进程一些打开的文件，但是子进程可能不需要，这会消耗系统资源。
- 打开黑洞文件（`/dev/null`），彻底的断开控制终端。

代码示例：{demo-c}/demo-in-linux/process02/daemon.c

程序运行之后会变成守护进程，不会在终端有输出。可以通过 "ps -ely" 命令查看进程状态。

```
> ps -ely
S   UID   PID  PPID  C PRI  NI   RSS    SZ WCHAN  TTY          TIME CMD
S     0     1     0  0  80   0  2824  2961 -      pts/0    00:00:00 bash
S     0    16     0  0  80   0  3064  2961 -      pts/1    00:00:00 bash
S     0    45     1  0  80   0    88  1058 -      ?        00:00:00 daemon
S     0    46    45  0  80   0    88  1058 -      ?        00:00:00 daemon
R     0    50    16  0  80   0  3076 12406 -      pts/1    00:00:00 ps
```

可以看到进程 45 运行的 daemon 程序，它的父进程变成 1 号 init 进程了，这时进程 45 它就是一个守护进程。
从进程关联的标准输入设备（TTY）也可以看到进程 45 它值是 "?"，表示没有关联终端。
进程 45 还创建了一个子进程 46，这个虽然是后台进程，但是它的父进程不是1 号 init 进程，所以不算守护进程。

另外，也可以通过 daemon() 创建守护进程。

### nohup

最常用的创建守护进程的方式是使用 "nohup" 命令加上 "&" 符号。`nohup ./for_job.elf &`。

"nohup" 命令的作用有：阻止 SIGHUP 信号发送给这个进程；
关闭 stdin 使得该进程不再能接收任何输入，即使进程是运行在前台的（没有加 "&" 符号）；
重定向 stdout 和 stderr 到 nohup.out。
