## 正文

### SQL 优化

SQL 优化属于数据库优化的子问题。
数据库优化包括：硬件优化；操作系统优化；数据库（引擎）优化；SQL 优化。

SQL 优化的主要目标就两个：

- 减少系统资源（CPU、内存）消耗：减少排序，分组，去重之类的操作。
- 减少硬盘 IO 次数：尽量避免全表扫描、尽量使用索引、尽量使用索引覆盖。

SQL 优化一般都是在 explain 和尝试优化两个步骤之间循环。

### explain

- type：查询到所需行的方式。
  - system 和 const，可以理解为只返回一行数据。
  - eq_ref 和 ref，字面意思是根据索引来查找。
  - range：索引范围扫描。
  - index：索引全表扫描，整棵索引树。
  - ALL：全表扫描，要发起硬盘 IO。
  - system > const > eq_ref > ref > range > index > ALL

- possible_keys：候选的索引。
- key：实际使用的索引。
- rows：扫描的行数。数据库可能扫描了很多行之后才找到数据。
- filtered：查找到的数据占 rows 的比例。

### 优化思路

#### 选择索引

创建索引时，选择正确的列，非常的关键。

- 外键，一般用于关联和过滤数据。
- 频繁出现在 where 中的列，主要是为了避免全表扫描。
- 频繁出现在关联查询的关联条件中的列。不过一般不建议使用关联查询。
- 区分度很高的列。

另外，在创建联合索引时，区分度很高的列应该尽可能放到左边。

#### 索引覆盖

用频繁出现在 where 中和 order by 中的列构造联合索引。
这样在 where 之后，order by 出来的数据本身就是有序的。

#### 优化 count()

在别的地方（缓存、数据表）冗余一个总数，但是这样会影响插入和删除的效率。

如果可以接受延迟的话，这里就可以用异步的思路。比如，定时求和或者 binlog 工具。

#### 用 where 替换 having

如果不是使用聚合函数来作为过滤条件，最好还是将过滤条件优先写到 where 里面。

#### 优化分页中的偏移量

`LIMIT 5000, 50`。5000 就是偏移量。
实际执行时，数据库需要读出 5050 条数据。
然后将前面的 5000 都丢掉，只保留 50 条。

可以考虑用 `where id > 前一次查询的 max_id` 这个思路。
这样一方面是可以用到主键索引，另一方面偏移量永远都会是 0。
