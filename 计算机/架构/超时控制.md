---
draft: false
title: "超时控制"
summary: "超时控制；"
toc: true

categories:
  - 架构

tags:
  - 计算机
  - 架构

date: 2024-03-25 08:00:00 +0800
---

## 正文

### 超时控制

超时控制：
在规定的时间内，完成操作并返回响应；如果不能完成操作，就直接返回超时响应。

超时控制有两个目标：

一是确保客户端能在预期的时间内拿到响应。成功失败都可以，但是不能没有响应。

二是及时释放资源，尤其是线程、连接（数据库、TCP）等资源。
没有及时释放资源就会导致线程泄露、连接泄露、内存泄漏等问题。

超时控制分两种：针对一次请求的；针对调用链路的。

#### 针对一次请求的

上游系统在调用下游系统时，为调用设置一个超时时间。
如果下游系统还要调用下游系统，是不要管这个超时时间的。

#### 针对调用链路的

上游系统在调用下游系统时，为调用设置一个超时时间。
如果下游系统还要调用下游系统，是要传递这个超时时间的。
需要传递超时时间时，一般放在各个协议的协议头部里面。

比如，A 调用 B，B 调用 C，C 调用 D。
A 调用 B，超时时间设置为 1000ms，B 自己用 200ms。
那么 B 调用 C 时，超时时间就只能设置为 800ms 了。

这里还需要考虑建立连接消耗的时间。
从 A 发起调用到 B 接到请求的中间，还有个建立 TCP 连接的时间。
建立 TCP 连接可能还需要用掉 50ms。这时，其实只剩下 950ms 了。
B 自己用 200ms，那么 B 调用 C 时，超时时间就只能设置为 750ms 了。

除了逐级设置超时时间，还可以直接全链路传递请求的最晚完成时间。
只要下游系统的时间是准确的，大部分情况下也可以控制住超时时间。

### 如何确定超时时间

超时时间要设置合理。
设置过长可能会因为资源释放不及时导致服务崩溃。
设置过短可能会因为下游服务波动导致上游频繁超时。

确定超时时间的方式有：
根据用户体验、根据下游响应时间、根据代码估算。

#### 根据用户体验

根据产品经理的设计设置超时时间，这个主要是心理学的问题。
比如，热点新闻列表 3s 都刷不出来，用户说不定就不看了。

#### 根据下游响应时间

根据下游响应时间的 99 线（999 线）设置超时时间。

这个要求服务接入了可观测性组件，可以获得 99 线的数据。
如果没有的话，那么可以考虑通过压力测试获得 99 线的数据。

#### 根据代码估算

这里主要估算请求下游还有请求组件的时间，内存操作是很快的。
比如，某个请求需要调用一个下游接口、请求一次 redis，请求一次 mysql。

### 超时了怎么办

大多数系统，上游判断超时返回了，下游依然会继续执行。
这会出现一个经典的场景，客户端得到了超时响应，但是服务端成功了。

想解决这个问题就需要链路上所有的服务都有主动监测是否超时的功能。
每个服务都手写代码太麻烦了，这东西只能靠框架或者组件统一进行管理。
在发起请求和接受请求的地方判断一下是否超时，已经超时就不要继续了。
