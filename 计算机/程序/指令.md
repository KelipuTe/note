---
draft: false
date: 2023-06-10 08:00:00 +0800
title: "指令"
summary: "指令；指令集；"
toc: true

categories:
  - 程序

tags:
  - 计算机
  - 程序
---

## 反向链接

[算术逻辑单元](/计算机/硬件/算术逻辑单元)；

## 正文

### 指令

在算术逻辑单元那里提到了操作码可以用于指示 ALU 做什么操作。
如何识别不同的操作码，这个是通过逻辑单元实现的。举的那几个例子，就是指令（instruction）操作，几组指令操作。

为什么是几组呢。因为硬件制造出来之后，就可以理解为变不了了。
想让固定下来的硬件，去解决无穷多的问题。那就需要想办法让无穷多的问题，可以被有限数量的步骤解出来。
有限数量的步骤是可以重复的，但是重复的次数必须是有限的。有解，但是需要几千几万年，也可以理解为没有解。

这里的有限数量的步骤就是上面 ALU 那里的操作了。
因为硬件是固定的，所以如何表示操作，也是有一定的规则的。这里就需要一种方式，把某一个操作转化成一系列的小步骤。
表示这些步骤的一整套规则就是指令的内容了。指令的内容主要和操作码和操作数（寄存器 ID、内存地址等）有关。

同样的思路，到了 CPU 里也是一样的，只不过 CPU 的指令比 ALU 更多、更复杂。
指令指示 CPU 要做什么。操作码就是 CPU 要进行的动作，操作数就是 CPU 要处理的数据。
比如：算数加法（两个数、相加）、算数减法、从内存中读数据（内存地址、读取）、往内存中写数据等。

沿着之前硬件的思路，每个硬件内部的导线数量和元件数量就那么多，所以指令的长度肯定也是有限的。
比如寄存器，设计出来多大就是多大了。因此显然不可能把所有的指令都一股脑的扔给 CPU，让 CPU 去处理。

到这里，指令的大概概念和运行逻辑就差不多了。把大量的指令和数据组合起来，为了完成某一个操作，这就是程序了。

### 指令集

如果要把一次加法操作，比如，0b1 + 0b1 = 0b10，转换成程序。
首先需要依次加载两个数字，然后需要知道是加法并进行运算，最后需要存储运算结果。

这里面有几种不同的操作：加载数据、加法运算、存储数据。
这三个操作囊括了一次加法操作所需要的全部操作，构成了一个操作集合。

需要给每个操作设计对应的电路，这些不同的电路可以用指令码来进行标记。
那么和操作一样，这些指令码也属于一个指令码集合，这就是指令集的概念。

简单点说，程序想跑起来，那么构成程序的操作都要在指令集里面能找到。
硬件是根据指令集设计的，操作只有在指令集能找到，才能有对应的电路。

指令集是计算机的灵魂，整个计算机都是围绕指令集构建起来的。
它本质上是一个抽象层，硬件系统和软件系统通过这个抽象层连接。
一方面指导硬件系统怎么设计（比如 CPU），另一方面指导软件系统怎么设计。（比如 BIOS）
