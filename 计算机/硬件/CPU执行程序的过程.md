---
draft: false
date: 2023-02-21 08:00:00 +0800
title: "CPU 执行程序的过程"
summary: "CPU 执行程序的过程；"
toc: true

categories:
  - 硬件

tags:
  - 计算机
  - 硬件
---

## 反向链接

[CPU](/计算机/硬件/CPU)；
[可寻址内存](/计算机/硬件/可寻址内存)；

## 资料

图：

- ./CPU.drawio
- ./CPU执行程序的过程.drawio

## 正文

CPU 的运算器可以进行算数运算，控制器可以控制执行，内存可以存储数据。
如果能把 CPU 和内存结合起来，那就可以处理复杂的逻辑了。

### 定义指令

这里假设这个 CPU 一次可以处理 8 bit 的数据，也就是一条指令的长度是 8 bit。
一条指令有包括指令码和操作数，这里假设前 4 bit 作为指令码，后 4 bit 作为操作数。

这里假设指令集就是下面这样的，假定指令的操作数都是内存地址。

- 0b0001____，从内存读取数据到寄存器 A；
- 0b0010____ 从内存读取数据到寄存器 B；
- 0b00110000 把寄存器 A 和寄存器 B 的数据交给 ALU 做加法运算，然后把输出的结果放到寄存器 A，这个步骤不需要操作数；
- 0b0100____，把寄存器 A 的数据写入内存；

### 写出程序

这样就可以把这个程序大概写出来了。**见图：CPU.drawio**。

假设两个数据都是 1，分别存储在内存地址 1100 和 1101 上。执行一次加法运算，然后把结果存储到内存地址 1110 上。

### 找个地方放程序

指令和数据都可以以二进制的形式存储在内存里。比如，之前那个一次加法操作的整个程序是可以存储在内存中的。
这里我们先忽略程序是怎么装到内存里去的，这个在 <<BIOS>> 那篇笔记里再说。

但是跑这个程序的时候，直接操作内存搞，搞起来会很复杂。
所以会需要一些额外的空间临时存储一些数据，这些额外的空间通常由寄存器来实现。

这里继续使用那个一次加法操作的程序来说明。

首先，构成一次加法操作的每一步指令是需要分析的。
但是把内存线路直接接到控制单元上直接产生依赖显然不是一个好设计。
可以从内存里把指令拿出来，暂存在控制单元里，然后再进行分析，这就是指令寄存器的概念。

然后，程序跑到哪一步了也是需要记录的，这就是指令地址寄存器的概念。
两个操作数肯定是放在两个内存地址上的，这里肯定需要一个一个取出来，也就是需要两个能暂存操作数的地方。
这里就是很普通的，用于存数据的寄存器，叫寄存器 A 和寄存器 B 好了。

另外，ALU 计算的结果和标志位也需要处理。

最后，程序的每一次指令操作都需要电信号来触发，这个由时钟组件来控制，时钟会定时发射电脉冲。
比如，每过一秒，就发射一次电脉冲，驱动整个系统运作一次。

到这里，就可以画一个简单的结构图了。**见图：CPU_执行程序的过程.drawio**。
分为两部分：执行程序的 CPU 和存储程序的内存。

### CPU 执行程序的过程

把存有程序的内存和 CPU 连接起来，假设指令地址寄存器从 0 开始，那么程序的执行过程如下：

1、从 RAM 取数据放到寄存器 A。

将内存地址 0b0000 上的指令 0b00011100 加载到指令寄存器。

分析指令的指令码，0b0001 表示从内存读取数据到寄存器 A。

分析指令的操作数，0b1100 表示内存地址。于是去内存地址 0b1100 上，把数据 0b00000001 加载到寄存器 A。

内存地址 0b0000 上的指令执行结束，指令地址寄存器 +1 得到 0b0001。

2、从 RAM 取数据放到寄存器 B。

将内存地址 0b0001 上的指令 0b00101101 加载到指令寄存器。

分析指令的指令码，0b0010 表示从内存读取数据到寄存器 B。

分析指令的操作数，0b1101 表示内存地址。于是去内存地址 0b1101 上，把数据 0b00000001 加载到寄存器 B。

内存地址 0b0001 上的指令执行结束，指令地址寄存器 +1 得到 0b0010。

3、将内存地址 0b0010 上的指令 0b00110000 加载到指令寄存器。

分析指令的指令码，0b0011 表示把寄存器 A 和寄存器 B 的数据交给 ALU 做加法运算，然后把输出的结果放到寄存器 A，这个步骤不需要操作数。

先把寄存器 A 和寄存器 B 的数据交给 ALU 做加法运算，得到 0b00000010。

因为这个时候寄存器 A 还连着 ALU 呢，直接把数据给过去，数据就又传给 ALU 了。

所以控制单元会先暂存运算结果，然后切断寄存器 A 和 ALU 的连接，然后再把运算的结果放到寄存器 A 上。

内存地址 0b0010 上的指令执行结束，指令地址寄存器 +1 得到 0b0011。

4、将寄存器 A 中的数据存入 RAM。

将内存地址 0b0011 上的指令 0b01001110 加载到指令寄存器。

分析指令的指令码，0b0100 表示把寄存器 A 的数据写入内存。

分析指令的操作数，0b1110 表示内存地址。于是去内存地址 0b1101 上，把数据 0b00000010 存进去。

内存地址 0b0011 上的指令执行结束，指令地址寄存器 +1 得到 0b0100。

到这里，这个程序就已经执行结束了，后面的内存地址上如果存储了指令，那属于另外一个程序。
