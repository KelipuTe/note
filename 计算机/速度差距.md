---
draft: false
date: 2023-06-27 08:00:00 +0800
title: "速度差距"
summary: "速度差距；"
toc: true

categories:
  - 计算机

tags:
  - 计算机
---

## 正文

### 速度差距

计算机体系里的很多设计，解决的本质上都是速度差距导致的问题。

各个硬件的运行速度差异、各个程序的运行速度差异等。
一般情况下，CPU 是整个计算机里面速度最快的部件。

比如，CPU 的运行速度是远大于内存的运行速度的，那么当 CPU 需要从内存里读取数据的时候。
运行速度较快的 CPU 发送一个信号给内存之后，就需要等着运行速度较慢的内存把数据读出来。

如果速度差距很大的话。比如，内存执行一个基本操作的速度是 CPU 的 100 倍。
CPU 运行 1 个时间单位，发送一个信号给内存之后。内存需要运行 100 个时间单位，才能把数据读出来。
也就是说 CPU 要空等 99 个时间单位，这就造成了巨量的浪费。

所以根据局部性原理，在 CPU 内部设计了高速缓存来平衡这个问题。

存储器容量和存储器速度的矛盾本质上也是不同存储器硬件的运行速度差异导致的。
寄存器就那么多数据，内存的存储空间那多大了。就单纯的轮询一遍都有速度差距么。

再比如，本地就可以运行的程序的速度是远大于需要进行网络请求的程序的速度的。
简单理解，本地程序的各种信号充其量只在机箱里跑，网络请求的各种信号怎么说也是要出机箱的。

如果机器上只运行一个需要进行网络请求的程序，那么会发生和上面类似的问题。
程序运行 1 个时间单位，发起一个网络请求之后。需要等待 100 个时间单位，才能得到网络响应。
也就是说机器要空等 99 个时间单位，一样的造成了巨量的浪费。

所以为了避免这种情况，发展出了进程、分时操作系统、时间片轮转调度算法等，让多个程序在宏观上可以同时运行。

这种速度差距也可能发生在一个程序的内部。进程的粒度依然过大，然后就出现了线程这种比进程更小的单位。
