---
draft: false
date: 2023-12-04 08:00:00 +0800
title: 操作系统
summary: 操作系统；
toc: true

categories:
  - 操作系统

tags:
  - 计算机
  - 操作系统
---

## 反向链接

[BIOS](/计算机/操作系统/BIOS)；
[进程](/计算机/操作系统/进程)；

### 操作系统

操作系统、operating system；

前面我们已经有了 BIOS 和进程了，这里还需要关注一个问题。
当多个进程在一台计算机上一起运行的时候，难免会出现互相影响的问题。
这里就需要一个调度和保护机制，把这些进程隔离开来，防止他们互相影响。
同时规范程序的操作，把下层那些直接操作起来复杂而危险的东西保护起来。

这东西就是操作系统了，负责管理硬件资源和软件资源。
哪个进程切上去运行，进程用到哪些硬件，都是操作系统来负责调度。

操作系统一般是计算机启动后启动的第一个进程。
在 Linux 操作系统里面，它叫 init 进程。

### 主要功能

操作系统主要提供：进程管理、内存管理、文件系统、网络通信、用户界面、驱动程序等功能。

### 驱动程序

我在 BIOS 哪里提到过，BIOS 只需要给各种硬件提供最基本的输入输出功能。
和指令集一样，硬件提供了很多的功能，但是 BIOS 不需要全部提供。
BIOS 可以把更加复杂的指令直接交给硬件，BIOS 不认识没关系，硬件认识就行。
硬件怎么处理 BIOS 传给它的指令 BIOS 不管，BIOS 等着回传结果就行。

开发人员知道硬件可以识别那些指令就行了。
通过 BIOS 提供的基本的输入输出功能，间接地就可以使用硬件全部的功能。
我的理解，驱动程序就是一层封装，是给操作系统提供硬件全部功能的程序。

### 可执行文件

我的理解，可执行文件就是操作系统对可以在操作系统上运行的程序做了一个规定。
程序必须要按照操作系统要求的格式去写，这样操作系统才能识别其中的内容。
操作系统认不出来，那这玩意就是一堆文本或者数据，操作系统不知道要干什么。

可执行文件里面一般就都是构建操作系统所使用的指令集里的指令还有程序的数据了。

### 系统调用

操作系统想要保护下层的硬件，那就不能让开发人员能直接操作。
所以操作系统把下面硬件提供的功能也做一层封装，不能直接使用。
必须通过操作系统提供的各种接口才能使用，这就是系统调用。

### 分类

操作系统的分类没有统一的标准。

根据工作方式可分为：批处理操作系统、分时操作系统、实时操作系统、网络操作系统、分布式操作系统等。

根据指令长度可分为：16bit 操作系统、32bit 操作系统、64bit 操作系统等。

还有个人计算机操作系统、嵌入式操作系统等。

### 内核态和用户态

- 内核、kernel；内核态、kernel mode；用户态、user mode；
- 超级权限模式、supervisor mode；
- 内核空间、kernel space；用户空间、user space；

操作系统也是个程序，它会把自己和开发人员写的程序，在各个方面区别开来，比如，操作权限，内存空间等。

操作系统的权限是最高的，开发人员写的程序权限比自己低。
操作系统占用的内存空间，开发人员写的程序不能随便就能用。

开发人员只能通过操作系统提供的系统调用才能间接的使用下面的资源。
程序执行在这里天然就形成了以调用系统调用为分界线的了两个部分。

调用系统调用之前，程序处于用户态，调用系统调用之后，程序处于内核态。
系统调用相当于一个黑盒，处于内核态的程序只能干等着操作系统返回结果。

内核程序就相当于操作系统本身，处于超级权限模式，可以访问内核空间。
内核空间只有内核程序可以访问，专门给应用程序使用的内存叫用户空间。

## 参考

- [计算机系统：用户态和内核态](https://zhuanlan.zhihu.com/p/608775807)

## 正向链接

[Linux导航](/计算机/操作系统/linux/Linux导航)；
