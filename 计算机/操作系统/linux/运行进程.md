
### 进程的运行

笔记主要涉及 execve()、exec 家族的六个函数。

程序被 execve() 加载到内存中时，需要操作系统分配内存资源。
准备工作做完后，下一步就是找到程序入口并开始执行。主进程默认会启动一个主线程去执行 main() 入口函数。

#### execve()

> DESCRIPTION</br>
> execve() executes the program referred to by pathname.</br>
> ...</br>
> pathname must be either a binary executable, or a script starting
> with a line of the form: `#!interpreter [optional-arg]`</br>
> ...

在当前正在运行的程序里，可以调用 execve() 通过另外一个新的程序的路径名执行它。
这个新的程序必须是一个二进制的可执行文件。或者是一个以 `#!interpreter [optional-arg]` 形式开始的脚本。
比如，shell 脚本文件开头的 `#!/bin/bash`。

> DESCRIPTION</br>
> ...</br>
> This causes the program that is currently being run by the calling process to be replaced
> with a new program, with newly initialized stack, heap, and (initialized and uninitialized) data segments.</br>
> ...</br>
> execve() does not return on success, and the text, initialized data, uninitialized data (bss),
> and stack of the calling process are overwritten according to the contents of the newly loaded program.

execve() 在成功时不会返回。而是会导致当前正在运行的程序被另外一个新的程序所取代。
当前程序的 .test 段、.data 段、.bss 段、栈、堆等，都会被新的程序的数据覆盖。

#### exec

> DESCRIPTION</br>
> The exec() family of functions replaces the current process image with a new process image.</br>
> The functions described in this manual page are layered on top of execve(2).

简单理解，exec 家族的六个函数底层都是基于 execve() 实现的。

用 execl() 举例，代码示例：

- {demo-c}/demo-in-linux/process/execl.c
- {demo-c}/demo-in-linux/process/call_by_exec.c

用 execv() 举例，代码示例：

- {demo-c}/demo-in-linux/process/execv.c
- {demo-c}/demo-in-linux/process/call_by_exec.c

这个例子在 Ubuntu 22.04 环境中执行，会返回 Bad Address，不知道为什么。

### 进程的运行顺序

> DESCRIPTION</br>
> The scheduling priority of the process, process group, or user, as indicated by which and who
> is obtained with the getpriority() call and set with the setpriority() call.</br>
> The process attribute dealt with by these system calls is the same attribute
> (also known as the "nice" value) that is dealt with by nice(2).</br>
> ...</br>
> The prio argument is a value in the range -20 to 19 (but see NOTES below),
> with -20 being the highest priority and 19 being the lowest priority.</br>
> Attempts to set a priority outside this range are silently clamped to the range.</br>
> The default priority is 0; lower values give a process a higher scheduling priority.</br>
> ...

进程的运行（执行、调度）顺序受到 PRI（priority）值和 NI（nice）值控制，这两个值对应进程的同一个属性。
值的范围是 -20~19，值越小，进程优先级越高。这两个值可以通过 ps 命令（`ps -ely`）查看（PRI 和 NI 参数），
也可以通过 top 命令查看（PR 和 NI 参数）。

在系统中，可以使用 nice 命令和 renice 命令调整进程的优先级。
nice 命令用于进程启动之前，renice 命令用于进程启动之后。

在代码中，getpriority() 可以查看进程优先级，setpriority()、nice() 可以调整进程优先级。
getpriority() 和 setpriority() 使用的时候需要注意的是，who 参数要和 which 参数对应。

代码示例：{demo-c}/demo-in-linux/process/nice.c
