---
draft: false
date: 2023-06-10 08:00:00 +0800
title: "作业"
summary: "作业；作业控制；前台作业；后台作业；"
toc: true

categories:
  - Linux

tags:
  - 计算机
  - 操作系统
  - Linux
---

## 反向链接

[进程组](/计算机/操作系统/linux/进程组)；
[控制进程](/计算机/操作系统/linux/控制进程)；

## 资料

代码：{demo-c}/demo-in-linux/process02/

## 正文

### 作业

Linux 是一个多用户多任务的分时操作系统。
多用户是指多个用户可以在同一时间使用计算机系统。
多任务是指 Linux 可以同时执行多个任务，可以在一个任务还未执行完的同时执行另一项任务。
多个用户和多个任务都由操作系统进行管理。
分时是指计算机采用时间片轮转的方式同时为几个、几十个、甚至几百个用户服务。

### 作业控制

Shell 是操作系统的用户界面，提供了用户与内核进行交互操作的一种接口。
它实际上是一个命令解释器，接收并解释用户输入的命令，然后把命令送入内核去执行。
Shell 有多种不同的版本，常用的 BASH 就是其中一种。

Shell 控制的不是进程而是作业。正在执行的一个或多个相关进程被称为作业（job），也有叫任务的。
作业是计算机操作者（可以是人也可以是程序）交给操作系统的执行单位。
作业控制指的是控制正在运行的进程的行为。比如，在 Shell 控制终端控制多个作业。

### 前台作业和后台作业

作业还分为前台作业和后台作业。用户直接操作的那个终端窗口就属于前台作业，前台作业独占终端窗口。
它可以直接接收用户输入的命令，而且一旦命令开始运行，除非命令运行结束或者强制终止命令，要不然是不能执行其他命令的。

前台作业运行结束，Shell 就会把自己提到前台。
比如，在终端窗输入 "ls" 命令之后，Shell 会启动一个进程去执行 "ls" 命令，
"ls" 命令执行完之后会输出结果，然后这个进程退出，然后 Shell 把自己提到前台。

除了表面上看得到的前台作业的进程，还有很多正在运行的进程是表面上看不到的。
比如，那个直接和用户交互的作业背后，是需要操作系统做很多工作来提供支撑的。
这些进程就属于后台作业。Shell 可以运行一个前台作业和任意多个后台作业。

### 切换前台作业和后台作业

这里准备了一个程序 for_job.c。程序每 5 秒，用 printf() 输出一次 pid。

想启动前台作业很简单，在终端窗口里直接执行命令就好了。比如，在终端窗口里直接运行这个程序。
这样程序就是一个前台作业，会占着终端窗口一直输出 pid。

```
> ./for_job.elf
[debug]:getpid()=11959
[debug]:getpid()=11959
一直输出。。。
```

这个时候可以按下 "ctrl + z"，可以停止进程并放入后台。这个时候，这个前台作业就变成后台作业了。

```
^Z
[1]+  Stopped                 ./for_job.elf
```

job 命令可以查看当前 Shell 环境中已启动的作业状态，这里用 "job -l" 命令查看一下。
可以看到刚才的 11959 进程，现在在后台而且处于停止状态。

```
> jobs -l
[1]+ 11962 Stopped                 ./for_job.elf
```

- "\[1\]" 表示作业号为 1。
- "+" 表示最近一个放入后台的作业。如果这里是 "-" 则表示倒数第二个放入后台的工作，
  倒数第三个以后的工作就没有 "+" 或者 "-" 标志了。
- 11962 就是 pid；Stopped 表示进程现在是停止状态。
- 最后的 "./for_job.elf" 表示进程是这个命令启动起来的。

bg 命令可以让最近一个暂停的后台任务继续执行。这里也可以用 "bg %1"，"%1" 就是指定了作业号。

```
> bg
[1]+ ./for_job.elf &
[debug]:getpid()=11962
[debug]:getpid()=11962
一直输出，而且不受控制
```

这里就要提到后台作业的两个特点：

- 继承当前会话的标准输出（stdout）和标准错误输出（stderr）。
  因此，后台任务的所有输出依然会同步地打到终端窗口，也就是上面一直输出的原因。
- 不继承当会话的标准输入（stdin）。因此，无法再向这个任务输入指令了，也就是上面不受控制的原因。
  如果后台作业试图读取标准输入，终端驱动会检测后台进程的这种举动并向后台作业发送一个 SIGTTIN 信号。
  SIGTTIN 信号通常会暂停（halt）后台作业的执行。

所以，前台任务和后台任务的区别只有一个：是否继承标准输入。

如果这个时候继续在终端窗口里面输入命令，它是可以被执行的。
虽然这个时候后台任务的所有输出会同步地打到终端窗口，让窗口看上去非常的混乱，但是这并不影响输入的命令。
输入和输出的内容并不在一个地方，只是都显示到了一个地方。

比如，使用 fg 命令将后台运行的或挂起的作业切换到前台运行。这里也可以用 "fg %1"，"%1" 同样是指定了作业号。

```
> fg %1
./for_job.elf
[debug]:getpid()=11962
一直输出。。。
```

另外，可以通过在命令的后面加一个 "&" 符号，让程序直接以后台作业的方式启动。

```
>./for_job.elf  &
[1] 2228
```

这种方式启动起来的作业就是直接处于后台并且是运行状态的。

```
> jobs -l
[1]+  2249 Running                 ./for_job.elf &
```

### 子进程

如果作业中的某个进程又创建了子进程，则子进程不属于作业。
作业运行结束时，如果这个子进程还没终止，那么它会变为后台进程。
比如，用 fork() 创建了一个子进程之后，父进程直接退出，这个时候子进程并不会终止，而是变成孤儿进程。
