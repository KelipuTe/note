---
draft: true
date: 2022-08-01 08:00:00 +0800
title: "页式管理"
summary: "页式管理；"
toc: true

categories:
  - 操作系统

tags:
  - 计算机科学
  - 操作系统
  - 内存
---

## 正文

图：/content/计算机/operating-system/页式管理.drawio

### 页式管理

整个虚拟内存空间和物理内存空间都被切成一个个固定尺寸大小的内存空间（内存页）。

分页可以让内存交换时，读写的数据少一点。在 Linux 中，每一页的大小为 4KB。

虚拟地址与物理地址之间通过页表来映射。（**见图：页式管理.drawio**）

页表存储在内存里，每个进程都有自己的页表。（**见图：页式管理.drawio**）

从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址，所以页表一定要覆盖全部虚拟地址空间。
内存管理单元负责将虚拟内存地址转换成物理地址。

虚拟地址分为两部分：页号和页内偏移。

页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址。

页表里的页表项中除了物理地址之外，还有一些标记属性的数据，比如控制一个页的读写权限，标记该页是否存在等。
在内存访问方面，操作系统提供了更好的安全性。

对于一个内存地址转换，分三个步骤：

- 1、把虚拟内存地址，切分成页号和偏移量。
- 2、根据页号，从页表里面，查询对应的物理页号。
- 3、拿物理页号，加上前面的偏移量，就得到了物理内存地址。

当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常。
然后进入系统内核空间，分配物理内存，更新进程页表，最后再返回用户空间，恢复进程的运行。

### 页式管理的优点

由于内存空间都是预先划分好的，所以释放的内存都是以页为单位释放的，不会产生无法给进程使用的小内存。

如果内存空间不够，操作系统会把其他正在运行的进程中的最近没被使用的内存页面给释放掉。
也就是暂时写在硬盘上，称为换出（Swap Out）。

一旦需要的时候，再加载进来，称为换入（Swap In）。
所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。

分页的方式使得在加载程序的时候，不需要一次性都把程序加载到物理内存中。
只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。

### 简单分页的缺陷

简单分页有空间上的缺陷。

在 32 位的环境下，虚拟地址空间共有 4GB（2^32）。假设一个页的大小是 4KB（2^12），每个页表项 4 个字节。

那么 4GB 空间就需要 100 万（2^20）个页，大概 4MB 来存储页表。
每个进程都有自己的虚拟地址空间（页表）。那么，100 个进程就需要 400MB 来存储页表。

多级页表（Multi-Level Page Table）可以解决简单分页的空间上的缺陷。

### 多级页表

多级页表把 100 多万个页表项再分页，用一个一级页表 4KB 表示全部的虚拟地址空间，一级页表一共有 1024 个页表项。
每个一级页表项对应一个二级页表，每个二级页表也有 1024 个页表项。（**见图：页式管理.drawio**）

二级页表可以在需要时进行创建。每个进程都有 4GB 的虚拟地址空间。
而对于大多数程序来说，其使用到的空间远未达到 4GB，所以大多数的页表项都是空的。这样就可以节省下很多的空间。

多级页表解决了空间上的问题，但是转换工序带来了时间上的开销。

对于 64 位的系统，多级页表变成了四级目录，分别是：

- PGD（page global directory、全局页目录项）
- PUD（page upper directory、上层页目录项）
- PMD（page middle directory、中间页目录项）
- PTE（page table entry、页表项）。

### 页表缓存

根据局部性原理，程序在一段时间内的执行会集中在整个程序的其中一个部分。
相应地，执行所访问的存储空间也局限于某个内存区域。

[局部性原理](/计算机/局部性原理)

利用这一特性，可以在 CPU 里放一块缓存，用来存放最常访问的页表项。
这个缓存就是页表缓存（Translation Lookaside Buffer、TLB、快表、转址旁路缓存等）


