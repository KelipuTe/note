---
draft: false
date: 2023-01-29 08:00:00 +0800
lastmod: 2023-01-29 08:00:00 +0800
title: "队列（Golang 实现）"
summary: "并发安全队列；优先队列；延迟队列；"
toc: true

categories:
- golang

tags:
- computer-science(计算机科学)
- programming-language(编程语言)
- golang
- queue(队列)
- concurrent(并发)
---

> CPU AMD64(x86_64)<br/>
> Windows 11 家庭版<br/>
> go version go1.19 windows/amd64

### 资料

- [{demo-golang}](https://github.com/KelipuTe/demo-golang)/demo/queue/
- <a href="/drawio/computer-science/programming-language/golang/queue.drawio.html">queue.drawio.html</a>

### 并发安全队列

并发安全队列就是不会出现并发问题的队列。

关于并发问题的一些东西在这篇里：[并发问题](/计算机/concurrency_issues)

### 阻塞队列和非阻塞队列

个人认为，一个队列是阻塞队列还是非阻塞队列，应该根据队列本身的设计判断。队列需不需要阻塞，是设计上决定的，和用锁还是用 CAS 是没关系的，这两个结构是为了解决并发问题的。

如果设计队列的时候，队列有最大容量。而且队列本身的设计中有阻塞的逻辑。这样的队列就是阻塞队列。比如，在入队阶段，判断队列容量已满的时候，不是直接返回入队失败，而是等待队列空出位置后在入队，那么这里就需要设计阻塞的逻辑。

反之，如果设计队列的时候，队列有最大容量，但是队列本身的设计中没有阻塞的逻辑，或者队列没有最大容量，那就是非阻塞队列。比如，在入队阶段，判断队列容量已满的时候，直接返回入队失败，那么这里就不需要设计阻塞的逻辑。

### 并发安全的有最大容量的队列

代码详见：

- {demo-golang}/demo/queue/concurrent_blocking_queue.go。
- {demo-golang}/demo/queue/wait_cond.go。

这里沿用上面的定义。想要一个并发安全的有最大容量的队列的两个要求：1、并发安全；2、有最大容量。这里用锁+环形数组实现。因为有最大容量的限制，所以肯定是需要阻塞的逻辑的。

从最简单的入队出队逻辑开始。入队：检查容量->(等待有空位：比如循环检查容量)->入队。出队：检查容量->(等待有数据：比如循环检查容量)->出队。这种结构可以满足有最大容量的要求，但是因为对临界资源（队列数据）的访问是没有限制的，所以这肯定不是并发安全的。

既然要保护临界资源，那么首先想到的肯定是加锁。Golang 里面就是 sync.Mutex 了。直接加锁行不行呢？入队：加锁->检查容量->(等待有空位：比如循环检查容量)->入队->解锁。出队：加锁->检查容量->(等待有数据：比如循环检查容量)->出队->解锁。这样的逻辑显然会在"等待有空位"和"等待有数据"这两个步骤产生死锁。

如果队列满了，"等待有空位"这里就无法入队，导致锁放不掉。这里锁放不掉，出队那里就加不了锁，无法出队。如果队列为空，"等待有数据"这里就无法出队，导致锁放不掉。这里锁放不掉，入队那里就加不了锁，无法入队。

所以加锁之后，"等待有空位"和"等待有数据"这个两步骤需要修改。"等待有空位"需要先解锁，这样出队那里就可以加锁。然后等待有空位。等到有空位之后，再加锁，然后入队。"等待有数据"需要先解锁，这样入队那里就可以加锁。然后等待有数据。等到有数据之后，再加锁，然后出队。

大概的过程见图：**queue.drawio.html 2-2、2-4**

Golang 里面提供了这种工具 sync.Cond。可以先看一眼官方提供的 sync.Cond.Wait() 里面的逻辑。执行逻辑很简单，大概是：获取一个用于等通知的结构；把拿着的锁放掉；阻塞，等通知；等到通知了，把锁加回来。

```
func (c *Cond) Wait() {
	c.checker.check()
	t := runtime_notifyListAdd(&c.notify)
	c.L.Unlock()
	runtime_notifyListWait(&c.notify, t)
	c.L.Lock()
}
```

有了这个结构。出队的那个地方出队的时候，发一个信号给"等待有空位"就行。入队的那个地方入队的时候，发一个信号给"等待有数据"就行。这样并发问题也就解决了。加锁可以在并发场景中保护队列数据的正确性，但是用 sync.Mutex 和 sync.Cond 有一个缺点，这玩意无法控制超时。

用 sync.Mutex 执行 sync.Mutex.Lock() 之后，gorouting 就陷进去了，直到它拿到锁，否则是不会出来的。用 sync.Cond 也一样。执行 sync.Cond.Wait() 之后，gorouting 一样会陷进去，直到它被 sync.Cond.Signal() 或者 sync.Cond.Broadcast() 发出的信号唤醒，否则也是不会出来的。

所以这里需要的是一个可以被控制的等待加锁的结构。也就是说要一个 sync.Mutex.Luck(time) 或者 sync.Cond.Wait(time) 这样的东西。如果一定时间拿不到锁，或者等不到信号，要能从阻塞状态退出来。

仔细观察一下 Wait() 的代码。里面加锁和解锁的步骤是必须的，所以核心问题其实就找到了。需要修改原有的等通知的逻辑，让这里变成既可以等待信号，同时也可以被 context 超时控制的结构。在 Golang 里面，等待信号可以使用 channel（管道）。这玩意可以变相的做到，既可以被阻塞，也可以在需要的时候被唤醒。

可以把读一个空的管道理解成阻塞，把从管道里读到东西理解成唤醒。如果需要模拟阻塞，那么就读一个空的管道就可以了。唤醒这里需要一点技巧，这里不能用往管道里写数据的方式去唤醒阻塞中的 gorouting。因为不知道到底有多少个 gorouting 在等着读数据，也就是不知道要写多少次数据。写少了，会有等着的 gorouting 读不到数据，会泄露。写多了自己会阻塞，也会泄露。

这里可以用直接关闭管道的思路，读取已经关闭的管道会读到零值。那么关闭一个有很多 gorouting 都在读取的管道，就相当于完成了一次 Broadcast()。但是这种操作无法实现 Signal()。新的方法里面的逻辑大概就是下面这样（伪代码）。

```
func (p7this *Cond) WaitWithTimeout(ctx context.Context) error {
	// 获取一个用于等通知的 channel
	// 把拿着的锁放掉
	select {
	case <-ctx.Done():
		// 超时，这里就不用把锁加回来了。外层应该拿到这里的异常，然后执行异常处理逻辑。
		return ctx.Err()
	case <-通知信号:
		// 等到通知了，说明有 gorouting 调用了 Broadcast() 关闭了 channel，把锁加回来。
		// 这个地方并没有完全解决超时的问题，因为这里加锁的逻辑还是有可能被阻塞的。
	}
}
```

### 并发安全的没有最大容量的队列

代码详见：

- {demo-golang}/demo/queue/concurrent_nonblocking_queue.go。

这里沿用上面的定义。想要一个并发安全的没有最大容量的队列的两个要求：1、并发安全；2、没有最大容量。这里用链表+CAS+自旋实现。因为没有最大容量，所以是不需要设计阻塞逻辑的。

还是从最简单的入队出队逻辑开始。因为没有最大容量，所以入队时是没有限制的。出队这里，和入队哪里保持一致，不设计阻塞逻辑。所以队列为空的时候，就直接返回一个异常就行。当然，出队如果想设计成一直等到有数据再出队的逻辑也不是不行。

所以基本的逻辑就可以定下来了。入队：入队。出队：检查队头->出队。和前面一样，因为对临界资源（队列数据）的访问是没有限制的，所以这肯定不是并发安全的。

如果选择用加锁的方式保护临界资源，那么基本思路就和前面的那个"并发安全的有最大容量的队列"是一样的。这里就不重复了，这里换另一个处理思路，用 CAS+自旋达到和锁一样的效果。改造后的步骤也不是很复杂。入队：准备好数据->使用 CAS 入队。出队：检查队头->使用 CAS 出队。

CAS 入队怎么入呢？入队的时候，最关心的是队尾，因为新结点会连接到原来的队尾结点上去，变成新的队尾结点。所以只要保护住"替换队尾结点"这个步骤，就能避免出现并发问题。所以 CAS 操作的目标就可以确定了，原来的队尾结点和新结点。

```
func (p7this *Queue) Enqueue(ctx context.Context, data) error {
	// 先把新的结点准备好
	// 然后通过 CAS 操作挂到链表的尾部
	for {
		// 通过原子操作把队尾拿出来
		// CAS 操作，如果当前的队尾指针就是上面取到的指针，那么把队尾换成新的结点
		if atomic.CompareAndSwapPointer(队尾, 取到的队尾, 新结点) {
			// CAS 返回成功，说明队尾没变，可以直接修改
			// 把新结点接到原来的队尾结点上去
		}
		// CAS 返回失败，说明队尾变了，其他想要入队的，已经抢先入队而且完成了，那就要重头再来
	}
}
```

CAS 出队怎么出呢？出队的时候，最关心的是队头，因为队头结点出队之后，队头结点的下一个结点会接替原来的队头结点成为新的队头结点。所以只要保护住"接替原来的队头结点"这个步骤，就能避免出现并发问题。所以 CAS 操作的目标就可以确定了，原来的队头结点和队头结点的下一个结点。

```
func (p7this *Queue) Dequeue(ctx context.Context) (data, error) {
	for {
		// 检查队列是否为空
		// 通过原子操作把队头拿出来
		if atomic.CompareAndSwapPointer(队头, 取到的队头, 队头结点的下一个结点) {
			// CAS 返回成功，说明队头没变，可以直接修改
			// 直接把结点上的数据取出来，然后出队就行了
		}
		// CAS 返回失败，说明队头变了，其他想要出队的，已经抢先出队而且完成了，那就要重头再来
	}
}
```

思路比较简单，就是理解起来很不直观，这里需要借助调度时候的时序图来理解。详细的入队出队的调度过程见图。入队：**queue.drawio.html 4-6、4-6-2、4-6-4、4-6-4-2、4-6-4-4**。出队：**queue.drawio.html 4-8、4-8-2、4-8-4、4-8-4-2、4-8-4-4**。注意里面红色标记的结点，因为协程会在任意时刻被剥夺 CPU 资源，所以会出现部分步骤没完成的场景。

### 延迟队列

代码详见：

- {demo-golang}/demo/queue/delay_queue.go
- {demo-golang}/demo/queue/priority_queue.go
- {demo-golang}/demo/queue/wait_cond_v2.go

延迟队列就是进入队列的元素有时间属性，在时间到之前不能出队。入队的时候没有什么限制，问题在出队这里。简单的搞法，直接整一个轮询不停地全量扫描，这是可以达到目的的，就是会占用 CPU 资源。

但是如果队列里面的元素很多，那全量扫描的时间，说不定队列里面已经有元素到时间了。所以最好对队列元素进行排序，搞成有优先级的，这样每次只需要检查第一个元素就行了。

这里借助时间属性给元素确定优先级，那么时间小的就应该排在前面。加上需要不停地进行插入和删除操作，普通的数组就不太合适了，比较合适的数据结构是小根堆。

优先队列可以解决全量扫描的问题，但是暴力轮询的问题还没有解决。如果不暴力轮询，那么中间就需要加入阻塞等待的机制，这个就稍微麻烦一点了。

首先，阻塞固定的时间是肯定不行的，在这段时间里面，队头元素说不定已经到时间了。所以阻塞的时间肯定要根据队头元素来，队头元素还有多久到时间，那就阻塞多久。这种思路可以解决队列元素不变的情况。但是如果等待过程中，入队了一个优先级更高的元素。那么这个思路也是有问题的，阻塞之后来不及出来了。

所以这里需要监听两种信号，一种是队头元素到时间的信号，另一种是入队信号。监听到入队信号之后，检查一下入队的元素的优先级，如果优先级更高就需要调整阻塞的时间。

整体思路和前面的那个"并发安全的有最大容量的队列"是一样的，就是队列数据的存储结构不一样，然后就是增加了针对延时的逻辑。大概的过程见图：**queue.drawio.html 6-2、6-4**

## 参考（reference）

- [极客时间](https://time.geekbang.org/)
  - Go实战训练营
    - 并发等待队列实现
