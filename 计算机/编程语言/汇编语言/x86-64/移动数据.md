---
draft: false
date: 2023-07-12 08:00:00 +0800
title: "移动数据"
summary: "移动数据；间接寻址；"
toc: true

categories:
  - 汇编语言

tags:
  - 计算机科学
  - 编程语言
  - 汇编语言
---

## 资料

图：/content/计算机/programming-language/assembly/assembly.drawio

## 正文

### bswap

bswap，用于翻转寄存器上的数据的字节序。
主要用于小端字节序和大端字节序相互转换。

### lea

lea，用于获取内存地址。
主要用于把变量的内存地址传输到寄存器中。

### mov

mov，用于移动数据，把源操作数复制到目标操作数。
使用的时候需要注意，两个操作数的大小必须相同。

`mov 变量名, 寄存器`，表示移动变量上存储的值到寄存器。我的理解，这个时候是内存操作数的逻辑。
`mov $变量名, 寄存器`，表示移动变量的起始地址到寄存器。我的理解，这个时候是立即数的逻辑。

如果传输的数据是数组或者结构体这样的。那么就需要使用内存操作数，也就是间接寻址。
内存操作数的格式是 `displacement(base, index, scale)`。

- displacement，常量或者内存操作数；
- base，地址寄存器（可选参数），内存操作数；
- index，索引寄存器（可选参数）。比如，数组下标；
- scale，缩放因子，可以是 1,2,4,8；
- 获取的数据的起始地址就位于 displacement + base + index * size。

常用的用法有两种，下面用数组举例。

```
.section .data
    array1: .int 1,2,3,4,5
```

第一种用法。

```
movl $2, %r8d
movl array1(,%r8,4), %r10d
```

- displacement 是 array1，array1 对应的是一个内存操作数，也就是数组的起始地址。
- base 不填；index 下标是 2；scale 缩放因子是 4，对应 int 的长度。
- 获取的数据的起始地址就位于 "array1 + 2 * 4"，数组的起始地址向后偏移 8，也就是下标为 2 的第 3 个元素。

写成 c 语言就相当于这样。

```
array1 int[5] = {1,2,3,4,5}
r9d = *(array1+2)
```

第二种用法。

```
movq $array1, %r8
movl 4(%r8), %r10d
```

- displacement 是 4，常量。
- base 地址是 array1，array1 对应的是一个内存操作数，也就是数组的起始地址。index 不填；scale 不填。
- 获取的数据的起始地址就位于 "4 + array1 + 0 * 0"，数组的起始地址向后偏移 4，也就是下标为 1 的第 2 个元素。

### movsx

movsx，带符号扩展数据。

8 位的 -1（1111,1111），带符号扩展到 16 位，依然是 -1（1111,1111,1111,1111）。

### movzx

movsx，扩展数据后填充 0。

8 位的 -1（1111,1111），扩展到 16 位后填充 0，就不是 -1 了，而是 255（0000,0000,1111,1111）。

### xchg

xchg，用于交换数据。
