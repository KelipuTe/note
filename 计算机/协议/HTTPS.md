---
draft: false
title: "HTTPS"
summary: "HTTPS"
toc: true

categories:
  - 协议

tags:
  - 计算机
  - 协议

date: 2022-05-06 08:00:00 +0800
---

## 反向链接

[HTTP](/计算机/协议/HTTP)；

## 正文

- SSL：Secure Sockets Layer、安全套接层
- TLS：Transport Layer Security、传输层安全协议
- MITM：Man-in-the-MiddleAttack、中间人攻击
- MD5 算法：Message-Digest Algorithm 5、信息-摘要算法 5

### HTTPS

HTTPS 是 HTTP 和 SSL、TLS 的组合。SSL 标准化之后名字改成了 TLS。

由于 HTTP 是明文传输的，所以，存在三个方面的风险。

- 被窃听的风险：在通信链路上可以拦截通信内容。
- 被篡改的风险：拦截后在报文内植入垃圾数据。
- 被冒充的风险：无法确认报文数据的真实性。

### 加密

使用加密技术可以解决被窃听的问题。

HTTPS 使用的是混合加密的技术，混合加密技术包括对称加密和非对称加密。

- 加密和解密用同一个秘钥的加密方式叫做对称加密。
- 非对称加密会有一对秘钥：公钥和私钥。
  公钥加密的内容，私钥可以解开；私钥加密的内容，公钥可以解开；

对称加密，因为加密解密使用的是同一个秘钥，所以双方都必须知道这个秘钥是什么。
这就要求所有发送端都要有秘钥，这显然不合理。
因为只要有一个发送端的秘钥泄露，那么整个环境的加密就不安全了。
而且就算所有的发送端都能保证安全，秘钥传输的过程也是不安全的。

非对称加密的私钥只保存在接收端，公钥可以发送给所有的发送端。
在传输公钥的过程中，肯定也会有被中间人获取的风险。
但是，至少可以保证发送端通过公钥加密的内容，中间人是无法破解的。
因为私钥只保存在接收端，只有私钥可以破解公钥加密的内容。

对称加密的速度相对非对称加密而言更快。
所以 HTTPS 的策略是，先使用非对称加密加密对称加密的秘钥。
在双方都得到对称加密的秘钥之后，后续通信都使用对称加密。

### HTTPS 握手示意图

<table>
<tr align="center"><td>发送端</td><td></td><td>接收端</td></tr>
<tr align="center"><td colspan="3">TCP 三次握手</td></tr>
<tr align="center"><td>生成一个随机数，发起加密通信请求</td><td></td><td></td></tr>
<tr align="center"><td></td><td>client hello ==>></td><td></td></tr>
<tr align="center"><td></td><td></td><td>生成一个随机数，响应接收端的证书</td></tr>
<tr align="center"><td></td><td><<==server hello</td><td></td></tr>
<tr align="center">
<td>
验证证书。生成一个随机数，用接收端的公钥加密。
用三个随机数组合出对称加密秘钥；用之前所有的内容计算一个信息摘要；
</td>
<td></td><td></td>
</tr>
<tr align="center"><td></td><td>client key ==>></td><td></td></tr>
<tr align="center">
<td></td><td></td>
<td>
取出加密后的随机数，用私钥解密；用三个随机数组合出对称加密秘钥；
用之前所有的内容计算一个信息摘要，比对发送端的摘要和自己的摘要；
</td>
</tr>
<tr align="center"><td colspan="3">HTTPS 握手结束</td></tr>
<tr align="center"><td colspan="3">后续的通信使用对称加密</td></tr>
</table>

### 信息摘要

使用信息摘要技术可以解决被篡改的问题。

任意一端在发送数据之前，先通过信息摘要算法，计算出一个摘要。
然后将明文数据和摘要一起加密作为报文的正文。

接收端收到加密的报文后，解密得到明文数据和发送方计算的摘要。
然后，接收端使用相同的信息摘要算法再计算出一个摘要。
如果接收端计算出的摘要和报文解密后得到的摘要一致，那就说明，信息没有被篡改。

### 数字证书

使用 "数字证书 + 第三方认证" 可以解决被冒充的问题。

#### MITM

MITM 是一种网络攻击方式。在发送端向接收端索要公钥时，中间人截获接收端公钥。
然后生成一个伪造公钥发给发送端。这个时候，发送端拿到的公钥就是假的。
公钥被掉包，是因为发送端无法分辨传回公钥的到底是中间人还是接收端。

#### 第三方认证

MD5 算法本身并不是一个加密算法。
因为数据经过 MD5 之后，是无法通过解密的手段得到原始信息的。

将网站的信息（主要是公钥）通过 MD5 计算摘要后，将摘要交给第三方机构。
通过第三方机构的私钥再次进行加密，生成数字签名。
最后生成一个数字证书，$数字证书 = 网站信息的摘要 + 数字签名$。

假如，中间人拦截后，把接收端的公钥替换为自己的公钥。
因为数字签名的存在，会导致发送端验证签名不匹配。这样就防止了中间人替换公钥的问题。

浏览器安装后，会内置一些权威第三方认证机构的公钥，
比如 VeriSign、Symantec、GlobalSign 等。
验证签名时，直接从本地就可以拿到相应第三方机构的公钥，
然后用公钥对私钥加密后的数字签名进行解密，得到真正的签名。

然后，浏览器使用签名生成规则进行签名生成，看两个签名是否匹配。
如果匹配认证通过，不匹配则获取证书失败。