---
draft: false
date: 2023-02-20 08:00:00 +0800
lastmod: 2023-02-20 08:00:00 +0800
title: "ALU（arithmetic and logic unit、算术逻辑单元）"
summary: "什么是 ALU；什么是逻辑门；逻辑门的原理；ALU 的原理；"
toc: true

categories:
- hardware(硬件)

tags:
- computer-science(计算机科学)
- hardware(硬件)
---

## 资料

- <a href="/drawio/computer-science/hardware/alu.drawio.html">alu.drawio.html</a>


## 正文

### ALU

ALU（arithmetic and logic unit、算术逻辑单元）由 AU（算术单元）、LU（逻辑单元）组成。算术单元由逻辑门、半加器、全加器、加法器等各种各样的单元组成。逻辑单元，由大量逻辑门组成。ALU 的主要功能是进行二进制的算术运算。

### 机械继电器

机械继电器主要由机械开关和电磁铁组成（见图：**alu.drawio.html 2-2**）。

当控制线不通电时，电磁铁不产生磁性，开关断开，输出端没有电，表示输出 0；当控制线通电时，电磁铁产生磁性，开关闭合，输出端有电，表示输出 1（见图：**alu.drawio.html 2-4-2、2-4-4**）。

### 二极管

二极管通常由半导体材料制造。半导体是指在常温下导电性范围介于导体和绝缘体之间的材料，最关键的特点就是导电性可控。

画一个简单的二极管的示意图（见图：**alu.drawio.html 4-2**），里面最关键的就是控制线和半导体。假设，当控制线不通电时，半导体不导通，这个时候输出端没有电，表示输出 0；当控制线通电时，半导体导通，这个时候输出端有电，表示输出 1（见图：**alu.drawio.html 4-4-2、4-4-4**）。

下文的逻辑电路都会用到这个简单的二极管。

### 逻辑门

#### 与门

AND gate（与门）就是实现了与运算的逻辑电路，串联两个二极管就可以实现（见图：**alu.drawio.html 6-2**）。

| 操作数 1 | 操作数 2 | 运算结果 |          示意图          |
|:-----:|:-----:|:----:|:---------------------:|
|   0   |   0   |  0   | alu.drawio.html 6-4-2 |
|   1   |   0   |  0   | alu.drawio.html 6-4-4 |
|   0   |   1   |  0   | alu.drawio.html 6-4-6 |
|   1   |   1   |  1   | alu.drawio.html 6-4-8 |

#### 或门

OR gate（或门）就是实现了或运算的逻辑电路，并联两个二极管就可以实现（见图：**alu.drawio.html 8-2**）。

| 操作数 1 | 操作数 2 | 运算结果 |          示意图          |
|:-----:|:-----:|:----:|:---------------------:|
|   0   |   0   |  0   | alu.drawio.html 8-4-2 |
|   1   |   0   |  1   | alu.drawio.html 8-4-4 |
|   0   |   1   |  1   | alu.drawio.html 8-4-6 |
|   1   |   1   |  1   | alu.drawio.html 8-4-8 |

#### 非门

NOT gate（非门）就是实现了非运算的逻辑电路，一个二极管加上短路的设计就可以实现（见图：**alu.drawio.html 10-2**）。

| 操作数  | 运算结果 |          示意图           |
|:----:|:----:|:----------------------:|
|  0   |  1   | alu.drawio.html 10-4-2 |
|  1   |  0   | alu.drawio.html 10-4-4 |

#### 异或门

XOR gate（Exclusive-OR gate、异或门）就是实现了异或运算的逻辑电路，异或门由上面三个基本逻辑门组成（见图：**alu.drawio.html 12-2**）。

| 操作数 1 | 操作数 2 | 运算结果 |          示意图           |
|:-----:|:-----:|:----:|:----------------------:|
|   0   |   0   |  0   | alu.drawio.html 12-4-2 |
|   1   |   0   |  1   | alu.drawio.html 12-4-4 |
|   0   |   1   |  1   | alu.drawio.html 12-4-6 |
|   1   |   1   |  0   | alu.drawio.html 12-4-8 |

### 算术单元

#### 半加器

half adder（半加器）由异或门、与门组成（见图：**alu.drawio.html 14-2**）。可以处理两个 1 位二进制数的加法运算，产生两个输出，一个表示和，一个表示进位。

| 操作数 1 | 操作数 2 | 运算结果 | 进位  |  和  |          示意图           |
|:-----:|:-----:|:----:|:---:|:---:|:----------------------:|
|   0   |   0   |  00  |  0  |  0  | alu.drawio.html 14-4-2 |
|   1   |   0   |  01  |  0  |  1  | alu.drawio.html 14-4-4 |
|   0   |   1   |  01  |  0  |  1  | alu.drawio.html 14-4-6 |
|   1   |   1   |  10  |  1  |  0  | alu.drawio.html 14-4-8 |

#### 全加器

full adder（全加器）由半加器、或门组成（见图：**alu.drawio.html 16-2**）。可以处理三个 1 位二进制数的加法运算，产生 2 个输出，1 个表示和，一个表示进位。

| 操作数 1 | 操作数 2 | 操作数 3 | 运算结果 | 进位  |  和  |           示意图           |
|:-----:|:-----:|:-----:|:----:|:---:|:---:|:-----------------------:|
|   0   |   0   |   0   |  00  |  0  |  0  | alu.drawio.html 16-4-2  |
|   1   |   0   |   0   |  01  |  0  |  1  | alu.drawio.html 16-4-4  |
|   0   |   1   |   0   |  01  |  0  |  1  | alu.drawio.html 16-4-6  |
|   0   |   0   |   1   |  01  |  0  |  0  | alu.drawio.html 16-4-8  |
|   1   |   1   |   0   |  10  |  1  |  0  | alu.drawio.html 16-4-10 |
|   1   |   0   |   1   |  10  |  1  |  0  | alu.drawio.html 16-4-12 |
|   0   |   1   |   1   |  10  |  1  |  0  | alu.drawio.html 16-4-14 |
|   1   |   1   |   1   |  11  |  1  |  1  | alu.drawio.html 16-4-16 |

#### 两个 2 位二进制数加法

运算电路由半加器、全加器组成（见图：**alu.drawio.html 18-2**）。可以处理两个 2 位二进制数的加法运算，产生 3 个输出，2 个表示和，一个表示进位。

| 操作数 1 | 操作数 2 | 运算结果  |  进位  | 和 2 | 和 1 |           示意图           |
|:-----:|:-----:|:-----:|:----:|:---:|:---:|:-----------------------:|
|  00   |  00   |  000  |  0   |  0  |  0  | alu.drawio.html 16-4-2  |
|  01   |  00   |  001  |  0   |  0  |  1  | alu.drawio.html 16-4-4  |
|  00   |  01   |  001  |  0   |  0  |  1  | alu.drawio.html 16-4-6  |
|  01   |  01   |  010  |  0   |  1  |  0  | alu.drawio.html 16-4-8  |
|  10   |  00   |  010  |  0   |  1  |  0  | alu.drawio.html 16-4-10 |
|  00   |  10   |  010  |  0   |  1  |  0  | alu.drawio.html 16-4-12 |
|  10   |  01   |  011  |  0   |  1  |  1  | alu.drawio.html 16-4-14 |
|  01   |  10   |  011  |  0   |  1  |  1  | alu.drawio.html 16-4-16 |
|  10   |  10   |  100  |  1   |  0  |  0  | alu.drawio.html 16-4-18 |
|  11   |  00   |  011  |  0   |  1  |  1  | alu.drawio.html 16-4-20 |
|  00   |  11   |  011  |  0   |  1  |  1  | alu.drawio.html 16-4-22 |
|  11   |  01   |  100  |  1   |  0  |  0  | alu.drawio.html 16-4-24 |
|  01   |  11   |  100  |  1   |  0  |  0  | alu.drawio.html 16-4-26 |
|  11   |  10   |  101  |  1   |  0  |  1  | alu.drawio.html 16-4-28 |
|  10   |  11   |  101  |  1   |  0  |  1  | alu.drawio.html 16-4-30 |
|  11   |  11   |  110  |  1   |  1  |  0  | alu.drawio.html 16-4-32 |

#### 行波进位加法器

参考"两个 2 位二进制数加法"的运算电路，就可以设计出"两个 n 位二进制数加法"的运算电路。这里画一个 8 bit ripple carry adder（8 位行波进位加法器）的示意图（见图：**alu.drawio.html 20-2**）。可以处理两个 8 位二进制数的加法运算，产生 9 个输出，8 个表示和，一个表示进位。

### 逻辑单元

逻辑单元简单的理解就是，用不同逻辑门的组合，判断输入是不是满足某个条件。

#### 判断是否为 0

判断 4 位二进制输入是不是 0（见图：**alu.drawio.html 30-2**）。二进制数的 4 个位上只有全是 0 时，才输出 1；二进制数的 4 个位上只要有一个非 0，就输出 0（见图：**alu.drawio.html 30-4-2 30-4-4**）。

### ALU

ALU 是由算术单元和逻辑单元组成的，这里画一个简单的 ALU 的示意图（见图：**alu.drawio.html 60-2**），真正的 ALU 会有更多的东西。

这里假设是一个可以处理 8 位二进制数的 ALU。它有，两个数据输入（两个操作数）、一个 operation code（操作码）输入（加法还是减法）、一个数据输出（运算的结果）、3 个 flag（标志位）输出（overflow 是否溢出、zero 是否为 0、negative 负标志）。

下面举几个例子：

计算 11111111 + 11111111。两个数据输入就是 11111111 和 11111111、操作码输入就是 0001（表示加法）。这个时候，因为 11111111 + 11111111 = 1 11111110，它溢出了。所以数据输出会是 11111110、overflow 会是 1。

计算 11111111 == 11111111。判断两个数字是否相等，可以用相减之后和 0 比较的思路。那么，两个数据输入就是 11111111 和 11111111、操作码输入就是 0002（表示减法）。这个时候，因为 11111111 - 11111111 = 00000000，为 0。所以数据输出会是 00000000、zero 会是 1。

计算 11111111 < 11111110。判断两个数字的大小，可以用相减之后和 0 比较的思路。那么，两个数据输入就是 11111111 和 11111110、操作码输入就是 0002（表示减法）。这个时候，因为 11111111 - 11111110 = 00000001，大于 0。所以数据输出会是 00000001、negative 会是 0（表示 11111111 - 11111110 > 0）。如果是 11111110 - 11111111，那 negative 就会是 1。

## reference（参考）

- Crash Course Computer Science（计算机科学速成课）
    - [bilibili](https://www.bilibili.com/video/BV1EW411u7th)
    - [CrashCourse 字幕组](https://github.com/1c7/crash-course-computer-science-chinese)
    - [Youtube 原视频](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulI)