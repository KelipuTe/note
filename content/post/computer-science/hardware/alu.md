---
draft: false
date: 2023-02-20 08:00:00 +0800
lastmod: 2023-02-20 08:00:00 +0800
title: "ALU（Arithmetic and Logic Unit、算术逻辑单元）"
summary: "什么是 ALU；什么是逻辑门；逻辑门的原理；ALU 的原理；"
toc: true

categories:
- hardware(硬件)

tags:
- computer-science(计算机科学)
- hardware(硬件)
---

## 资料

- <a href="/drawio/computer-science/hardware/alu.drawio.html">alu.drawio.html</a>

## 正文

### 机械继电器

早期的计算机用机械结构来控制电路的状态，这个部件叫机械继电器。机械继电器主要由机械开关和电磁铁组成（见图：**alu.drawio.html 2-2**）。

当控制线不通电时，电磁铁不产生磁性，开关断开，输出端没有电，表示输出 0；当控制线通电时，电磁铁产生磁性，开关闭合，输出端有电，表示输出 1。（见图：**alu.drawio.html 2-4-2、2-4-4**）

### 二极管

随着技术的发展，后来用二极管替换了机械继电器来控制电路的状态。二极管通常由半导体材料制造，半导体是指在常温下导电性范围介于导体和绝缘体之间的材料，最关键的特点就是导电性可控。

这里画一个简单的二极管的示意图（见图：**alu.drawio.html 4-2**），里面最关键的部分是控制线和半导体。下文的逻辑电路都会用到这个简单的二极管。

当控制线不通电时，半导体不导通，输出端没有电，表示输出 0；当控制线通电时，半导体导通，输出端有电，表示输出 1。（见图：**alu.drawio.html 4-4-2、4-4-4**）

### 逻辑门

#### 与门

AND gate（与门）就是实现了与运算的逻辑电路，串联两个二极管就可以实现（见图：**alu.drawio.html 22-2**）。

| 输入 1 | 输入 2 | 运算结果 |          示意图           |
|:-----:|:-----:|:----:|:----------------------:|
|   0   |   0   |  0   | alu.drawio.html 22-4-2 |
|   1   |   0   |  0   | alu.drawio.html 22-4-4 |
|   0   |   1   |  0   | alu.drawio.html 22-4-6 |
|   1   |   1   |  1   | alu.drawio.html 22-4-8 |

#### 或门

OR gate（或门）就是实现了或运算的逻辑电路，并联两个二极管就可以实现（见图：**alu.drawio.html 24-2**）。

| 输入 1 | 输入 2 | 运算结果 |          示意图           |
|:-----:|:-----:|:----:|:----------------------:|
|   0   |   0   |  0   | alu.drawio.html 24-4-2 |
|   1   |   0   |  1   | alu.drawio.html 24-4-4 |
|   0   |   1   |  1   | alu.drawio.html 24-4-6 |
|   1   |   1   |  1   | alu.drawio.html 24-4-8 |

#### 非门

NOT gate（非门）就是实现了非运算的逻辑电路，一个二极管加上短路的设计就可以实现（见图：**alu.drawio.html 26-2**）。

| 输入  | 运算结果 |          示意图           |
|:----:|:----:|:----------------------:|
|  0   |  1   | alu.drawio.html 26-4-2 |
|  1   |  0   | alu.drawio.html 26-4-4 |

#### 异或门

XOR gate（Exclusive-OR gate、异或门）就是实现了异或运算的逻辑电路，异或门由与门、或门、非门组成（见图：**alu.drawio.html 28-2**）。

| 输入 1 | 输入 2 | 运算结果 |          示意图           |
|:-----:|:-----:|:----:|:----------------------:|
|   0   |   0   |  0   | alu.drawio.html 28-4-2 |
|   1   |   0   |  1   | alu.drawio.html 28-4-4 |
|   0   |   1   |  1   | alu.drawio.html 28-4-6 |
|   1   |   1   |  0   | alu.drawio.html 28-4-8 |

### ALU

ALU（arithmetic and logic unit、算术逻辑单元）由 AU（算术单元）和 LU（逻辑单元）组成。

### 算术单元

算术单元由逻辑门、半加器、全加器、加法器等部件组成，主要的功能是进行算术运算。

#### 半加器

half adder（半加器）由异或门、与门组成（见图：**alu.drawio.html 42-2**）。可以处理两个 1 位二进制数的加法运算，产生 2 个输出：一个 carry（进位）、一个 sum（和）。

| 输入 1 | 输入 2 | 运算结果 | carry  | sum |          示意图           |
|:-----:|:-----:|:----:|:---:|:---:|:----------------------:|
|   0   |   0   |  00  |  0  |  0  | alu.drawio.html 42-4-2 |
|   1   |   0   |  01  |  0  |  1  | alu.drawio.html 42-4-4 |
|   0   |   1   |  01  |  0  |  1  | alu.drawio.html 42-4-6 |
|   1   |   1   |  10  |  1  |  0  | alu.drawio.html 42-4-8 |

#### 全加器

full adder（全加器）由半加器、或门组成（见图：**alu.drawio.html 44-2**）。可以处理三个 1 位二进制数的加法运算，产生 2 个输出：一个 carry、1 个 sum。

| 输入 1 | 输入 2 | 输入 3 | 运算结果 | carry  |  sum  |           示意图           |
|:-----:|:-----:|:-----:|:----:|:---:|:---:|:-----------------------:|
|   0   |   0   |   0   |  00  |  0  |  0  | alu.drawio.html 44-4-2  |
|   1   |   0   |   0   |  01  |  0  |  1  | alu.drawio.html 44-4-4  |
|   0   |   1   |   0   |  01  |  0  |  1  | alu.drawio.html 44-4-6  |
|   0   |   0   |   1   |  01  |  0  |  0  | alu.drawio.html 44-4-8  |
|   1   |   1   |   0   |  10  |  1  |  0  | alu.drawio.html 44-4-10 |
|   1   |   0   |   1   |  10  |  1  |  0  | alu.drawio.html 44-4-12 |
|   0   |   1   |   1   |  10  |  1  |  0  | alu.drawio.html 44-4-14 |
|   1   |   1   |   1   |  11  |  1  |  1  | alu.drawio.html 44-4-16 |

#### 两个 2 位二进制数加法

实现运算的电路由半加器、全加器组成。（见图：**alu.drawio.html 46-2**）该电路可以处理两个 2 位二进制数加法运算，产生 3 个输出：一个 carry、2 个 sum（注意顺序）。

这里简要描述一下二进制加法运算的逻辑，用 0b11（A） + 0b11（B）举例。为了描述方便，这里借用 10 进制的个位、十位、百位的概念。先把 0b11 拆成十位的 1（A1、B1） 和个位的 1（A0、B0）。

在进行加法运算的时候，先进行个位和个位的加法，这里只有两个参数，两个个位（A0 和 B0），所以由半加器进行运算。1 + 1 = 10，产生 2 个输出：carry = 1、sum1 = 0。

然后进行十位和十位的加法，这里有三个参数，两个十位（A1 和 B1）还有个位相加的进位（carry），所以这里需要全加器进行运算。1 + 1 + 1 = 11，产生 2 个输出：carry = 1、sum2 = 1。所以最后的结果就是 0b110，carry = 1、sum2 = 1、sum1 = 0。

| 输入 A | 输入 B | 运算结果  |  carry  | sum2 | sum1 |           示意图           |
|:------:|:-----:|:-----:|:----:|:---:|:---:|:-----------------------:|
|   00   |  00   |  000  |  0   |  0  |  0  | alu.drawio.html 46-4-2  |
|   01   |  00   |  001  |  0   |  0  |  1  | alu.drawio.html 46-4-4  |
|   00   |  01   |  001  |  0   |  0  |  1  | alu.drawio.html 46-4-6  |
|   01   |  01   |  010  |  0   |  1  |  0  | alu.drawio.html 46-4-8  |
|   10   |  00   |  010  |  0   |  1  |  0  | alu.drawio.html 46-4-10 |
|   00   |  10   |  010  |  0   |  1  |  0  | alu.drawio.html 46-4-12 |
|   10   |  01   |  011  |  0   |  1  |  1  | alu.drawio.html 46-4-14 |
|   01   |  10   |  011  |  0   |  1  |  1  | alu.drawio.html 46-4-16 |
|   10   |  10   |  100  |  1   |  0  |  0  | alu.drawio.html 46-4-18 |
|   11   |  00   |  011  |  0   |  1  |  1  | alu.drawio.html 46-4-20 |
|   00   |  11   |  011  |  0   |  1  |  1  | alu.drawio.html 46-4-22 |
|   11   |  01   |  100  |  1   |  0  |  0  | alu.drawio.html 46-4-24 |
|   01   |  11   |  100  |  1   |  0  |  0  | alu.drawio.html 46-4-26 |
|   11   |  10   |  101  |  1   |  0  |  1  | alu.drawio.html 46-4-28 |
|   10   |  11   |  101  |  1   |  0  |  1  | alu.drawio.html 46-4-30 |
|   11   |  11   |  110  |  1   |  1  |  0  | alu.drawio.html 46-4-32 |

#### 行波进位加法器

参考"两个 2 位二进制数加法"的实现方式，就可以设计出"两个 n 位二进制数加法"的运算电路。

比如，8 bit ripple carry adder（8 位行波进位加法器）。（见图：**alu.drawio.html 48-2**）可以处理两个 8 位二进制数的加法运算，产生 9 个输出：一个 carry、8 个 sum（注意顺序）。

### 逻辑单元

逻辑单元由大量逻辑门组成，主要的功能是判断输入到底是哪一种输入。

#### 判断是否为 0

这里用"判断 4 位的二进制输入是不是 0"举例。（见图：**alu.drawio.html 60-2**）4 位的二进制输入只有全是 0 时才输出 1；只要有一个非 0 就输出 0。（见图：**alu.drawio.html 60-4-2 60-4-4**）

### ALU

ALU 就是由算术单元和逻辑单元组成的，这里画一个简单的 ALU 的抽象示意图（见图：**alu.drawio.html 80-2**），真正的 ALU 会有更多的东西。

这里的抽象示意图对应的是一个可以处理两个 8 位二进制数的算术运算的 ALU。它有，两个数据输入（两个二进制数）、一个 operation code（操作码）输入（加法还是减法）、一个数据输出（算数运算的结果）、3 个 flag（标志位）输出（overflow 是否溢出、zero 是否为 0、negative 是否为负）。

下面举几个例子：

计算 0b11111111 + 0b11111111。两个数据输入是 0b11111111 和 0b11111111、操作码输入假设是 0b0001（表示加法）。这个时候，因为 0b11111111 + 0b11111111 = 0b111111110，溢出了。所以数据输出会是 0b11111110、overflow 会是 1。

计算 0b11111111 == 0b11111111。计算机不会直接比较两个数字哪个大哪个小，计算机用的思路是让两个数字相减，然后和 0 比较。两个数据输入是 0b11111111 和 0b11111111、操作码输入假设是 0002（表示减法）。这个时候，因为 0b11111111 - 0b11111111 = 0b00000000，为 0。所以数据输出会是 0b00000000、zero 会是 1。

计算 0b11111111 < 0b11111110。和上面那个例子的思路一样。两个数据输入是 0b11111111 和 0b11111110、操作码输入假设是 0002（表示减法）。这个时候，因为 0b11111111 - 0b11111110 = 0b00000001，大于 0。所以数据输出会是 0b00000001、negative 会是 0（表示 0b11111111 - 0b11111110 > 0，0b11111111 更大）。

## reference（参考）

- Crash Course Computer Science（计算机科学速成课）
  - [bilibili](https://www.bilibili.com/video/BV1EW411u7th)
  - [CrashCourse 字幕组](https://github.com/1c7/crash-course-computer-science-chinese)
  - [Youtube 原视频](https://www.youtube.com/playlist?list=PL8dPuuaLjXtNlUrzyH5r6jN9ulI)
