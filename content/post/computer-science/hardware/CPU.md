---
draft: false
date: 2023-02-21 08:00:00 +0800
title: "CPU"
summary: "CPU；"
toc: true

categories:
  - 硬件

tags:
  - 计算机科学
  - 硬件
---

## 正文

图：

- /post/computer-science/hardware/CPU.drawio
- /post/computer-science/hardware/CPU_执行程序的过程.drawio

### CPU

CPU（Central Processing Unit、中央处理器）是计算机的核心，负责执行程序。
CPU 的强大之处在于，它是可编程的（programmable）。如果输入不同的指令，就会执行不同的动作。

[程序](/post/computer-science/program/程序)

[指令](/post/computer-science/program/指令)

CPU 的核心部分由运算器和控制器组成。
核心部分之外还有寄存器、CPU 高速缓存、总线等。

[运算器](/post/computer-science/hardware/运算器)

[控制器](/post/computer-science/hardware/控制器)

[寄存器](/post/computer-science/hardware/寄存器)

[CPU_高速缓存](/post/computer-science/hardware/CPU_高速缓存)

### 时钟

时钟（clock）负责管理 CPU 的工作节奏。

时钟以精确的时间间隔触发脉冲信号，控制单元根据这个信号推进 CPU 的内部操作。

因为电的传输需要时间，所以时钟的节奏不能太快。

时钟频率（clock rate），单位是赫兹（hertz、Hz），10 Hz 代表时钟 1 秒触发脉冲信号 10 次。

时钟周期（clock cycle）又叫振荡周期，每一次脉冲信号高低电平的转换就是一个周期，时钟频率的倒数。

时钟频率越高，时钟周期越短，CPU 工作速度越快。

超频（over clocking）可以提升 CPU 的工作效率，但是会产生散热问题或因为跟不上时钟频率产生乱码。

降频（under clocking）可以省电，CPU 不需要时刻保持全速工作。

现代计算机都有动态频率调整（dynamic frequency scaling）的功能。

### 一条指令的执行过程

执行一条指令一般分为三个步骤：

- 取指令（instruction fetch、IF）
- 指令译码（instruction decode、ID）
- 执行指令（execute、EX）

CPU 会根据指令周期的不同阶段区分取指令还是取操作数。

初始化时，所有的寄存器都初始化为 0；RAM 中存入一段程序，假设地址从 0 开始。

取指令阶段，负责拿到指令。

CPU 将指令地址寄存器连接到 RAM，寄存器的值为 0，因此 RAM 返回地址 0 上的数据。

返回的数据会被复制到指令寄存器里。

指令译码阶段，搞清楚指令要干什么。

CPU 用控制单元判断指令寄存器里的指令的操作码是哪一个。

这里假设译码的结果为："操作码：读取内存数据放入寄存器 A；地址：9"。

执行阶段，执行译码的结果。

从 RAM 地址 9 的位置取出操作数，放到寄存器 A 里。

执行完成后，关闭所有电路，指令地址寄存器 +1，本次指令流程结束。

### CPU 执行程序的过程

#### 定义指令和程序

这里假设这个 CPU 一次可以处理 8 bit 的数据，也就是一条指令是 8 bit。

一条指令有包括指令码和操作数，这里假设前 4 bit 作为指令码，后 4 bit 作为操作数。

指令码属于指令集，这里假设指令集为：

- 0b0001，从内存读取数据到寄存器 A；
- 0b0010 从内存读取数据到寄存器 B；
- 0b0011 把寄存器 A 和寄存器 B 的数据交给 ALU 做加法运算，然后把输出的结果放到寄存器 A，这个步骤不需要操作数；
- 0b0100，把寄存器 A 的数据写入内存；

最后，假定指令的操作数都是内存地址。

这样就可以把这个程序大概写出来了。（**见图：CPU.drawio**）

假设两个数据都是 1，分别存储在内存地址 1100 和 1101 上。

执行一次加法运算，然后把结果存储到内存地址 1110 上。

#### 找个地方放程序

指令和数据都可以以二进制的形式存储在内存里。

比如上文的那个一次加法操作的整个程序是可以存储在内存中的。

但是跑这个程序的时候，直接操作内存搞，搞起来会很复杂。

所以会需要一些额外的空间临时存储一些数据，这些额外的空间通常由寄存器来实现。

这里继续使用上文的一次加法操作来说明。

首先，构成一次加法操作的每一步指令是需要分析的。

但是把内存线路直接接到控制单元上直接产生依赖显然不是一个好设计。

可以从内存里把指令拿出来，暂存在控制单元里，然后再进行分析，这就是指令寄存器的概念。

然后，程序跑到哪一步了也是需要记录的，这就是指令地址寄存器的概念。

两个操作数肯定是放在两个内存地址上的，这里肯定需要一个一个取出来，也就是需要两个能暂存操作数的地方。

这里就是很普通的，用于存数据的寄存器，叫寄存器 A 和寄存器 B 好了。

另外，ALU 计算的结果和标志位也需要处理。

最后，程序的每一次指令操作都需要电信号来触发，这个由时钟组件来控制，时钟会定时发射电脉冲。

比如，每过一秒，就发射一次电脉冲，驱动整个系统运作一次。

到这里，就可以画一个简单的结构图了。（**见图：CPU_执行程序的过程.drawio**）

分为两部分：执行程序的 CPU 和存储程序的内存。

#### CPU 执行程序的过程

把存有程序的内存和 CPU 连接起来，假设指令地址寄存器从 0 开始，那么程序的执行过程如下：

1、从 RAM 取数据放到寄存器 A。

将内存地址 0b0000 上的指令 0b00011100 加载到指令寄存器。

分析指令的指令码，0b0001 表示从内存读取数据到寄存器 A。

分析指令的操作数，0b1100 表示内存地址。于是去内存地址 0b1100 上，把数据 0b00000001 加载到寄存器 A。

内存地址 0b0000 上的指令执行结束，指令地址寄存器 +1 得到 0b0001。

2、从 RAM 取数据放到寄存器 B。

将内存地址 0b0001 上的指令 0b00101101 加载到指令寄存器。

分析指令的指令码，0b0010 表示从内存读取数据到寄存器 B。

分析指令的操作数，0b1101 表示内存地址。于是去内存地址 0b1101 上，把数据 0b00000001 加载到寄存器 B。

内存地址 0b0001 上的指令执行结束，指令地址寄存器 +1 得到 0b0010。

3、将内存地址 0b0010 上的指令 0b00110000 加载到指令寄存器。

分析指令的指令码，0b0011 表示把寄存器 A 和寄存器 B 的数据交给 ALU 做加法运算，然后把输出的结果放到寄存器 A，这个步骤不需要操作数。

先把寄存器 A 和寄存器 B 的数据交给 ALU 做加法运算，得到 0b00000010。

因为这个时候寄存器 A 还连着 ALU 呢，直接把数据给过去，数据就又传给 ALU 了。

所以控制单元会先暂存运算结果，然后切断寄存器 A 和 ALU 的连接，然后再把运算的结果放到寄存器 A 上。

内存地址 0b0010 上的指令执行结束，指令地址寄存器 +1 得到 0b0011。

4、将寄存器 A 中的数据存入 RAM。

将内存地址 0b0011 上的指令 0b01001110 加载到指令寄存器。

分析指令的指令码，0b0100 表示把寄存器 A 的数据写入内存。

分析指令的操作数，0b1110 表示内存地址。于是去内存地址 0b1101 上，把数据 0b00000010 存进去。

内存地址 0b0011 上的指令执行结束，指令地址寄存器 +1 得到 0b0100。

到这里，这个程序就已经执行结束了，后面的内存地址上如果存储了指令，那属于另外一个程序。

### 机器周期和指令周期

机器周期（又叫 CPU 周期、machine cycle）是 CPU 完成一个基本操作所需的时间。

指令周期（instruction cycle）是 CPU 执行一条指令所需的时间。

一条指令的执行过程划分为若干个阶段，每一阶段完成一个基本操作。

程序的机器周期数 = 程序的指令数 x 指令平均时钟周期数（cycles per instruction、CPI）

程序的 CPU 执行时间 = 程序的机器周期数 x 时钟周期

### 指令流水线

指令流水线（instruction pipeline）是指把一条指令的操作分成多个小步骤，每个步骤由专门的电路完成。

然后，再使用平行（parallelize）处理的方式提高指令的执行效率。

高级 CPU 会动态排序（dynamically reorder）有依赖（dependencies）关系的指令。

然后乱序执行（out-of-order execution），这里的乱序是和原来的顺序相比较的。

高级 CPU 会使用分支预测（branch prediction）技术，提前把指令放入流水线。

另外还有推测执行（speculative execution）技术。

### 其他提升性能的方法

超标量处理器（superscalar processor）：一个时钟周期完成多个指令。

多核处理器（multi-core processor）：一个 CPU 有多个内核，可同时处理多个指令流。

多个独立 CPU（multiple independent CPU）：多个独立 CPU 同时工作。
