---
draft: false
date: 2023-02-22 08:00:00 +0800
lastmod: 2023-02-22 08:00:00 +0800
title: "中央处理器（Central Processing Unit、CPU）"
summary: "程序；指令；指令集；控制单元；CPU；CPU 执行程序的过程；"
toc: true

categories:
- hardware(硬件)

tags:
- computer-science(计算机科学)
- hardware(硬件)
---
## 前言

前置笔记：

- [算术逻辑单元（Arithmetic and Logic Unit、ALU）](/post/computer-science/hardware/alu)
- [内存（Memory）](/post/computer-science/hardware/memory)

## 资料

- <a href="/drawio/computer-science/hardware/cpu.drawio.html">cpu.drawio.html</a>

## 正文

### 程序

ALU 可以进行算数运算，内存可以存储数据。如果能把两个结合起来，那就可以处理复杂的逻辑了。ALU 有三个输入，这里假设有两个 8 bit 的二进制数和一个操作码，但是一个内存地址只能存储 8 bit，显然不可能把所有的东西都存在一个内存地址上，然后一股脑的扔给 ALU。

所以，这里就需要一种方式把需要执行的逻辑转化成一个一个的小步骤，每个内存地址存一个小步骤，然后依次执行。这里就可以引出指令的概念了。程序由一系列操作组成，这些操作就叫指令。

### 指令

指令（instruction）指示计算机要做什么。如：算数加法、算数减法、去内存中读、往内存中写数据等。指令由操作码（operation code）和数据来源（内存地址、寄存器 ID 等）组成。

上文的一个小步骤就是一次指令操作，操作码就是指令码，两个 8 bit 的二进制数就是操作数。指令明确 ALU 要干什么，数据就是 ALU 要处理的数据，指令和数据合起来就是程序了。

### 指令集

程序就是由程序指令和程序数据构成的。下面把一次加法操作，比如，0b1 + 0b1 = 0b10，转换成程序。首先需要依次加载两个数字，然后需要知道是加法，然后需要进行运算，最后需要存储运算结果。

这里面有几种不同的操作：加载、加法、存储。这三个操作囊括了一次加法操作所需要的全部操作，构成了一个操作集合。实际的运行过程中需要给每个操作设计对应的电路来实现，这些不同的电路可以用指令码来进行标记。那么和操作一样，这些指令码也属于一个指令码集合，这就是指令集的概念。

### 控制单元

有了指令集之后，就可以设计电路来识别这些指令了。比如，0b0001 表示加载、0b0010 表示加法、0b0011 表示存储。每一个指令码对应一个电路（见图：**cpu.drawio.html 2-2**），当输入一个指令码的时候，整个电路只有和这个指令码匹配的那一处电路会导通（见图：**cpu.drawio.html 2-4**）。

识别出指令码是哪一个之后，就可以进行后续的操作了。比如，让电路连接内存，写入或者读取数据；或者让电路连接 ALU 进行运算并得到运算结果。这块的电路可以和 ALU、内存等组件独立开来成为单独一个模块，这就是控制单元。

### CPU

中央处理器（Central Processing Unit、CPU）是计算机的核心，负责执行程序。CPU 的核心部分由运算器（arithmetic unit）和控制器（control unit）组成。其他部分还有寄存器、CPU 高速缓存（CPU Cache）、总线等。

CPU 的强大之处在于它是可编程的（programmable），如果写入不同的指令，就会执行不同的任务。

#### 运算器

运算器由算术逻辑单元（ALU）、累加寄存器（AC）、数据缓冲寄存器（DR）、状态条件寄存器（PSW）等组成。执行所有的算数和逻辑运算并进行逻辑测试。比如，与、或、非等。

- ALU：对数据的算数和逻辑运算。
- AC：运算结果或者源操作数的存放区。
- DR：暂时存放内存的指令或数据。
- PSW：保存指令运行结果的条件码，如溢出标志。

#### 控制器

控制器由指令寄存器（IR）、程序计数器（PC）、地址寄存器（AR）、指令译码器（ID） 等组成。控制整个 CPU 的工作。

- IR：暂存 CPU 执行指令。
- PC：存放指令执行地址。
- AR：保存当前 CPU 所访问的内存地址。
- ID：分析指令操作码。

### 程序放到哪里

指令和数据都可以以二进制的形式存储在内存里。上文的那个一次加法操作的整个程序是可以存储在内存中的，比如，内存篇里面提到的那块可以存储 256 个字节的内存。

但是跑这个程序的时候，直接操作内存搞，搞起来会很复杂，所以会需要一些额外的空间临时存储一些数据，这些额外的空间通常由寄存器来实现。这里继续使用上文的一次加法操作来说明。

首先，构成一次加法操作的每一步指令是需要分析的。但是把内存线路直接接到控制单元上直接产生依赖显然不是一个好设计。可以从内存里把指令拿出来，暂存在控制单元里，然后再进行分析，这就是指令寄存器的概念。然后，程序跑到哪一步了也是需要记录的，这就是指令地址寄存器的概念。

两个操作数肯定是放在两个内存地址上的，这里肯定需要一个一个取出来，也就是需要两个能暂存操作数的地方。这里就是很普通的，用于存数据的寄存器，叫寄存器 A 和寄存器 B 好了。另外，ALU 计算的结果和标志位也需要处理。

最后，程序的每一次指令操作都需要电信号来触发，这个由时钟组件来控制，时钟会定时发射电脉冲。比如，每过一秒，就发射一次电脉冲，驱动整个系统运作一次。到这里，就可以画一个简单的结构图了，分为两部分：执行程序的 CPU 和存储程序的内存（见图：**cpu.drawio.html 2-6**）。

### 时钟

时钟（clock）负责管理 CPU 的工作节奏。时钟以精确的时间间隔触发脉冲信号，控制单元会用这个信号推进 CPU 的内部操作。节奏不能太快，因为电的传输需要时间。

- 时钟频率（clock rate），单位是赫兹（hertz、Hz），10 Hz 代表时钟 1 秒触发脉冲信号 10 次。
- 时钟周期（又叫振荡周期、clock cycle）：每一次脉冲信号高低电平的转换就是一个周期，时钟频率的倒数。
- 时钟频率越高，时钟周期越短，CPU 工作速度越快。

- 超频（overclocking）可以提升 CPU 的工作效率，但是会产生散热问题或因为跟不上时钟频率产生乱码。
- 降频（underclocking）可以省电，CPU 不需要时刻保持全速工作。
- 现代计算机都有动态频率调整（dynamic frequency scaling）的功能。

### CPU 执行程序的过程

#### 定义指令集和程序

这里假设这个 CPU 一次可以处理 8 bit 的数据，也就是一条指令是 8 bit。一条指令有包括指令码和操作数，这里假设前 4 bit 作为指令码，后 4 bit 作为操作数。

指令码属于指令集，这里假设指令集为：0b0001，从内存读取数据到寄存器 A；0b0010 从内存读取数据到寄存器 B；0b0011 把寄存器 A 和寄存器 B 的数据交给 ALU 做加法运算，然后把输出的结果放到寄存器 A，这个步骤不需要操作数；0b0100，把寄存器 A 的数据写入内存；

最后，假定指令的操作数都是内存地址。这样就可以把这个程序大概写出来了（见图：**cpu.drawio.html 2-8**）。假设两个数据都是 1，分别存储在内存地址 1100 和 1101 上。执行一次加法运算，然后把结果存储到内存地址 1110 上。

#### 执行程序的过程

把存有程序的内存和 CPU 连接起来（见图：**cpu.drawio.html 2-10-2**），假设指令地址寄存器从 0 开始，那么程序的执行过程如下：

1、从 RAM 取数据放到寄存器 A。

将内存地址 0b0000 上的指令 0b00011100 加载到指令寄存器。分析指令的指令码，0b0001 表示从内存读取数据到寄存器 A。分析指令的操作数，0b1100 表示内存地址。于是去内存地址 0b1100 上，把数据 0b00000001 加载到寄存器 A。内存地址 0b0000 上的指令执行结束，指令地址寄存器 +1 得到 0b0001。（见图：**cpu.drawio.html 2-10-4-2、2-10-4-4、2-10-4-6**）

2、从 RAM 取数据放到寄存器 B。

将内存地址 0b0001 上的指令 0b00101101 加载到指令寄存器。分析指令的指令码，0b0010 表示从内存读取数据到寄存器 B。分析指令的操作数，0b1101 表示内存地址。于是去内存地址 0b1101 上，把数据 0b00000001 加载到寄存器 B。内存地址 0b0001 上的指令执行结束，指令地址寄存器 +1 得到 0b0010。（见图：**cpu.drawio.html 2-10-6-2、2-10-6-4、2-10-6-6**）

3、将内存地址 0b0010 上的指令 0b00110000 加载到指令寄存器。分析指令的指令码，0b0011 表示把寄存器 A 和寄存器 B 的数据交给 ALU 做加法运算，然后把输出的结果放到寄存器 A，这个步骤不需要操作数。（见图：**cpu.drawio.html 2-10-8-2、2-10-8-4**）

先把寄存器 A 和寄存器 B 的数据交给 ALU 做加法运算，得到 0b00000010。因为这个时候寄存器 A 还连着 ALU 呢，直接把数据给过去，数据就又传给 ALU 了。所以控制单元会先暂存运算结果，然后切断寄存器 A 和 ALU 的连接，然后再把运算的结果放到寄存器 A 上。内存地址 0b0010 上的指令执行结束，指令地址寄存器 +1 得到 0b0011。（见图：**cpu.drawio.html 2-10-8-6、2-10-8-8**）

4、将寄存器 A 中的数据存入 RAM。

将内存地址 0b0011 上的指令 0b01001110 加载到指令寄存器。分析指令的指令码，0b0100 表示把寄存器 A 的数据写入内存。分析指令的操作数，0b1110 表示内存地址。于是去内存地址 0b1101 上，把数据 0b00000010 存进去。内存地址 0b0011 上的指令执行结束，指令地址寄存器 +1 得到 0b0100。（见图：**cpu.drawio.html 2-10-10-2、2-10-10-4、2-10-10-6**）

到这里，这个程序就已经执行结束了，后面的内存地址上如果存储了指令，那属于另外一个程序。

### 一条指令的执行过程

执行一条指令一般分为三个步骤：取指令（instruction fetch、IF）、指令译码（instruction decode、ID）、执行指令（execute、EX）。CPU 会根据指令周期的不同阶段区分取指令还是取操作数。

初始化时，所有的寄存器都初始化为 0；RAM 中存入一段程序，假设地址从 0 开始。

取指令阶段，负责拿到指令。CPU 将指令地址寄存器连接到 RAM，寄存器的值为 0，因此 RAM 返回地址 0 上的数据。返回的数据会被复制到指令寄存器里。

指令译码阶段，搞清楚指令要干什么。CPU 用控制单元判断指令寄存器里的指令的操作码是哪一个。这里假设译码的结果为："操作码：读取内存数据放入寄存器 A；地址：9"。

执行阶段，执行译码的结果。从 RAM 地址 9 的位置取出操作数，放到寄存器 A 里。执行完成后，关闭所有电路，指令地址寄存器 +1，本次指令流程结束。

### 机器周期和指令周期

机器周期（又叫 CPU 周期、machine cycle）是 CPU 完成一个基本操作所需的时间。指令周期（instruction cycle）是 CPU 执行一条指令所需的时间。一条指令的执行过程划分为若干个阶段，每一阶段完成一个基本操作。

- 程序的机器周期数 = 程序的指令数 x 指令平均时钟周期数（cycles per instruction、CPI）
- 程序的 CPU 执行时间 = 程序的机器周期数 x 时钟周期

### 指令流水线

指令流水线（instruction pipeline）是指把一条指令的操作分成多个小步骤，每个步骤由专门的电路完成。然后，再使用平行（parallelize）处理的方式提高指令的执行效率。

- 高级 CPU 会动态排序（dynamically reorder）有依赖（dependencies）关系的指令，然后乱序执行（out-of-order execution），这里的乱序是和原来的顺序相比较的。
- 高级 CPU 会使用分支预测（branch prediction）技术，提前把指令放入流水线。另外还有推测执行（speculative execution）技术。

### 其他提升性能的方法

- 超标量处理器（superscalar processors）：一个时钟周期完成多个指令。
- 多核处理器（multi-core processors）：一个 CPU 有多个内核，可同时处理多个指令流。
- 多个独立 CPU（multiple independent CPU）：多个独立 CPU 同时工作。

## 参考（reference）

- [计算机科学相关笔记的参考](/post/computer-science/reference)
