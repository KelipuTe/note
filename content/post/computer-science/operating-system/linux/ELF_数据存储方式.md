---
draft: false
date: 2023-06-10 08:00:00 +0800
title: "ELF 数据存储方式"
summary: "ELF 文件中的数据是怎么存储的；"
toc: true

categories:
  - Linux

tags:
  - 计算机科学
  - 操作系统
  - Linux
---

## 反向链接

[ELF](/post/computer-science/operating-system/linux/ELF)；

## 资料

代码：{demo-c}/demo-in-linux/elf/

## 正文

### 数据是怎么存储的

- 小端字节序、little endian；大端字节序、big endian；

数据存储方式有两种：小端字节序和大端字节序。
小端字节序又叫主机字节序，大端字节序又叫网络字节序。

上面 `readelf -h` 命令的结果里面，在 Data 字段里可以看见 "little endian"。
意思就是在 symbol.elf 里面，数据的存储格式是小端字节序。下面来验证一下这个结论。

在 symbol.c 的源码里面，全局变量 globalIntB 是一开始就明确的给了值的。
在 `readelf -s` 命令输出的符号表里，找到 globalIntB 在的那一行。
然后，就可以知道到 globalIntB 对应的内存地址是 0x4010。

在 `objdump -s` 命令输出的结果里面，找到内存地址 0x4010，地址上存储的就是全局变量 globalIntB 的数据。
内存地址 0x4010 在 ".data" 段里面，这里截取一下 ".data" 段的内容。

```
Contents of section .data:
 4000 00000000 00000000 08400000 00000000  .........@......
 4010 2c010000 0a000000                    ,.......        
```

因为源码里面 globalIntB 是 int 类型的，int 类型的长度是 4 个字节。
所以，globalIntB 的数据就对应从 0x4010 地址开始的 4 个字节的数据。也就是 "2c010000" 这一段。

源码里面 globalIntB 初始化的时候是 300。
10 进制的 300 用 16 进制表示就是 0x12c，补全 4 个字节就是 "00 00 01 2c"。
但是，这里可以看到内存上的数据是 "2c 01 00 00"，是反的。这就是因为这里用的是小端字节序。

c 语言的 int 变量由 4 个字节组成，每个字节由 8 个 bit 位组成。
把 10 进制的 300 转换成 2 进制就是 "00000000 00000000 00000001 00101100"，左边定义为高位，右边定义为低位。
小端字节序的存储格式是把数据的低位放在内存低位上，而内存的排布是从低位到高位的。
所以，就变成了 "00101100 00000001 00000000 00000000"，转换成 16 进制就是 "2c 01 00 00"。

关于进制的问题，我放了一个示例代码，0b_0_10_0x.c。

通过 size 命令可以查看文件中各段及其总和的大小，单位是字节。
关于 size 命令具体怎么用可以看 "size(1) - list section sizes and total size of binary files"。

这里观察一下 symbol.elf 文件。

```
> size demo02
   text	   data	    bss	    dec	    hex	filename
   1786	    608	     16	   2410	    96a	symbol.elf
```

- text，代码段，通常是指用来存放程序执行代码的一块内存区域。
- data，数据段，通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。
- bss，通常是指用来存放程序中未初始化的全局变量的一块内存区域。bss 段属于静态内存分配。
- 默认情况下，段的大小是以十进制的方式来展示。
