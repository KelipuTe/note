---
draft: false
date: 2023-03-07 08:00:00 +0800
title: "init 进程、进程间关系、作业、会话、守护进程"
summary: "init 进程；进程组；作业；前台作业；后台作业；会话；控制进程；守护进程；"
toc: true

categories:
  - operating-system(操作系统)

tags:
  - computer-science(计算机科学)
  - operating-system(操作系统)
  - linux
  - c-programming-language
  - process(进程)
---

## 前言

实践的环境：

- amd64（x86_64）
- windows 11
- vmware workstation pro 16
- ubuntu 22.04
- linux version 5.19.0-41-generic
- gcc version 11.3.0

前置笔记：
[进程的创建、进程的运行、进程的内存资源、进程的退出、进程的回收](/post/computer-science/operating-system/linux/process)

交叉笔记：[终端和控制台](/post/computer-science/terminal_console)

## 资料

- [{demo-c}](https://github.com/KelipuTe/demo-c)/demo-in-linux/process02/

## 正文

### init 进程

init 程序是 Linux 操作系统中不可缺少的程序之一，它是一个由内核启动的用户级进程。
内核会在过去曾使用过 init 程序的几个地方查找它，它的正确位置（对 Linux 系统来说）是 "/sbin/init"。
如果内核找不到 init，它就会试着运行 "/bin/sh"。如果这两个都运行失败了，操作系统的启动也会失败。

Linux 操作系统的启动首先从 BIOS 开始，接下来进入 boot loader，由 boot loader 载入内核，进行内核初始化。
内核启动之后（被载入内存，开始运行，初始化所有的设备驱动程序和数据结构之后），就会通过启动一个用户级程序 init 的方式，完成引导进程。

内核初始化的最后一步就是启动 init 进程，这个进程是系统的第一个进程，它负责产生其他所有的用户进程。
所以，init 进程始终是第一个进程，其进程编号始终为 1。
其他所有的用户进程每个进程都有父进程，一直上溯的话，所有的进程会形成一个以 init 进程为根结点的树状结构。

### 进程树

这里简单的验证一下。先打开一个终端，使用 "echo $$" 命令，打印当前进程的 pid。
再打开一个终端，使用 "echo $$" 命令，打印当前进程的 pid。然后使用 "pstree -p" 命令，观察一下进程树。

```
> echo $$
1963
```

```
> echo $$
2166
> pstree -p
systemd(1)─┬...
           ├─systemd(1074)─┬─...
           │               ├─gnome-terminal-(1945)─┬─bash(1963)
           │               │                       ├─bash(2166)───pstree(2173)
```

这里从进程树里截取了有关的片段。
可以看到，打开的两个终端，bash(1963) 和 bash(2166) 的父进程都是 gnome-terminal-(1945)。
终端 bash(2166) 执行 pstree 命令的时候，又创建了一个子进程 pstree(2173)。

### 进程组

进程组（process group）是一个或者多个进程的集合。
每个进程必须而且只能属于一个进程组。集合里的这些进程并不是孤立的，它们之间会存在父子或者兄弟的关系。
进程有自己的唯一标识，称为进程 id（process id、pid），进程组也有自己的唯一标识，称为进程组 id（process group id、pgid）。

每个进程组都有一个组长进程，组长进程的 pid 与其 pgid 相同。组长进程可以创建一个进程组，一般是进程变成组长进程的时候。

进程组的生命周期从被创建开始，直到进程组内所有进程终止或离开该组。
无论组长进程是否终止，只要进程组中存在未终止的进程，这个进程组就不会消失。
组长进程终止后，进程组中便不存在组长进程，剩下的进程也不会自动推选新的组长进程。

进程组的作用是为了方便对进程进行管理。
假设有一个任务需要好多进程一起协作完成，现在出于某种原因需要终止这个任务。
如果没有进程组，就需要用 pid 一个一个杀掉这些进程，而且还要考虑顺序，先杀子进程再杀父进程。
如果有进程组的话，就可以搞一个杀进程组的操作。

通过 getpgid() 或者 getpgrp() 可以获取进程所属的进程组 id。通过 setpgid() 可以设置进程的进程组 id。
进程通过 setpgid() 只能设置它自己和它的子进程的 ppid。
如果它的子进程调用了 exec 家族的函数，那么它也无法更改这个子进程的 ppid 了。

创建出来的子进程一开始是和父进程是一组的，会继承父进程的 pgid。
可以通过把子进程的 pgid 设置成子进程的 pid，来创建以子进程为组长进程的新进程组。

### 作业

Linux 是一个多用户多任务的分时操作系统。
多用户是指多个用户可以在同一时间使用计算机系统。
多任务是指 Linux 可以同时执行多个任务，可以在一个任务还未执行完的同时执行另一项任务。
多个用户和多个任务都由操作系统进行管理。
分时是指计算机采用时间片轮转的方式同时为几个、几十个、甚至几百个用户服务。

#### 作业控制

Shell 是操作系统的用户界面，提供了用户与内核进行交互操作的一种接口。
它实际上是一个命令解释器，接收并解释用户输入的命令，然后把命令送入内核去执行。
Shell 有多种不同的版本，常用的 BASH 就是其中一种。

Shell 控制的不是进程而是作业。正在执行的一个或多个相关进程被称为作业（job），也有叫任务的。
作业是计算机操作者（可以是人也可以是程序）交给操作系统的执行单位。
作业控制指的是控制正在运行的进程的行为。比如，在 Shell 控制终端控制多个作业。

#### 前台作业和后台作业

作业还分为前台作业和后台作业。用户直接操作的那个终端窗口就属于前台作业，前台作业独占终端窗口。
它可以直接接收用户输入的命令，而且一旦命令开始运行，除非命令运行结束或者强制终止命令，要不然是不能执行其他命令的。

前台作业运行结束，Shell 就会把自己提到前台。
比如，在终端窗输入 "ls" 命令之后，Shell 会启动一个进程去执行 "ls" 命令，
"ls" 命令执行完之后会输出结果，然后这个进程退出，然后 Shell 把自己提到前台。

除了表面上看得到的前台作业的进程，还有很多正在运行的进程是表面上看不到的。
比如，那个直接和用户交互的作业背后，是需要操作系统做很多工作来提供支撑的。
这些进程就属于后台作业。Shell 可以运行一个前台作业和任意多个后台作业。

#### 子进程

如果作业中的某个进程又创建了子进程，则子进程不属于作业。
作业运行结束时，如果这个子进程还没终止，那么它会变为后台进程。
比如，用 fork() 创建了一个子进程之后，父进程直接退出，这个时候子进程并不会终止，而是变成孤儿进程。

### 会话

Linux 是一个多用户多任务的分时操作系统。多用户是指多个用户可以在同一时间使用计算机系统。一个用户登录一次系统就形成一个会话。

会话（session）是多个进程组的集合，一个会话中可以包含一个前台进程组以及一个或多个后台进程组。
每个会话都有会话 id（session id、sid）。每个会话都有一个会话首进程（session leader），即创建会话的进程。

一个会话可以关联终端，也可以不关联终端，关联终端的时候只能关联一个。
这个终端一般由会话首进程建立连接。此时，会话首进程也叫控制进程，这个终端也叫控制终端。

一个会话关联了一个终端后，它至少有一个前台进程组，其它都是后台进程组。
在终端输入特殊字符，如：中断键（"ctrl + c"）、暂停键（"ctrl + z"）、退出键（"ctrl + \\"）时，会产生中断信号。
中断信号会往前台进程组里的所有进程发送，但是不会给后台进程组里的进程发送。

通过 getsid() 可以获取会话 id，通过 setsid() 可以设置会话 id。
当一个进程调用 setsid() 时，会发生三件事：该进程会变成会话首进程（session leader）；
该进程会变成进程组的组长；该进程不会关联终端，就算父进程有终端也会断开（后面可以再关联终端）。
必须注意的是，只有当前进程不是进程组的组长时，才能创建一个新的会话，成为新会话的会话首进程。

#### 控制进程

控制进程就是关联了终端的进程。比如，控制台黑窗口。可以通过 `ps -l` 命令看一下。

```
> ps -l
  UID     PID    PPID  C PRI  NI ADDR SZ WCHAN  TTY          TIME CMD
0 S  1000    2643    2625  0  80   0 -  3557 do_wai pts/0    00:00:00 bash
0 R  1000    2650    2643  0  80   0 -  3939 -      pts/0    00:00:00 psF S 
```

进程（PID）2643，是由 bash（/bin/bash）文件启动的，同时该进程关联了终端设备（TTY），这个终端设备是 pts/0（伪终端）。

### 切换前台作业和后台作业

这里准备了一个程序 for_job.c。程序每 5 秒，用 printf() 输出一次 pid。

想启动前台作业很简单，在终端窗口里直接执行命令就好了。比如，在终端窗口里直接运行这个程序。
这样程序就是一个前台作业，会占着终端窗口一直输出 pid。

```
> ./for_job.elf
[debug]:getpid()=11959
[debug]:getpid()=11959
一直输出。。。
```

这个时候可以按下 "ctrl + z"，可以停止进程并放入后台。这个时候，这个前台作业就变成后台作业了。

```
^Z
[1]+  Stopped                 ./for_job.elf
```

job 命令可以查看当前 Shell 环境中已启动的作业状态，这里用 "job -l" 命令查看一下。
可以看到刚才的 11959 进程，现在在后台而且处于停止状态。

```
> jobs -l
[1]+ 11962 Stopped                 ./for_job.elf
```

- "\[1\]" 表示作业号为 1。
- "+" 表示最近一个放入后台的作业。如果这里是 "-" 则表示倒数第二个放入后台的工作，
  倒数第三个以后的工作就没有 "+" 或者 "-" 标志了。
- 11962 就是 pid；Stopped 表示进程现在是停止状态。
- 最后的 "./for_job.elf" 表示进程是这个命令启动起来的。

bg 命令可以让最近一个暂停的后台任务继续执行。这里也可以用 "bg %1"，"%1" 就是指定了作业号。

```
> bg
[1]+ ./for_job.elf &
[debug]:getpid()=11962
[debug]:getpid()=11962
一直输出，而且不受控制
```

这里就要提到后台作业的两个特点：

- 继承当前会话的标准输出（stdout）和标准错误输出（stderr）。
  因此，后台任务的所有输出依然会同步地打到终端窗口，也就是上面一直输出的原因。
- 不继承当会话的标准输入（stdin）。因此，无法再向这个任务输入指令了，也就是上面不受控制的原因。
  如果后台作业试图读取标准输入，终端驱动会检测后台进程的这种举动并向后台作业发送一个 SIGTTIN 信号。
  SIGTTIN 信号通常会暂停（halt）后台作业的执行。

所以，前台任务和后台任务的区别只有一个：是否继承标准输入。

如果这个时候继续在终端窗口里面输入命令，它是可以被执行的。
虽然这个时候后台任务的所有输出会同步地打到终端窗口，让窗口看上去非常的混乱，但是这并不影响输入的命令。
输入和输出的内容并不在一个地方，只是都显示到了一个地方。

比如，使用 fg 命令将后台运行的或挂起的作业切换到前台运行。这里也可以用 "fg %1"，"%1" 同样是指定了作业号。

```
> fg %1
./for_job.elf
[debug]:getpid()=11962
一直输出。。。
```

另外，可以通过在命令的后面加一个 "&" 符号，让程序直接以后台作业的方式启动。

```
>./for_job.elf  &
[1] 2228
```

这种方式启动起来的作业就是直接处于后台并且是运行状态的。

```
> jobs -l
[1]+  2249 Running                 ./for_job.elf &
```

### 守护进程

守护进程（Daemon 进程）最基本的特点就是运行在后台，并且不和终端关联。
这里的运行在后台和上文的后台作业或者后台进程组是有区别的。上文的后台作业或者后台进程组，进程依然是和会话进程关联的。
而守护进程的父进程是 1 号 init 进程，和启动它的会话进程不关联。
这里的不和终端关联的意思是，守护进程不接受标准输入也不会产生标准输出或者标准错误输出。

从终端开始运行的进程都会依附于这个终端，这个终端称为这些进程的控制终端。
当控制终端被关闭时，相应的进程都会被自动关闭。对于一般的前台进程，可以用 "ctrl + c" 的方式来停止运行，也可以直接关闭终端。
但是对于守护进程来说它的生命周期需要突破这种限制，它会一直运行直到整个系统关闭才会退出，因此守护进程不能依赖于终端。

#### 编写守护进程的步骤

- 创建一个子进程 b，父进程 a 退出。因为调用 setsid() 的进程不能是组长进程。
- 子进程 b 调用 setsid() ，创建一个新的会话。
  调用进程调用 setsid() 时，该调用进程会变成会话首进程，变成组长进程，而且不关联终端。
- 有些时候，在子进程 b 调用 setsid() 后，还会再创建一个子进程 c ，然后自己（会话首进程）退出。
- 修改子进程的工作目录，一般为根目录。fork() 使得子进程继承了父进程的工作目录。
- 调用 umask() 重设文件权限掩码。fork() 使得子进程继承了父进程的文件权限掩码，这会给子进程使用文件带来麻烦。
- 关闭不必要的文件描述符（主要是 0、1、2）。fork() 使得子进程继承了父进程一些打开的文件，但是子进程可能不需要，这会消耗系统资源。
- 打开黑洞文件（`/dev/null`），彻底的断开控制终端。

代码示例：**{demo-c}/demo-in-linux/process02/daemon.c**

程序运行之后会变成守护进程，不会在终端有输出。可以通过 "ps -ely" 命令查看进程状态。

```
> ps -ely
S   UID   PID  PPID  C PRI  NI   RSS    SZ WCHAN  TTY          TIME CMD
S     0     1     0  0  80   0  2824  2961 -      pts/0    00:00:00 bash
S     0    16     0  0  80   0  3064  2961 -      pts/1    00:00:00 bash
S     0    45     1  0  80   0    88  1058 -      ?        00:00:00 daemon
S     0    46    45  0  80   0    88  1058 -      ?        00:00:00 daemon
R     0    50    16  0  80   0  3076 12406 -      pts/1    00:00:00 ps
```

可以看到进程 45 运行的 daemon 程序，它的父进程变成 1 号 init 进程了，这时进程 45 它就是一个守护进程。
从进程关联的标准输入设备（TTY）也可以看到进程 45 它值是 "?"，表示没有关联终端。
进程 45 还创建了一个子进程 46，这个虽然是后台进程，但是它的父进程不是1 号 init 进程，所以不算守护进程。

另外，也可以通过 daemon() 创建守护进程。

#### nohup

最常用的创建守护进程的方式是使用 "nohup" 命令加上 "&" 符号。`nohup ./for_job.elf &`。

"nohup" 命令的作用有：阻止 SIGHUP 信号发送给这个进程；
关闭 stdin 使得该进程不再能接收任何输入，即使进程是运行在前台的（没有加 "&" 符号）；
重定向 stdout 和 stderr 到 nohup.out。

## 参考

- [百度百科-init](https://baike.baidu.com/item/init/1196449?fr=aladdin)
- [Linux初始化init系统](https://zhuanlan.zhihu.com/p/573503461)
- [百度百科-Linux Shell](https://baike.baidu.com/item/Linux%20Shell/10142850?fr=aladdin)
- [百度百科-Linux进程管理及作业控制](https://baike.baidu.com/item/Linux%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86%E5%8F%8A%E4%BD%9C%E4%B8%9A%E6%8E%A7%E5%88%B6/10143582?fr=aladdin)
- [Linux-进程、进程组、作业、会话、控制终端详解](https://www.cnblogs.com/JohnABC/p/4079669.html)
- [APUE 2 - 进程组（process group） 会话（session） job](https://www.cnblogs.com/Sven7/p/7442791.html)
- [Linux会话、终端与进程组](https://zhuanlan.zhihu.com/p/563471531)
