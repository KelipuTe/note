---
draft: false
date: 2023-01-29 08:00:00 +0800
lastmod: 2023-01-29 08:00:00 +0800
title: "队列（Golang 实现）"
summary: "并发安全队列；优先队列；延迟队列；"
toc: true

categories:
- golang

tags:
- computer-science(计算机科学)
- programming-language(编程语言)
- golang
- queue(队列)
- concurrent(并发)
---

> CPU AMD64(x86_64)<br/>
> Windows 11 家庭版<br/>
> go version go1.19 windows/amd64

### 资料

- [{demo-golang}](https://github.com/KelipuTe/demo-golang)/demo/queue/
- <a href="/drawio/computer-science/programming-language/golang/queue.drawio.html">queue.drawio.html</a>

### 并发安全队列

并发安全队列就是不会出现并发问题的队列。

### 阻塞队列和非阻塞队列

个人认为，一个队列是阻塞队列还是非阻塞队列，应该根据队列本身的设计判断。队列需不需要阻塞，是设计上决定的，和用锁还是用 CAS 是没关系的，这两个结构是为了解决并发问题的。

如果设计队列的时候，队列有最大容量。而且队列本身的设计中有阻塞的逻辑。这样的队列就是阻塞队列。比如，在入队阶段，判断队列容量已满的时候，不是直接返回入队失败，而是等待队列空出位置后在入队，那么这里就需要设计阻塞的逻辑。

反之，如果设计队列的时候，队列有最大容量，但是队列本身的设计中没有阻塞的逻辑，或者队列没有最大容量，那就是非阻塞队列。比如，在入队阶段，判断队列容量已满的时候，直接返回入队失败，那么这里就不需要设计阻塞的逻辑。

### 并发安全的有最大容量的队列

代码详见：

- {demo-golang}/demo/queue/concurrent_blocking_queue.go。
- {demo-golang}/demo/queue/wait_cond.go。

这里沿用上面的定义。想要一个并发安全的有最大容量的队列的两个要求：1、并发安全；2、有最大容量。这里用锁+环形数组实现。

从最简单的入队出队逻辑开始。入队：检查容量->(等待有空位：比如循环检查容量)->入队。出队：检查容量->(等待有空位：比如循环检查容量)->出队。这种结构可以满足有最大容量的要求，但是因为对临界资源（队列数据）的访问是没有限制的，所以这肯定不是并发安全的。

既然要保护临界资源，那么首先想到的肯定是加锁。Golang 里面就是 sync.Mutex 了。直接加锁行不行呢？入队：加锁->检查容量->(等待有空位：比如循环检查容量)->入队->解锁。出队：加锁->检查容量->(等待有数据：比如循环检查容量)->出队->解锁。这样的逻辑显然会在"等待有空位"和"等待有数据"这两个步骤产生死锁。

如果队列满了，"等待有空位"这里就无法入队，导致锁放不掉。这里锁放不掉，出队那里就加不了锁，无法出队。如果队列为空，"等待有数据"这里就无法出队，导致锁放不掉。这里锁放不掉，入队那里就加不了锁，无法入队。

所以加锁之后，"等待有空位"和"等待有数据"这个两步骤需要修改。"等待有空位"需要先解锁，这样出队那里就可以加锁。然后等待有空位。等到有空位之后，再加锁，然后入队。"等待有数据"需要先解锁，这样入队那里就可以加锁。然后等待有数据。等到有数据之后，再加锁，然后出队。

Golang 里面提供了这种工具 sync.Cond。可以先看一眼官方提供的 sync.Cond.Wait() 里面的逻辑。执行逻辑很简单，大概是：获取一个用于等通知的结构；把拿着的锁放掉；阻塞，等通知；等到通知了，把锁加回来。

```
func (c *Cond) Wait() {
	c.checker.check()
	t := runtime_notifyListAdd(&c.notify)
	c.L.Unlock()
	runtime_notifyListWait(&c.notify, t)
	c.L.Lock()
}
```

有了这个结构。出队的那个地方出队的时候，发一个信号给"等待有空位"就行。入队的那个地方入队的时候，发一个信号给"等待有数据"就行。这样并发问题也就解决了。加锁可以在并发场景中保护队列数据的正确性，但是用 sync.Mutex 和 sync.Cond 有一个缺点，这玩意无法控制超时。

用 sync.Mutex 执行 sync.Mutex.Lock() 之后，gorouting 就陷进去了，直到它拿到锁，否则是不会出来的。用 sync.Cond 也一样。执行 sync.Cond.Wait() 之后，gorouting 一样会陷进去，直到它被 sync.Cond.Signal() 或者 sync.Cond.Broadcast() 发出的信号唤醒，否则也是不会出来的。

所以这里需要的是一个可以被控制的等待加锁的结构。也就是说要一个 sync.Mutex.Luck(time) 或者 sync.Cond.Wait(time) 这样的东西。如果一定时间拿不到锁，或者等不到信号，要能从阻塞状态退出来。

仔细观察一下 Wait() 的代码。里面加锁和解锁的步骤是必须的，所以核心问题其实就找到了。需要修改原有的等通知的逻辑，让这里变成既可以等待信号，同时也可以被 context 超时控制的结构。在 Golang 里面，等待信号可以使用 channel（管道）。这玩意可以变相的做到，既可以被阻塞，也可以在需要的时候被唤醒。

可以把读一个空的管道理解成阻塞，把从管道里读到东西理解成唤醒。如果需要模拟阻塞，那么就读一个空的管道就可以了。唤醒这里需要一点技巧，这里不能用往管道里写数据的方式去唤醒阻塞中的 gorouting。因为不知道到底有多少个 gorouting 在等着读数据，也就是不知道要写多少次数据。写少了，会有等着的 gorouting 读不到数据，会泄露。写多了自己会阻塞，也会泄露。

这里可以用直接关闭管道的思路，读取已经关闭的管道会读到零值。那么关闭一个有很多 gorouting 都在读取的管道，就相当于完成了一次 Broadcast()。但是这种操作无法实现 Signal()。新的方法里面的逻辑大概就是下面这样（伪代码）。

```
func (p7this *Cond) WaitWithTimeout(ctx context.Context) error {
	// 获取一个用于等通知的 channel
	// 把拿着的锁放掉
	select {
	case <-ctx.Done():
		// 超时，这里就不用把锁加回来了。外层应该拿到这里的异常，然后执行异常处理逻辑。
		return ctx.Err()
	case <-通知信号:
		// 等到通知了，说明有 gorouting 调用了 Broadcast() 关闭了 channel，把锁加回来。
		// 这个地方并没有完全解决超时的问题，因为这里加锁的逻辑还是有可能被阻塞的。
	}
}
```

### 并发安全的无最大容量的队列

代码详见：

- {demo-golang}/demo/queue/concurrent_nonblocking_queue.go。

这里沿用上面的定义。想要一个并发安全的有最大容量的队列的两个要求：1、并发安全；2、无最大容量。这里用链表+CAS+自旋实现。

CAS（Compare And Swap）操作是原子操作，包含三个操作数：内存中的值（内存位置 V）、原值（预期原值 A）、新值（新值 B）。如果内存中的值与原值相等，那么处理器会将内存中的值更新为新值。如果内存中的值与原值不相等，处理器不做任何操作。

### 锁和 CAS+自旋

单纯地看一次操作的效率的话，CAS 的效率肯定是比锁高的。但是并发场景中，不能只看一次操作的效率，而是要看整体操作的效率。

如果并发量很少，也就是冲突不明显的时候。比如锁和 CAS 都是一次就成功。那么整体的效率，CAS 是比锁要高的。

如果并发量很大，也就是冲突明显的时候。锁一次不成功，就会阻塞，然后进入通知队列等着被唤醒了，CPU 就可以空出来干别的事情。但是 CAS 一次不成功，会不定的重试，直到成功。

这个时候问题就来了，假设并发数量是 10000，那么 1 个成功了，那么剩下来的 9999 个，一定是不可能成功的。但是它们依然在不停的重试，一直消耗 CPU 的资源。

### 优先队列

### 延迟队列

### reference（参考）

- [极客时间](https://time.geekbang.org/)
  - Go实战训练营
    - 并发等待队列实现