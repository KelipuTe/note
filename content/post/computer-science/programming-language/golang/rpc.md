---
draft: false
date: 2023-01-01 08:00:00 +0800
lastmod: 2023-01-01 08:00:00 +0800
title: "Golang 实现简单的自定义 RPC 协议"
summary: "RPC 有几块，这几块是怎么工作的，一次 RPC 调用的大概过程，RPC 大概的实现思路"
toc: true

categories:
- golang

tags:
- computer-science(计算机科学)
- programming-language(编程语言)
- golang
- protocol(协议)
- rpc
---

> CPU AMD64(x86_64)<br/>
> Windows 11 家庭版<br/>
> go version go1.19 windows/amd64

### 前言

在看这篇之前，建议先看下面这篇：

- [关于 RPC 的基本认知](/post/computer-science/protocol/rpc)

在动手实现自定义 RPC 之前，先搞清楚 RPC 是什么，以及 RPC 的原理。

### 资料

- [{micro-service-go}](https://github.com/KelipuTe/micro-service-go)/v20/
- <a href="/drawio/computer-science/protocol/rpc.drawio.html">rpc.drawio.html</a>

### 先来看看有几块东西

RPC 的意思是远程过程调用。既然是调用，那么这玩意肯定有一个调用方，一个被调用方，也就是说会有客户端和服务端。然后又是远程调用，那客户端和服务端应该不在同一个服务里，那么它们之间要用就需要用到网络，那么他们之间就必须要商量一个通信的方式，也就是需要一个通信协议。差不多就这三个玩意：客户端、服务端、协议。

理论上，可以基于 TCP 协议构造一个 RPC 协议，也可以基于 HTTP 协议构造一个 RPC 协议，这个其实没有严格的规定。进行协议设计的时候需要注意的是：如果是基于 HTTP 协议设计，那么里面会包含 HTTP 和 TCP 两个协议，会多一层转换的开销；如果是直接基于 TCP 协议设计，虽然少一层转换的开销，但是编码难度上去了。在实际应用中，需要做好协议性能和开发难度的权衡。

### 这几块东西是怎么工作的

RPC 有一个核心的描述：它想像使用本地服务一样使用远端服务。也就是说，如果在 a 服务上有另一个类 B，在远端服务 b 上有一个类 A，这个类 B 想直接 new 一个类 A 出来，然后调用方法。通常情况下这么干肯定是不行的，因为 a 服务上并没有类 A 的代码。但是如果把类 A 的代码在 a 服务上再写一份，那就没意义了。

RPC 这里想要的是 a 服务上有一个类 A 的壳子，这个类 A 的壳子可以直接 new 出来，然后调用壳子上的方法。调用壳子上的方法的时候，这个壳子上的方法做的事情是，把调用者传进来的参数收集起来，然后交给远端服务 b 上真正的类 A 去处理，拿到处理结果后，返回给调用者。调用者只是感觉上和使用本地服务没什么区别。

为了保证 a 服务和远端服务 b 上的类 A 是一样的，这里需要引入一个公共的抽象。a 服务基于这个公共的抽象实现一个壳子，远端服务 b 基于这个公共的抽象实现真正的功能。这里的两方是可以使用不同的语言的，a 服务上收集到的调用参数可以进行序列化处理然后再传到远端服务 b，只要远端服务 b 能根据序列化的数据还原出调用参数就行。

来总结一下这几块东西是怎么工作的：

- 客户端需要实现一个壳子。
- 壳子需要收集调用参数，把调用参数序列化，然后传给远端服务 b。
- 远端服务 b 在接到数据之后，需要用序列化后的数据还原出调用参数，处理完成后把结果返回回去。
- 壳子收到远端服务 b 的处理结果后，把处理结果返回给调用者。

这里面还有几处细节：

- 双方的通信的方式，也就是协议还没有约定。
- 远端服务 b 在接到数据之后，需要知道调用哪个类的哪个方法，这个是壳子需要告诉远端服务 b 的。
- 远端服务 b 处理出错了怎么办，也就是异常还没有处理。

### RPC 调用的大概过程

用流程图（见图：**rpc.drawio.html 4-2**）来描述 RPC 调用的大概过程比较合适。

### 大概的实现

#### 几个抽象

- 服务：就是壳子和真正的功能的抽象，两端需要基于这个抽象传递方法的入参和出参。
- 序列化：序列化可以用任意的算法，比如 JSON 或 protobuf。抽象是为了方便后续扩展新的序列化算法，上层不需要知道参数是怎么序列化的。
- 协议：协议可以用任意的协议，比如自定义 JSON 协议或自定义 RPC 协议。抽象是为了方便后续扩展新的协议，上层不需要知道数据是怎么发出去的。
- 网络请求：网络请求可以使用任意的形式，比如 TCP 或 HTTP，比如每次都新建连接或使用连接池。对网络请求层进行抽象是为了可以替换不同的实现，上层不需要知道网络请求是怎么实现的。
- 请求参数和响应参数：对这两个东西进行抽象是为了方便对 RPC 流程进行抽象。要不然请求的那个地方会是任意类型的，不方便添加中间件之类的结构。

#### 协议

协议设计见图：**rpc.drawio.html 6-2**

最前面的定长的部分，这几个字段属于非常常见的字段了，很多协议里都可以看到这种设计。

- 请求（响应）头长度用于标记请求（响应）头的长度，这里的请求头包括前面定长的部分。
- 请求（响应）体长度用于标记请求（响应）体的长度。
- 这两个玩意合起来用于从 TCP 里读取一个完整的报文。也就是从 TCP 里读取的时候，先读前面 8 个字节，然后解析出这两个长度，这样就可以知道这一个报文的长度了。

版本号、序列换算法、压缩算法这三个属于标记位，用于提示客户端或者服务端，协议的内容怎么解析。

请求头里用 `\r\n` 分隔每一条数据。最前面两个固定为：service name 和 method name，后面则是剩下的元数据。比如，链路追踪 id 和超时时间之类的。service name 和 method name 单独拿出来放最前面是考虑到：1、这两个属于必须字段；2、如果有网关的存在，网关直接解析最前面这两个字段就可以进行转发，不用解析整个请求头。

响应头里只有一个放异常的位置。因为返回响应的时候一般都是原路返回的，所以 service name 和 method name 是不必要的。然后元数据，本来就是上游传过去的，没必要传回来，而且一般也不会有穿别的元数据回来的需要。所以请求头里的玩意，在响应头里都可以去掉。

#### 壳子

客户端这边最重要的就是壳子了。如果客户端里需要大量使用 RPC 的话，那么每个方法都要作 RPC 改造。但是每个方法要做的事情都是一样的：收集调用信息，发起 RPC 调用，得到结果，返回给调用者。所以这里应该要进行封装。问题来了，各个方法它是不一样的，这东西怎么封装呢。这里就需要使用约定加反射的技巧。这里使用的是 Golang 别的语言依葫芦画瓢就行了。

首先约定 RPC 方法的入参只有两个：上下文和一个结构体指针。结构体里面装着方法需要的所有的参数。方法的出参也是两个：一个结构体指针和异常。结构体里面装着方法返回的所有的结果。这样子反射就好操作了。对于入参，通过反射获取入参的上下文参数，然后进行格式化，作为协议里的元数据。通过反射获取入参的结构体，然后进行序列化，作为协议请求报文里的请求体。对于出参，通过反射获取出参的结构体，然后进行序列化，作为协议响应报文里的响应体。通过反射获取异常，然后进行格式化，作为协议里的元数据。

#### 异常

上面提到，异常是放到元数据那里的。为什么异常要放到元数据的位置呢。这是因为不管是 TCP 协议还是 HTTP 协议，它们都属于字节流协议。请求过来的时候，不会被分隔成独立的协议数据报文，这个也就是经常问的那个 TCP 粘包的问题。协议内部也是一样的，如果把出参的结构体和异常都放到响应体里面，那就需要有分隔它们的手段。要不然这两玩意粘在一起，直接序列化是要报错的。

#### 大概就差不多了

具体的直接看代码就好了。
