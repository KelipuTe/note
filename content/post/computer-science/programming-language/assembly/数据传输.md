---
draft: false
date: 2023-07-12 08:00:00 +0800
title: "数据传输（笔记片段）"
summary: "数据传输；数据交换；数据比较；"
toc: true

categories:
  - programming-language(编程语言)

tags:
  - computer-science(计算机科学)
  - programming-language(编程语言)
  - assembly-language(汇编语言)
---

## 前言

这篇笔记需要 intel x86-64 架构、gdb 调试相关的知识。

实践的环境：同 [x86-64_架构]()

## 资料

笔记里的代码都在 {demo-assembly}/demo-in-linux/move-data/ 目录下。

## 正文

### mov

mov，传输数据。它把源操作数复制到目的操作数。`mov {源操作数}, {目的操作数}`。
源操作数可以是立即数、寄存器、内存位置。目的操作数可以是寄存器、内存位置。

两个操作数的大小必须相同，可以是字节（b）、字（w）、双字（l）、四字（q）。

代码示例：{demo-assembly}/demo-in-linux/move-data/mov.asm

如果内存上的数据是数组或者结构体这样的。
那么传输内存的数据到寄存器的时候，需要使用内存操作数，也就是间接寻址。
内存操作数的格式是 displacement(base, index, scale)。

- displacement，位移或偏移，可以是常量或者内存位置；
- base，地址址寄存器（可选参数），保存内存位置；
- index，索引寄存器（可选参数），保存下标；
- scale，缩放因子，可以理解为，一个下标对应的内存地址的长度，可以是 1,2,4,8；
- 获取的数据的起始地址就位于 displacement + base + index * size。

常用的用法有两种，下面用数组举例。

```
.section .data
    array1: .int 1,2,3,4,5
```

第一种用法。

```
movl $2, %r8d
movl array1(,%r8,4), %r10d
```

- displacement 是 array1，变量名对应的是一个内存地址，也就是数组的起始地址。
- base 不填；index 需要个寄存器，这里在 r8d 里塞个 2，然后，放在这里；scale 的 4 对应 int 的长度。
- 获取的数据的起始地址就位于 "&array1 + 2 * 4"，数组的起始地址向后偏移 8,，也就是下标为 2 的第 3 个元素。 

写成 c 语言就相当于这样。

```
array1 int[5] = {1, 2, 3, 4, 5}
r9d = *(array1+2)
```

第二种用法。

```
movq $array1, %r8
movl 4(%r8), %r10d
```

- displacement 是 4，常量，常量对应的是一个偏移。
- base 需要个寄存器，这里在 r8 里塞 array1 的地址，然后，放在这里；index 不填；scale 不填。
- 获取的数据的起始地址就位于 "4 + &array1 + 0 * 0"，数组的起始地址向后偏移 4，也就是下标为 1 的第 2 个元素。

### cmov（cmovcc）

cmov，带条件的 mov。`cmov {源操作数}, {目的操作数}`。使用方式和 mov 一样。

每条 cmovcc 指令都有一个条件代码（cc），用于指示测试的条件。
测试的条件是 eflags 寄存器中的状态标志（cf、of、pf、sf 和 zf）。
如果处于指定状态，则执行移动操作。如果不处于指定状态，则不执行移动操作。
详细的指令看文档，太多了这里就不写了。

cmov 前面需要一个 cmp。
cmp 用于比较两个操作数，并根据结果设置 eflags 寄存器中的状态标志。
`cmp {源操作数}, {目的操作数}`。cmp 的操作数只能是寄存器。

代码示例：{demo-assembly}/demo-in-linux/move-data/cmovcc.asm

### xchg

xchg，交换数据。`xchg {源操作数}, {目的操作数}`。
操作数可以是两个通用寄存器或一个通用寄存器和一个内存位置。

代码示例：{demo-assembly}/demo-in-linux/move-data/xchg.asm

### bswap

bswap，把寄存器上的数据的字节序翻转。`bswap {寄存器}`。
主要作用就是可以完成小端字节序和大端字节序的相互转换。

代码示例：{demo-assembly}/demo-in-linux/move-data/bswap.asm

### lea

lea，获取内存地址。`lea {源操作数}, {目的操作数}`。
计算源操作数的有效地址，并将其存储到目的操作数中。

源操作数是内存地址；目的操作数是通用寄存器。

代码示例：{demo-assembly}/demo-in-linux/move-data/lea.asm
