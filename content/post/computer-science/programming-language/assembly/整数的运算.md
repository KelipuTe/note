---
draft: false
date: 2023-07-13 08:00:00 +0800
title: "整数的运算（笔记片段）"
summary: "整数的四则运算；"
toc: true

categories:
  - programming-language(编程语言)

tags:
  - computer-science(计算机科学)
  - programming-language(编程语言)
  - assembly-language(汇编语言)
---

## 前言

这篇笔记需要 intel x86-64 架构、gdb 调试相关的知识。

实践的环境：同 [x86-64_架构]()

## 资料

## 正文

### add

add 可以实现整数的加法运算。

```
.section .data
    int1: .int 1
```

把立即数加到寄存器。

```
add $1, %rax
```

把寄存器加到寄存器。

```
add %rax, %rbx
```

把立即数加到内存。
    
```
addl $1, int1
```

### adc

adc 可以实现整数的加法运算。
与 add 不同的是，当 adc 的计算结果溢出时，会设置 cf 标志位。

```
movq $0x7fffffffffffffff, %rax
add $1, %rax
# 如果产生了溢出，那么就会设置 cf 标志位，jc 指令就会跳转到 exit 处
jc exit
```

### sub

sub 可以实现整数的减法运算。`sub {源操作数}, {目的操作数}`。

用目的操作数减源操作数，结果存入目的操作数。

目的操作数可以是寄存器或内存位置；源操作数可以是立即数、寄存器或内存位置。
寄存器减立即数；内存减立即数（需要带指令后缀）；寄存器减寄存器；内存减寄存器；寄存器减内存；

当使用立即值作为操作数时，它将被扩展到目的操作数格式的长度。

### sbb

sbb 可以实现整数的减法运算。`sbb {源操作数}, {目的操作数}`。

用目的操作数减（源操作数和 cf 标志之和），结果存入目的操作数。

目的操作数可以是寄存器或内存位置；源操作数可以是立即数、寄存器或内存位置。
寄存器减立即数；内存减立即数（需要带指令后缀）；寄存器减寄存器；内存减寄存器；寄存器减内存。

当使用立即值作为操作数时，它将被扩展到目标操作数格式的长度。

sbb 不区分有符号或无符号操作数，处理器自动处理。
如果是有符号整数产生了借位就设置 of 标志；如果是无符号整数产生了借位就设置 cf 标志。

### mul

mul 可以实现无符号整数的乘法运算。`sbb {源操作数}`。目的操作数要先放到 AL、AX、EAX、RAX 里面去。

执行源操作数和目的操作数的无符号乘法运算，结果存入目的操作数。

源操作数可以是寄存器或内存位置。寄存器乘寄存器；内存乘寄存器（需要带指令后缀）。

当目的操作数的寄存器放不下乘积的结果的时候，数据会被拆成两部分放到两个寄存器里去。
比如，RAX 不够放了，数据的前半部分会放到 RDX 里面去。详细内容看文档。

```
mov $0xffffffffffffffff, %rax
mov $2, %rbx
mul %rbx
```

无符号的 0xffffffffffffffff 已经把 rax 塞满了。这个时候再 x2，其结果 0x1fffffffffffffffe 需要 65 位的空间。
这个时候就会把数据拆成两部分，后面的 64 位（0xfffffffffffffffe）放在 rax，前面剩下的数据（0x1）放在 rdx。

### imul

imul 可以实现有符号整数的乘法运算。

### div

div 可以实现无符号整数的除法运算。

### idiv

idiv 可以实现有符号整数的除法运算。
