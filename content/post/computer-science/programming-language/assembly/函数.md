---
draft: false
date: 2023-07-15 08:00:00 +0800
title: "函数（笔记片段）"
summary: "函数；函数的参数；函数的约定；怎么调用 c 库函数；怎么传递结构体参数；怎么返回结构体参数；函数里怎么调用函数；"
toc: true

categories:
  - programming-language(编程语言)

tags:
  - computer-science(计算机科学)
  - programming-language(编程语言)
  - assembly-language(汇编语言)
---

### 函数

函数和代码块是不一样的。
函数用的是 call 指令，而代码块用的是 jmp 指令。
使用 jmp 指令的时候，除了不会有别的操作。

堆栈是操作系统分配给进程或线程的一块连续的内存空间。
它的主要功能有两个，一个是用于函数内部临时存储数据，另一个是用于函数间传递参数。

和堆栈有关系的指令就两个 push（入栈） 和 pop（出栈）。
每 push 或者 pop 一次，rsp 寄存器的值就会变一次。

当进入一个函数的时候，会把函数的下一行指令的地址 push 到堆栈。
然后，把 rip 修改成函数第一行指令的地址。

当函数执行完毕，执行 ret 指令的时候。
会从堆栈中把下一行指令的地址 pop 出来，然后，赋值给 rip。

代码示例：{demo-assembly}/demo-in-linux/function/stack.s

示意图：assembly.drawio.html 8-2

### 函数的参数

函数的参数可以用寄存器、全局变量、堆栈进行传递。

用寄存器的问题在于，谁都能对寄存器上的数据进行修改。
用全局变量的问题在于，谁都能对全局变量进行修改。
这两个很类似，都用全局变量的概念来理解就好。

### 函数的约定

[X86_calling_conventions](https://en.wikipedia.org/wiki/X86_calling_conventions)

找到 System_V_AMD64_ABI 这一条，这个是 64 位 linux 系统的函数约定。

整数用 rdi、rsi、rdx、rcx、r8、r9 传递。浮点数用 xmm0 ~ xmm7 传递。如果还不够，那就用堆栈传递。

64 位以下的整数返回值用 rad 传递，128 位以下的整数返回值用 rad 和 rdx 传递。浮点数返回值用 xmm0 和 xmm1 传递。

linux 系统提供的系统函数的参数数量都是 6 个及以内的。

代码示例：{demo-assembly}/demo-in-linux/function/conventions.s

示意图：assembly.drawio.html 8-4

```
# 恢复栈指针
mov %rbp, %rsp
pop %rbp
```

恢复栈指针的这两行指令，可以用 leave 指令代替。
leave 的作用 "Set RSP to RBP, then pop RBP"。

### 调用 c 库的 printf

想调用 printf，那按照函数的约定传参数就好了。

代码示例：{demo-assembly}/demo-in-linux/function/call_printf.s

这里需要注意的是，因为需要用到 c 库里的函数了，所以，链接的时候，需要加上动态库。

可以用 c 先写一个 hello world 看一下。

```
> ldd hello_world.elf
	linux-vdso.so.1 (0x00007ffd309b0000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f177ea00000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f177edd7000)
```

链接命令是这样写的：`ld -lc -I /lib64/ld-linux-x86-64.so.2 xxx.o -o xxx.elf`。
"-lc" 表示链接 c 动态库 libc.so.6，"-I /lib64/ld-linux-x86-64.so.2" 指定动态链接器。
