---
draft: false
date: 2023-07-15 08:00:00 +0800
title: "函数（笔记片段）"
summary: "函数；函数的参数；函数的约定；怎么调用 c 库函数；怎么传递结构体参数；怎么返回结构体参数；函数里怎么调用函数；"
toc: true

categories:
  - programming-language(编程语言)

tags:
  - computer-science(计算机科学)
  - programming-language(编程语言)
  - assembly-language(汇编语言)
---

## 前言

这篇笔记需要 intel x86-64 架构、数据传输、流程控制、整数、浮点数、字符串、gdb 调试相关的知识。

实践的环境：同 [x86-64_架构]()

## 资料

笔记里的代码都在 {demo-assembly}/demo-in-linux/integer/ 目录下。

## 正文

### 函数

函数和代码块是不一样的。函数用的是 call 指令，而代码块用的是 jmp 指令。
使用 jmp 指令的时候，除了跳转不会有别的动作。使用 call 指令的时候，除了跳转，还有一些别的动作。

堆栈是操作系统分配给进程或线程的一块连续的内存空间。
它的主要功能有两个，一个是用于函数内部临时存储数据，另一个是用于函数间传递参数。

和堆栈有关系的指令就两个 push（入栈） 和 pop（出栈）。每 push 或者 pop 一次，rsp 寄存器的值就会变一次。
push 的时候 rsp 的值变小（栈顶往上移动，反映在内存上就是内存地址变小），pop 就是 push 反过来。

当调用 call 进入一个函数的时候，会把 call 的下一行指令的地址 push 到堆栈。
然后，把 rip 修改成函数第一行指令的地址。下面执行的时候，就是函数的指令了。

当函数执行完毕，执行 ret 指令的时候。会从堆栈中把下一行指令的地址 pop 出来，然后，赋值给 rip。
这样 rip 就回到 call 的下一行指令上去了。就可以继续往下执行代码了。

代码示例：{demo-assembly}/demo-in-linux/function/stack.asm

示意图：assembly.drawio.html 8-2

### 函数的参数

函数的参数可以用寄存器、全局变量、堆栈进行传递。

用寄存器的问题在于，谁都能对寄存器上的数据进行修改。
用全局变量的问题在于，谁都能对全局变量进行修改。
这两个很类似，都用全局变量的概念来理解就好。

### 函数的约定

[X86_calling_conventions](https://en.wikipedia.org/wiki/X86_calling_conventions)

找到 System_V_AMD64_ABI 这一条，这个是 64 位 linux 系统的函数约定。

64 位整数用 rdi、rsi、rdx、rcx、r8、r9 传递，32 位的用 32 位对应的寄存器，以此类推。
浮点数用 xmm0 ~ xmm7 传递。如果参数很多，寄存器不够用的话，那就用堆栈传递。

64 位以下的整数返回值用 rad 传递，128 位以下的整数返回值用 rad 和 rdx 传递。
浮点数返回值用 xmm0 和 xmm1 传递。

linux 系统提供的系统函数的参数数量都是 6 个及以内的，寄存器是够用的。

代码示例：{demo-assembly}/demo-in-linux/function/conventions.asm

示意图：assembly.drawio.html 8-4

```
mov %rbp, %rsp
pop %rbp
```

这两行指令适用于恢复栈指针的，也可以用 leave 指令代替。
leave 的作用："Set RSP to RBP, then pop RBP"。

进入函数之后，一般会申请一块堆栈空间，把寄存器里的参数都存下来，因为不知道后续的操作会不会影响寄存器。

### 调用 c 库的 printf

想调用 printf，那按照函数的约定传参数就好了。

代码示例：{demo-assembly}/demo-in-linux/function/call_printf.s

这里需要注意的是，因为需要用到 c 库里的函数了，所以，链接的时候，需要加上动态库。

可以用 c 先写一个 hello world 看一下。

```
> ldd hello_world.elf
	linux-vdso.so.1 (0x00007ffd309b0000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f177ea00000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f177edd7000)
```

libc.so.6 就是需要的 c 动态库，"/lib64/ld-linux-x86-64.so.2" 是链接器。

链接命令是这样写的：`ld -lc -I /lib64/ld-linux-x86-64.so.2 xxx.o -o xxx.elf`。
"-lc" 表示链接 c 动态库，"-I /lib64/ld-linux-x86-64.so.2" 指定动态链接器。
