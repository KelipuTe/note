---
draft: false
date: 2023-07-12 08:00:00 +0800
title: "逻辑运算（笔记片段）"
summary: "与；或；非；异或；"
toc: true

categories:
  - programming-language(编程语言)

tags:
  - computer-science(计算机科学)
  - programming-language(编程语言)
  - assembly-language(汇编语言)
---

## 前言

这篇笔记需要 intel x86-64 架构、数据传输、gdb 调试相关的知识。

实践的环境：同 [x86-64_架构]()

## 资料

笔记里的代码都在 {demo-assembly}/demo-in-linux/logical/ 目录下。

## 正文

### and

and，与运算。`and {源操作数}, {目的操作数}`。
对源操作数和目的操作数进行按位与运算，并将结果存储到目的操作数。
如果源操作数和目的操作数相应位都为 1，则结果的相应位被设置为 1；反之，则被设置为 0。

源操作数可以是立即数、寄存器、内存位置；目标操作数可以是寄存器、内存位置。
但是，一条指令中不能使用两个内存操作数。

代码示例：{demo-assembly}/demo-in-linux/logical/and.asm

### or

or，或运算。`or {源操作数}, {目的操作数}`。
对源操作数和目的操作数进行按位或运算，并将结果存储到目的操作数。
如果源操作数和目的操作数相应位都为 0，则结果的相应位被设置为 0；反之，则被设置为 0。

源操作数可以是立即数、寄存器、内存位置；目标操作数可以是寄存器、内存位置。
但是，一条指令中不能使用两个内存操作数。

代码示例：{demo-assembly}/demo-in-linux/logical/or.asm

### not

not，非运算。`not {目的操作数}`。
对目标操作数进行按位非运算，并将结果存储到目标操作数位置。
如果位上是 1 则设置为 0，位上是 0 则设置为 1。

目标操作数可以是寄存器或内存位置。

代码示例：{demo-assembly}/demo-in-linux/logical/not.asm

### xor

xor，异或运算。`xor {源操作数}, {目的操作数}`。
对源操作数和目的操作数进行按位异或运算，并将结果存储到目的操作数。
如果源操作数和目的操作数相应位不同，则结果的相应位被设置为 1；反之，则被设置为 0。

源操作数可以是立即数、寄存器、内存位置；目标操作数可以是寄存器、内存位置。
但是，一条指令中不能使用两个内存操作数。

代码示例：{demo-assembly}/demo-in-linux/logical/xor.asm
