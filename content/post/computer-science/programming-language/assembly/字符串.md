---
draft: false
date: 2023-07-20 08:00:00 +0800
title: "字符串（笔记片段）"
summary: "字符串传输；字符串比较；"
toc: true

categories:
  - assembly-language(汇编语言)

tags:
  - computer-science(计算机科学)
  - programming-language(编程语言)
  - assembly-language(汇编语言)
---

## 前言

实践的环境：同 [x86-64_架构]()

## 资料

笔记里的代码在 {demo-assembly}/demo-in-linux/string/

示例代码：
- 字符串大小写转换。
- 判断两个字符串是否相等。
- 计算字符串长度。
- 在字符串中寻找指定字符，并返回找到的第一个指定字符的下标。

## 正文

### movs

movs，用于传输字符串。

指令的源操作数和目标操作数都是内存操作数。
源操作数的地址从 rsi 寄存器读取。目的操作数地址从 rdi 寄存器读取。
指令执行之前，必须正确加载这两个寄存器。

每执行一次指令，就会按照指令设置的字节、字、双字、四字传输一次。
然后，rsi 和 rdi 上存储的地址都会自动增加或者减少对应的位数。

rsi 和 rdi 上存储的地址是增加或者减少，这个由 eflags 寄存器的 df 标志决定。
df = 0 的时候增加，可以通过 cld 指令设置；df = 1 的时候减少，可以通过 std 指令设置。默认 df = 0。
需要从头开始处理字符串的时候用 cld，需要从尾开始处理字符串的时候用 std。

想要传输完整的字符串，可以使用循环结构来处理，也可以用 rep 指令。
rep，按 rcx 寄存器中指定的次数重复字符串指令，或者重复到不再满足 eflags 的 zf 标志的指定条件。
rep 可以加载字符串指令前面作为前缀，像这样 `rep movs`。

和 rep 相似的有 5 个指令。rep、repe、repz、repne、repnz。
rep 的结束条件是 rcx 寄存器为 0。
repe、repz 的结束条件是 rcx 寄存器为 0 或者 zf 标志为 0。
repne、repnz 的结束条件是 rcx 寄存器为 0 或者 zf 标志为 1。

### lods、stos

lods，将一个字节、字、双字、四字从源操作数加载到 al、ax、eax、rax 寄存器。

源操作数是内存操作数，源操作数的地址从 rsi 寄存器读取。
指令执行之前，必须正确加载这个寄存器。

stos，将 al、ax、eax、rax 寄存器中的字节、字、双字、四字存储到目标操作数中。

目标操作数是内存操作数，目标操作数的地址从 rdi 寄存器读取
指令执行之前，必须正确加载这个寄存器。

数据传输完成后，rsi 和 rdi 上存储的地址都会自动增加或者减少对应的位数。

### cmps

cmps，用于比较字符。

源操作数和目标操作数是内存操作数。
源操作数的地址从 rsi 寄存器读取。目的操作数的地址从 rdi 寄存器读取。
指令执行之前，必须正确加载这两个寄存器。

指令将源操作数指定的字节、字、双字、四字与目标操作数指定的字节、字、双字、四字进行比较。
相等的话，就设置 eflags 的 zf 标志为 1。不相等的话，就设置 eflags 的 zf 标志为 0。

每执行一次指令，就会按照指令设置的字节、字、双字、四字比较一次，并设置结果。
然后，rsi 和 rdi 上存储的地址都会自动增加或者减少对应的位数。

使用循环结构或者 rep，就可以实现比较两个字符串是否相等。

### scas

scas，用于比较字符。该指令有 2 种形式，取决于操作数的数量。

无操作数形式，`scas`。内存操作数地址从 rdi 寄存器中读取。

单操作数形式，`scas {内存操作数}`。

指令将内存操作数指定的字节、字、双字、四字与 al、ax、eax、rax 中的值进行比较。
相等的话，就设置 eflags 的 zf 标志为 1。不相等的话，就设置 eflags 的 zf 标志为 0。

每执行一次指令，就会按照指令设置的字节、字、双字、四字比较一次，并设置结果。
然后，rdi 上存储的地址会自动增加或者减少对应的位数。

使用循环结构或者 rep，就可以实现从字符串里找某个字符。
