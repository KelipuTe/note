---
draft: false
date: 2023-07-24 08:00:00 +0800
title: "函数和库（笔记片段）"
summary: "函数；函数的参数；函数的约定；函数里怎么调用函数；系统调用；怎么调用 c 库函数；
怎么传递和返回数组参数；怎么传递和返回结构体参数；命令行参数和环境变量；静态库和动态库；"
toc: true

categories:
  - assembly-language(汇编语言)

tags:
  - computer-science(计算机科学)
  - programming-language(编程语言)
  - assembly-language(汇编语言)
---

## 前言

实践的环境：同 [x86-64_架构]()

## 资料

笔记里的代码在：
- {demo-assembly}/demo-in-linux/function/
- {demo-assembly}/demo-in-linux/library/

示例代码：
- 打印命令行参数和环境变量。
- 打印全局变量的数组。
- 打印全局变量的结构体。

示意图：
- <a href="/drawio/computer-science/programming-language/assembly/assembly.drawio.html">assembly.drawio.html</a>

## 正文

### 函数

函数和代码块是不一样的。函数用的是 call 指令，而代码块用的是 jmp 指令。
使用 jmp 指令的时候，除了跳转不会有别的动作。使用 call 指令的时候，除了跳转，还有一些别的动作。

函数这里还有个堆栈的概念。堆栈是操作系统分配给进程或线程的一块连续的内存空间。
它的主要功能有两个，一个是用于函数内部临时存储数据，另一个是用于函数间传递参数。

和堆栈有关系的指令就两个 push（入栈） 和 pop（出栈）。
每 push 或者 pop 一次，rsp 寄存器的值就会变一次。在 64 位的系统上，一次移动 8 个字节。
push 的时候 rsp 的值变小（栈顶往上移动，反映在内存上就是内存地址变小），pop 就是 push 反过来。

当调用 call 进入一个函数的时候，会把 call 的下一行指令的地址 push 到堆栈。
然后，把 rip 修改成函数第一行指令的地址。下面执行的时候，就是函数的指令了。

当函数执行完毕，执行 ret 指令的时候。会从堆栈中把下一行指令的地址 pop 出来，然后，赋值给 rip。
这样 rip 就回到 call 的下一行指令上去了。就可以继续往下执行代码了。

示意图：assembly.drawio.html 8-2

### 函数的参数

函数的参数可以用寄存器、全局变量、堆栈进行传递。

用寄存器的问题在于，谁都能对寄存器上的数据进行修改。
用全局变量的问题在于，谁都能对全局变量进行修改。
这两个很类似，都用全局变量的概念来理解就好。

用堆栈也可以，但是，需要知道数据的大小和在内存上的具体位置。

### 函数的约定

[X86_calling_conventions](https://en.wikipedia.org/wiki/X86_calling_conventions)

在页面里找到 System_V_AMD64_ABI 这一条，这个是 64 位 linux 系统的函数约定。

64 位整数用 rdi、rsi、rdx、rcx、r8、r9 传递，32 位的用 32 位对应的寄存器，以此类推。
浮点数用 xmm0 ~ xmm7 传递。如果参数很多，寄存器不够用的话，那就用堆栈传递。

64 位以下的整数返回值用 rad 传递，128 位以下的整数返回值用 rad 和 rdx 传递。
浮点数返回值用 xmm0 和 xmm1 传递。

linux 系统提供的系统函数的参数数量都是 6 个及以内的，寄存器是够用的。

示意图：assembly.drawio.html 8-4

一般函数代码的最前面会有这几条指令。

```
push %rbp
mov %rsp, %rbp
sub $xxx, %rsp
```

先用堆栈保存 rbp 的值，这个时候 rsp 会上移。然后，把 rsp 当前的值给 rbp。
然后，rsp 减去一个数值，这个操作相当于在内存上开辟了一块空间。这个位置一般用于存储函数的局部变量

进入函数之后，一般会申请一块堆栈空间，把寄存器里的参数都存下来，因为不知道后续的操作会不会影响寄存器。
申请的堆栈空间可以大一点，我发现有的时候申请正好够用的空间，调用 c 库函数的时候会 core dump，申请的大一点又不会 core dump。

一般函数代码的最后面会有这两条指令。

```
mov %rbp, %rsp
pop %rbp
```

这两条指令适用于恢复栈指针的，也可以用 leave 指令代替。
leave 的作用："Set RSP to RBP, then pop RBP"。

### 系统调用

### 调用 c 库的 printf

想调用 printf，那按照函数的约定传参数就好了。

这里需要注意的是，因为需要用到 c 库里的函数了，所以，链接的时候，需要加上动态库。

可以用 c 先写一个 hello world 看一下。

```
> ldd hello_world.elf
	linux-vdso.so.1 (0x00007ffd309b0000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f177ea00000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f177edd7000)
```

libc.so.6 就是需要的 c 动态库，"/lib64/ld-linux-x86-64.so.2" 是链接器。

链接命令是这样写的：`ld -lc -I /lib64/ld-linux-x86-64.so.2 xxx.o -o xxx.elf`。
"-lc" 表示链接 c 动态库，"-I /lib64/ld-linux-x86-64.so.2" 指定动态链接器。

### 命令行参数和环境变量

示意图：assembly.drawio.html 8-6

### 多文件编译

如果一个汇编程序由多个文件组成，编译的时候分别编译，链接的时候一起链接。

```
as xxx.asm -o xxx.o -g
as yyy.asm -o yyy.o -g
ld xxx.o yyy.o -o xxxyyy.elf
```

还需要注意函数的作用域，如果要给别的文件用，那么定义的时候，需要加一个 ".global"。

```
.section .text
.type functionName, @function
.global functionName
functionName:
    push %rbp
    mov %rsp, %rbp

    sub $16, %rsp

    leave
    ret
```

### 静态库和动态库

实例在这里：{demo-assembly}/demo-in-linux/library/

主要关注这几个文件 caller.asm、part1.asm、part2.asm。

#### 静态库

静态库说白了就是将多个文件组合在一起。
主要的用处就是，编译或者链接的时候，可以少写一堆文件名。
比如，把 part1 和 part2 组合。

```
# ar r lib{名字}.a {xxx}.o ...
ar r libpart.a part1.o part2.o
```

然后，编译或者链接的时候，写静态库就行，不用写那两个文件了。

```
ld caller.o libpart.a -o caller_ld.elf
# gcc xxx.c lib{名字}.a -o xxx.elf
```

最终生成的 elf 里面，会包括静态库的所有代码。所以，静态库的缺点也就出来了。
如果多个应用程序都用了同一个静态库，那么磁盘里就会存在重复的代码。
如果修改了静态库，那么所有用到这个静态库的应用程序都需要重新编译。

#### 动态库

动态库和静态库思路差不多，也是将多个文件组合在一起。

```
# gcc -shared -o lib{名字}.so {xxx}.o ...
gcc -shared -o libpart.so part1.o part2.o
```

然后，编译或者链接的时候，写动态库就行。

```
# gcc xxx.c lib{名字}.so -o xxx.elf
ld caller.o libpart.so -o caller_so.elf
```

和静态库不一样的地方，最终生成的 elf 里面，不会包括动态库的代码。
程序运行的时候，需要依靠动态库加载器（ld.so）加载动态库。

用 ldd 命令可以看到程序依赖的动态库的名字，还有动态库的地址。

```
> ldd caller_so.elf
	linux-vdso.so.1 (0x00007ffc90745000)
	libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6 (0x00007f6c97200000)
	/lib64/ld-linux-x86-64.so.2 (0x00007f6c975b2000)
	libpart.so => not found
```

如果显示 not found，就执行一下 `export LD_LIBRARY_PATH="$LD_LIBRARY_PATH:."` 然后再看看。

动态库可以解决静态库的两个问题。
如果多个应用程序都用了同一个动态库，那么磁盘里只需要存储一份代码。
如果修改了动态库，程序运行的时候，动态库加载器就会加载新的动态库。
