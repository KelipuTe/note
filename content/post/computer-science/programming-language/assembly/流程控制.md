---
draft: false
date: 2023-07-12 08:00:00 +0800
title: "流程控制（笔记片段）"
summary: "分支跳转；选择结构；循环结构；"
toc: true

categories:
  - programming-language(编程语言)

tags:
  - computer-science(计算机科学)
  - programming-language(编程语言)
  - assembly-language(汇编语言)
---

## 前言

这篇笔记需要 intel x86-64 架构、数据传输、gdb 调试相关的知识。

实践的环境：同 [x86-64_架构]()

## 资料

笔记里的代码都在 {demo-assembly}/demo-in-linux/structure/ 目录下。

## 正文

### jmp

jmp 将程序控制转移到指令流的另一点，不记录返回信息。`jmp {目的操作数}`。
目标操作数指定被跳转指令的地址。该操作数可以是立即数、通用寄存器、内存位置。
跳转是无条件的。相当于 c 语言里的 goto。

代码示例：{demo-assembly}/demo-in-linux/structure/jmp.asm

这种是带名字的标签的写法。
看编译后的代码比较好理解，exit 就像变量一样对应某个内存地址，jmp 就是跳到 exit 指向的地址上去了。

```
0000000000401000 <_start>:
  401007:	eb 17                	jmp    401020 <exit>

0000000000401020 <exit>:
exit:
  401020:	48 c7 c0 03 00 00 00 	mov    $0x3,%rax
```

标签也可以不带名字，就是单纯的数字。和带名字一样，数字对应某个内存地址。

代码示例：{demo-assembly}/demo-in-linux/structure/jf_and_jb.asm

和带名字的标签不一样用法不太一样，用数字的时候需要指定方向。
比如，上面这段代码里的。1f 表示，往下找 1 标签，然后，跳过去。0b 表示，往上找 0 标签，然后，跳过去。
不写 f 和 b 编译的时候不会报错，但是运行的时候会报错。因为，jmp 会认为是跳到内存地址 1 上去。
然后，rip 寄存器的值就变成 1 了，这显然是不对的。

这两个结合起来用是可以实现循环结构的。

### j（jcc）

每条 jmp 指令都有一个条件代码（cc），用于指示测试的条件。
测试的条件是 eflags 寄存器中的一个或多个状态标志（cf、of、pf、sf 和 zf）。
如果处于指定状态，则执行跳转操作。如果不处于指定状态，则不执行跳转操作。
详细的指令看文档，太多了这里就不写了。使用方式和 cmovcc 有点像。

代码示例：{demo-assembly}/demo-in-linux/structure/jcc.asm

### loop

loop 使用寄存器 rcx、ecx、cx 作为计数器执行循环操作（取决于地址大小是 64 位、32 位、16 位）。

代码示例：{demo-assembly}/demo-in-linux/structure/loop.asm
