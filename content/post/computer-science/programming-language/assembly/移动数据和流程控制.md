---
draft: false
date: 2023-07-12 08:00:00 +0800
title: "移动数据和流程控制（笔记片段）"
summary: "移动数据；间接寻址；无条件跳转；分支结构；循环结构；有条件的指令；"
toc: true

categories:
  - programming-language(编程语言)

tags:
  - computer-science(计算机科学)
  - programming-language(编程语言)
  - assembly-language(汇编语言)
---

## 前言

实践的环境：同 [x86-64_架构]()

## 资料

示意图：
- <a href="/drawio/computer-science/programming-language/assembly/assembly.drawio.html">assembly.drawio.html</a>

## 正文

### 移动数据

#### bswap

bswap，用于翻转寄存器上的数据的字节序。
主要用于小端字节序和大端字节序相互转换。

#### lea

lea，用于获取内存地址。
主要用于把变量的内存地址传输到寄存器中。

#### mov

mov，用于移动数据，把源操作数复制到目标操作数。
使用的时候需要注意，两个操作数的大小必须相同。

`mov 变量名, 寄存器`，表示移动变量上存储的值到寄存器。我的理解，这个时候是内存操作数的逻辑。
`mov $变量名, 寄存器`，表示移动变量的起始地址到寄存器。我的理解，这个时候是立即数的逻辑。

如果传输的数据是数组或者结构体这样的。那么就需要使用内存操作数，也就是间接寻址。
内存操作数的格式是 `displacement(base, index, scale)`。

- displacement，常量或者内存操作数；
- base，地址寄存器（可选参数），内存操作数；
- index，索引寄存器（可选参数）。比如，数组下标；
- scale，缩放因子，可以是 1,2,4,8；
- 获取的数据的起始地址就位于 displacement + base + index * size。

常用的用法有两种，下面用数组举例。

```
.section .data
    array1: .int 1,2,3,4,5
```

第一种用法。

```
movl $2, %r8d
movl array1(,%r8,4), %r10d
```

- displacement 是 array1，array1 对应的是一个内存操作数，也就是数组的起始地址。
- base 不填；index 下标是 2；scale 缩放因子是 4，对应 int 的长度。
- 获取的数据的起始地址就位于 "array1 + 2 * 4"，数组的起始地址向后偏移 8，也就是下标为 2 的第 3 个元素。

写成 c 语言就相当于这样。

```
array1 int[5] = {1,2,3,4,5}
r9d = *(array1+2)
```

第二种用法。

```
movq $array1, %r8
movl 4(%r8), %r10d
```

- displacement 是 4，常量。
- base 地址是 array1，array1 对应的是一个内存操作数，也就是数组的起始地址。index 不填；scale 不填。
- 获取的数据的起始地址就位于 "4 + array1 + 0 * 0"，数组的起始地址向后偏移 4，也就是下标为 1 的第 2 个元素。

#### movsx

movsx，带符号扩展数据。

8 位的 -1（1111,1111），带符号扩展到 16 位，依然是 -1（1111,1111,1111,1111）。

#### movzx

movsx，扩展数据后填充 0。

8 位的 -1（1111,1111），扩展到 16 位后填充 0，就不是 -1 了，而是 255（0000,0000,1111,1111）。

#### xchg

xchg，用于交换数据。

### 流程控制

### jmp

jmp，无条件跳转到另一处继续执行程序。和 c 语言里的 goto 一个意思。

jmp 指令的标签有两种写法，有名字的标签和纯数字标签。

有名字的标签。

```
_start:
    mov $1, %rax
    jmp jmpPoint
    mov $2, %rax
jmpPoint:
    mov $3, %rax
```

看编译后的代码比较好理解，jmpPoint 标签就像变量一样，对应某个内存地址，jmp 就是跳到 jmpPoint 指向的地址上去了。

```
0000000000401000 <_start>:
  401000:	48 c7 c0 01 00 00 00 	mov    $0x1,%rax
  401007:	eb 07                	jmp    401010 <jmpPoint>
  401009:	48 c7 c0 02 00 00 00 	mov    $0x2,%rax

0000000000401010 <jmpPoint>:
  401010:	48 c7 c0 03 00 00 00 	mov    $0x3,%rax
```

示意图：assembly.drawio.html 2-4

纯数字标签。

```
_start:
    mov $1, %rax
    jmp 1f
0:
    mov $2, %rax
1:
    mov $3, %rax
    jmp 0b
```

和有名字的标签一样，纯数字标签也对应某个内存地址。

纯数字标签和有名字的标签用法不太一样，用数字的时候需要指定方向。
比如，上面这段代码里的。1f 表示，往下找 1 标签，然后，跳过去。0b 表示，往上找 0 标签，然后，跳过去。

不写 f 和 b，在编译的时候不会报错，但是，运行的时候会报错。
因为，jmp 会认为是跳到内存地址 1 上去。然后，rip 寄存器的值就变成 1 了，这显然是不对的。

这两个结合起来用是可以实现循环结构的，上面的代码就是个死循环。

### loop

loop，用于实现循环结构。

先往 rcx、ecx、cx 寄存器（取决于系统是 64 位、32 位、16 位）中传输循环需要执行的次数。
然后，设置跳转的标签。每一次运行到 loop 指令处时。先检测计数寄存器的值。
如果计数寄存器大于 0，则跳转到标签处，计数寄存器自动减 1，然后，继续执行。

```
	mov $5, %rcx
loopPoint:
	mov %rcx, %rdx
	loop loopPoint
```

### 有条件的指令

#### cmp

cmp，用于比较两个操作数，并根据结果设置 eflags 寄存器中的标志位。

标志位一般是给 jcc、loopcc、cmovcc、fcmovcc 这种带条件的指令用的。

带条件的指令，每条指令都有一个条件代码（cc），用于指示测试的条件。
测试的条件是 eflags 寄存器中的状态标志（cf、of、pf、sf、zf）。
如果处于指定状态，则执行相应的操作。如果不处于指定状态，则不执行操作。

#### cmovcc

cmov，带条件的 mov。

```
    cmp %rbx, %rcx
    cmovl $2, %rax
```

cmovg（great），如果 rcx > rbx 则执行 rax = 2。

#### jcc

jcc，带条件的 jmp。

```
    mov $1, %rax
    cmp %rbx, %rcx
    jg jmpPoint
    mov $2, %rax
jmpPoint:
    mov $3, %rax
```

jg（great），如果 rcx > rbx 则跳转到 jmpPoint 继续执行。
