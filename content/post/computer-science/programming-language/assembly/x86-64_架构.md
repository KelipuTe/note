---
draft: false
date: 2023-07-11 08:00:00 +0800
title: "intel x86-64 架构（笔记片段）"
summary: "intel cpu 文档；x86-64 架构；寄存器；指令；数据类型；"
toc: true

categories:
  - programming-language(编程语言)

tags:
  - computer-science(计算机科学)
  - programming-language(编程语言)
  - assembly-language(汇编语言)
---

## 正文

### 官方文档

[英特尔 64 和 32 架构软件开发手册](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)

在页面里找到：Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 1: Basic Architecture。这个就是开发手册了。

### intel x86-64 架构

x86 泛指基于 intel 8086 并且向后兼容的 cpu 指令级架构。
最早的 intel 8086 是 16 位的微处理器（1978 年），后面还有 80816、80826、80836、80846 等。
现在，提到 x86，一般是指 32 位的架构（1985 年）。提到 x86-64（或者 x64），一般是指 64 位的架构（2003 年）。

开发手册 3.2，里面有讲 32 位和 64 位架构的执行环境（Execution Environment）。
里面有：寄存器的种类、位数、个数；内存地址空间的范围。

### 寄存器

开发手册 3.4，里面有讲寄存器。里面有寄存器的用途、名字、大小。

低 8 位：AL、BL、CL、DL、DIL、SIL、BPL、SPL、R8L ~ R15L
低 16 位：AX、BX、CX、DX、DI、SI、BP、SP、R8W ~ R15W
32 位：EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、R8D ~ R15D
64 位：RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP、R8 ~ R15

RIP 程序计数器，上面存储的是下一调要执行的指令的地址。
分支（branch）指令就是通过修改 RIP 的值，实现程序的选择结构和循环结构。

### 指令

指令由操作码和操作数组成。
操作码，opcode，operation code，告诉 cpu 要做什么。
操作数，operand，有源操作数和目的操作数两种。
操作数的值有三种：立即数（写死的值）、寄存器、内存地址。

指令的详细内容看这个网页：
[x86 and amd64 instruction reference](https://www.felixcloutier.com/x86/)

### 原码、反码、补码

在计算机中，数据都是以补码的形式存储的。

对于有符号整数。
正整数的源码 = 反码 = 补码。
负整数的反码 = 除了源码的符号位，源码的其他位全部取反。
负整数的补码 = 负整数的反码 + 1。

- 用 1 字节表示的 +000；源码 = 00000000；反码 = 00000000；补码 = 00000000；
- 用 1 字节表示的 +001；源码 = 00000001；反码 = 00000001；补码 = 00000001；
- 用 1 字节表示的 +127；源码 = 01111111；反码 = 01111111；补码 = 01111111；
- 用 1 字节表示的 -001；源码 = 10000001；反码 = 11111110；补码 = 11111111；
- 用 1 字节表示的 -002；源码 = 10000010；反码 = 11111101；补码 = 11111110；
- 用 1 字节表示的 -126；源码 = 11111110；反码 = 10000001；补码 = 10000002；
- 用 1 字节表示的 -127；源码 = 11111111；反码 = 10000000；补码 = 10000001；
- 用 1 字节表示的 -128；补码 = 10000000；

10000000 应该是 -000 的位置，被用来存储 -128 了。
如果按加法算的话，-128 = -127 + -1 = 10000001 + 11111111 = 10000000，符号位固定为 -1，后面的部分其实溢出了。

### 数据的范围

整数

- 1 字节，2^8 = 256 个数字，0xff ~ 0x7f，-128~127。
- 2 字节，2^16 = 65,535 个数字，0xffff ~ 0x7fff，-32,768 ~ 32,767。
- 4 字节，2^32 = 4,294,967,295 个数字，0xffffffff ~ 0x7fffffff，-2,147,483,648 ~ 2,147,483,647。
- 8 字节，2^64= 18,446,744,073,709,551,616 个数字，
  0xffffffffffffffff ~ 0x7fffffffffffffff，9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807

浮点数

- float，单精度，4 字节，
- double，双精度，8 字节，

### 数据类型

- ".string"，以 "\0" 结束的字符串。
- ".byte"，定长 1 字节整型。
- ".short"、".word"，定长 2 字节整型。
- ".int"、".long"，定长 4 字节整型。
- ".quad"，定长 8 字节整型。
- ".float"，定长单精度浮点数，4 字节。
- ".double"，定长双精度浮点数，8 字节。

声明一个经过初始化的变量。

```
.section .data
    {变量名}:
        {数据类型} {数据}
```

声明一个没有初始化的变量。

```
.section .bss
    .lcomm {变量名}, {数据长度}
```

声明一个常量。如果有多个，就多写几行。

```
.equ {变量名},{值}
```

### 汇编代码

- 编译：as -g xxx.s -o xxx.o 生成可重定位文件。
- 链接：ld xxx.o -o xxx.elf 生成可执行文件。

汇编代码建议使用 gdb 进行调试，方便观察寄存器的值。
进入 gdb 调试之后。使用 "b *_start" 命令，在程序入口打断点。
