---
draft: false
date: 2023-07-11 08:00:00 +0800
title: "intel x86-64 架构（笔记片段）"
summary: "intel cpu 架构文档；intel x86-64 架构；
寄存器；数据类型；原码、反码、补码；数据的范围；数据扩展；指令；
hello world；编译、链接、调试；"
toc: true

categories:
  - assembly-language(汇编语言)

tags:
  - computer-science(计算机科学)
  - programming-language(编程语言)
  - assembly-language(汇编语言)
---

## 前言

实践的环境：

- amd64（x86_64）
- windows 11
- vmware workstation pro 16
- ubuntu 22.04
- linux version 5.19.0-41-generic
- gcc version 11.3.0

我是在虚拟机里跑的汇编程序，有的时候会遇到一些离谱的问题。
比如，同样一段汇编代码，重复执行的时候，结果不一样，有的时候成功，有的时候 core dump。
但是，gdb 调试的时候，寄存器和内存里的数据是对的，调用系统调用或者 c 库会 core dump。

笔记顺序：

- x86-64 架构
- [移动数据和流程控制](/post/computer-science/programming-language/assembly/移动数据和流程控制)
- 整数
- 浮点数
- 字符串
- [函数和库](/post/computer-science/programming-language/assembly/函数和库)
- 系统调用
- 内联汇编

## 正文

### intel cpu 架构文档

[英特尔 64 和 32 架构软件开发人员手册](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)

在页面里找到 "Intel® 64 and IA-32 Architectures Software Developer's Manual Volume 1: Basic Architecture"。

这个手册下面简称为 "基本架构手册"，介绍了处理器的架构和编程环境。
这里主要看的是 64 位架构的寄存器、内存、指令相关的内容，写汇编程序最主要的就是这三个东西。

### intel x86-64 架构

x86 泛指基于 intel 8086 并且向后兼容的 cpu 指令级架构。
最早的 intel 8086 是 16 位的微处理器（1978 年），后面还有 80816、80826、80836、80846 等。
现在，提到 x86，一般是指 32 位的架构（1985 年）。提到 x86-64（或者 x64），一般是指 64 位的架构（2003 年）。

[基本架构手册 3.2.1 节]() 这里主要看的是 64 位架构的内存地址空间、寄存器相关的内容。

[基本架构手册 3.3.7 节]() 这里主要看的是指令指针寄存器（rip）相关的内容。

指令指针寄存器（instruction pointer register），又叫程序计数器（program counter）。
指令指针寄存器上面存储的是下一条要执行的指令的地址。

注意指令指针寄存器和指令寄存器（instruction register）的区别。
指令寄存器上面存储的是正在被执行的指令。

分支（branch）指令，比如 jmp，就是通过修改 rip 的值，实现选择结构和循环结构的。

### 寄存器

[基本架构手册 3.4.1.1 节]() 这里主要看的是 64 位架构的通用寄存器相关的内容。

- 8 位：al、bl、cl、dl、dil、sil、bpl、spl、r8l ~ r15l
- 16 位：ax、bx、cx、dx、di、si、bp、sp、r8w ~ r15w
- 32 位：eax、ebx、ecx、edx、edi、esi、ebp、esp、r8d ~ r15d
- 64 位：rax、rbx、rcx、rdx、rdi、rsi、rbp、rsp、r8 ~ r15

rsp 就是栈指针，永远指向进程堆栈空间的栈顶。
函数的调用堆栈那里就需要用到 rbp、rsp 这两个寄存器。

[基本架构手册 3.4.1.1 节]() 这里主要看的是 64 位架构的通用寄存器相关的内容。

[基本架构手册 3.4.3 节]() 这里主要看的是 eflags 寄存器相关的内容。

cf，进位标志。最高位产生进位或者借位，则 cf=1，否则 cf=0。无符号整数运算结果溢出 cf=1。

zf，零标志。运算结果是 0，则 zf=1，否则 zf=0。

sf，符号标志位。就等于运算结果的最高位。有符号整数的符号位。

of，溢出标志。运算结果正数太大或者负数太小（不包括符号位），则 of=1,，否则 of=0。

[基本架构手册 3.7.3.1 节]() 这里主要看的是 64 位架构的内存操作数关的内容。

[基本架构手册 8.1.2 节]() 这里主要看的是浮点数（fpu）寄存器相关的内容。
fpu 寄存器是栈结构的，有 8 个 80 位的寄存器 st(0) ~ st(7)。
需要注意的是，入栈的时候，新数据始终在 st(0) 位置，老数据依次往上移动。

[基本架构手册 10.2.2 节]() 这里主要看的是 xxm 寄存器相关的内容。
有 8 个 128 位的寄存器 xmm0 ~ xmm7。

### 数据类型

[基本架构手册 4 章]()，这里主要看的是数据类型。

- ".byte"，定长 1 字节整型。
- ".short"、".word"，定长 2 字节整型。
- ".int"、".long"，定长 4 字节整型。
- ".quad"，定长 8 字节整型。
- ".float"，定长单精度浮点数，4 字节。
- ".double"，定长双精度浮点数，8 字节。
- ".string"，以 "\0" 结束的字符串。

声明经过初始化的变量。

```
.section .data
    {变量名1}: {数据类型} {数据}
    {变量名2}: {数据类型} {数据}
```

声明经过初始化的数组。

```
.section .data
    {变量名1}: {数据类型} {元素}, {元素}, {元素}...
```

声明经过初始化的结构体。

```
.section .data
    {变量名1}: 
    {属性名1}: {数据类型} {数据}
    {属性名2}: {数据类型} {数据}
    这里一定要空一行，要不然后面声明的变量，就会被当成结构体的属性
```

声明没有初始化的变量。

```
.section .bss
    .lcomm {变量名1}, {数据长度}
    .lcomm {变量名2}, {数据长度}
```

声明常量。

```
.equ {变量名1}, {值}
.equ {变量名2}, {值}
```

### 原码、反码、补码

在计算机中，数据都是以补码的形式存储的。

对于有符号整数。
正整数的源码 = 反码 = 补码。
负整数的反码 = 除了源码的符号位，源码的其他位全部取反。
负整数的补码 = 负整数的反码 + 1。

- 这里的例子都是 1 字节的。
- +000；源码 = 0000,0000；反码 = 0000,0000；补码 = 0000,0000；
- +001；源码 = 0000,0001；反码 = 0000,0001；补码 = 0000,0001；
- +127；源码 = 0111,1111；反码 = 0111,1111；补码 = 0111,1111；
- -001；源码 = 1000,0001；反码 = 1111,1110；补码 = 1111,1111；
- -002；源码 = 1000,0010；反码 = 1111,1101；补码 = 1111,1110；
- -126；源码 = 1111,1110；反码 = 1000,0001；补码 = 1000,0002；
- -127；源码 = 1111,1111；反码 = 1000,0000；补码 = 1000,0001；
- -128；补码 = 1000,0000；

10000000 应该是 -000 的位置，被用来存储 -128 了。

- -127 + -001 = 1000,0001 + 11111111 = 1,1000,0000
- +001 + -001 = 0000,0001 + 11111111 = 1,0000,0000

这两种情况，计算的时候，理论上都是溢出的。但是，如果把溢出的部分去掉，结果又是对的。

### 数据的范围

#### 整数

1 字节，8 位，可以表示 2^8 = 256 个数字。

有符号整形，0xff ~ 0x7f，-128 ~ 127。

2 字节，16 位，可以表示 2^16 = 65,535 个数字。

有符号整形，0xffff ~ 0x7fff，-32,768 ~ 32,767。

4 字节，32 位，可以表示 2^32 = 4,294,967,295 个数字。

有符号整形，0xffff,ffff ~ 0x7fff,ffff，-2,147,483,648 ~ 2,147,483,647。

8 字节，64 位，可以表示 2^64= 18,446,744,073,709,551,616 个数字。

有符号整形，0xffff,ffff,ffff,ffff ~ 0x7fff,ffff,ffff,ffff，9,223,372,036,854,775,808 ~ 9,223,372,036,854,775,807。

#### 浮点数

float，单精度，4 字节，1 位符号，8 位指数，23 位尾数。
1.175494351 E–38 ~ 3.402823466 E+38，6 ~ 7 个有效数字。

double，双精度，8 字节，1 位符号，11 位指数，52 位尾数。
2.2250738585072014 E–308 ~ 1.7976931348623158 E+308，15 ~ 16 个有效数字

### 数据扩展

#### 整数

无符号整数和有符号正整数，在前面补 0。有符号负整数，在前面补 1。

1 字节的 -1 补码是 1111,1111，扩展到 2 字节，补码是 1111,1111,1111,1111。

至于为什么，看上面 [原码、反码、补码]() 那里 -1 和 -2 的补码就知道了。

### 指令

[开发手册第 5 章]()，这里主要看的是指令相关的内容。

指令由操作码和操作数组成。
操作码，opcode，operation code，告诉 cpu 要做什么。
操作数，operand，有源操作数和目标（目的）操作数两种。
操作数的值有三种：立即数（写死的值）、寄存器、内存操作数。

也可以看这个页面 [x86 and amd64 instruction reference](https://www.felixcloutier.com/x86/)

这个网页里的指令是 intel 格式的，intel 格式的汇编和 att 格式的汇编，源操作数和目标操作数位置是反的。
imm{数字}，这种表示立即数；r 开头的表示寄存器；m 开头的表示内存操作数。还需要注意指令在 64 位操作系统上支不支持。

有的指令后面可以加后缀，后缀一般和操作的数据大小有关系。

- b 对应 char，1 字节。
- w（word，字）对应 short，2 字节。
- l（double word，双字）对应 int、unsigned int，4 字节。
- q（quad word，四字）对应 long、unsigned long、pointer，8 字节。
- s 对应 float，4 字节。
- d 对应 double，8 字节。

### hello world

代码示例：{demo-assembly}/demo-in-linux/hello_world.asm

这个程序主要涉及汇编程序结构、移动数据、系统调用的内容，这里不展开说。

### 汇编代码的编译、链接、调试

编译生成可重定位文件。
`as xxx.asm -o xxx.o -g`。
"-g" 表示添加调试信息。

链接生成可执行文件。
`ld xxx.o -o xxx.elf`。

汇编程序可以使用 gdb 进行调试，方便观察寄存器和内存中的数据。
进入 gdb 调试后，使用命令 `b *_start`，在汇编程序入口打断点。
然后，使用命令 `r`，运行到断点处。然后，就是常规的 gdb 调试流程。
