---
draft: false
date: 2023-07-12 08:00:00 +0800
title: "数据的传输和流程的控制（笔记片段）"
summary: "数据传输；数据交换；数据比较；分支跳转；循环结构；"
toc: true

categories:
  - programming-language(编程语言)

tags:
  - computer-science(计算机科学)
  - programming-language(编程语言)
  - assembly-language(汇编语言)
---

## 资料

笔记里的代码都在 [{demo-assembly}](https://github.com/KelipuTe/demo-assembly)/demo-in-linux/mov/ 目录下。

## 正文

### mov

mov 用于传输数据。

- mov，可以没有后缀。
- movb，b 对应 char，1 字节。
- movw，w（word，字）对应 short，2 字节。
- movl，l（double word，双字）对应 int、unsigned int，4 字节。
- movs，s 对应 float，4 字节。
- movq，q（quad word，四字）对应 long、unsigned long、pointer，8 字节。
- movd，d 对应 double，8 字节。

不同的指令后缀和操作数的大小还有寄存器的大小要匹配上，要不然会报错。

```
.equ CONST_INT1,100
.equ CONST_INT2,200

.section .data
    int1:
        .int 0x7fffffff
    list1:
        .int 1,2,3,4,5

.section .bss
    .lcomm int2, 4
```

传输立即数到寄存器。

```
movb $0x7f, %al
```

传输寄存器的数据到寄存器。

```
movq %rax, %rbx
```

传输内存的数据到寄存器。

```
movl int1, %eax
```

传输寄存器的数据到内存。

```
movl %eax, int2
```

如果内存上的数据是数组这样的，那么传输内存的数据到寄存器的时候，需要使用偏移量。
表达式格式是 base_address(offset_address,index,size)。offset_address 和 index 的值必须是寄存器。
获取的数据的起始地址位于 base_address + offset_address + index * size。

```
movl $0, %r8d
movl list1(,%r8,4), %r9d
movl $2, %r8d
movl list1(,%r8,4), %r10d
movl $4, %r8d
movl list1(,%r8,4), %r11d
```

用 c 语言来描述的话，就像下面这样。

```
r9d = *(list1+0)
r9d = *(list1+2)
r9d = *(list1+4)
```

寄存器可以用来进行间接寻址。

```
movq $list1, %r8
movl (%r8), %r9d
movl 4(%r8), %r10d
movl 12(%r8), %r11d
```

用 c 语言来描述的话，就像下面这样。

```
r8 = list1
r9d = *((int*)(((char*)r8)+0))
r9d = *((int*)(((char*)r8)+4))
r9d = *((int*)(((char*)r8)+4))
```

`movl 4(%r8), %r10d` 就表示，从 %r8 存储的地址向后偏移 4 个地址，然后，取 4 个字节放到 r10d。

传输常量到寄存器。

```
mov $CONST_INT1, %rax
mov $CONST_INT2, %rax
```

### cmov（cmovcc）

cmov 条件为真，就传输数据。cmov 前面一般会有一个 cmp。
cmp 用于比较两个操作数的大小。cmp 的操作数只能是寄存器。

```
cmp %rax, %rbx
cmovg %rax, %r8
```

如果 rbx > rax，就把 rax 传输给 r8。

cmov 有很多的后缀。

- cmove，equal，等于
- cmovne，equal，不等于
- cmova，above，大于
- cmovae，above，大于等于
- cmovg，greater，大于
- cmovge，greater，大于等于
- cmovb，below，小于
- cmovbe，below，小于等于
- cmovl，less，小于
- cmovle，less，小于等于
- 详细内容看文档

### xchg

xchg 把寄存器或者内存上的数据和寄存器进行交换。
指令是这样的：`xchg {寄存器|内存}, {寄存器}`。

### bswap

bswap 可以把寄存器上的数据的字节序翻转。
指令是这样的：`bswap {寄存器}`。

```
mov $0x1122334455667788, %rax
# rax = 0x1122334455667788
bswap %rax
# rax = 0x8877665544332211
```

### jmp

jmp 用于无条件分支跳转，相当于 goto。

```
_start:
    mov $1, %rax
    jmp exit
    mov $2, %rax
exit:
    mov $3, %rax
```

看编译后的代码比较好理解，jmp 就是跳到 exit 的起始地址上去了。

```
0000000000401000 <_start>:
  401007:	eb 17                	jmp    401020 <exit>

0000000000401020 <exit>:
exit:
  401020:	48 c7 c0 03 00 00 00 	mov    $0x3,%rax
```

jmp 也可以不写函数名。

```
_start:
    mov $1, %rax
    jmp 0f
    mov $2, %rax
0:
    mov $3, %rax
```

### j（jcc）

j 条件为真，就进行分支跳转。j 前面一般会有一个 cmp。
使用方式和 cmov 有点像。

```
_start:
    mov $1, %rax
    cmp %rax, %rbx
    jg exit
    mov $2, %rax
exit:
    mov $3, %rax
```

如果 rbx > rax，就跳转到 exit 继续执行。

j 也有很多的后缀。

- je，equal，等于
- jne，equal，不等于
- ja，above，大于
- jae，above，大于等于
- jg，greater，大于
- jge，greater，大于等于
- jb，below，小于
- jbe，below，小于等于
- jl，less，小于
- jle，less，小于等于
- 详细内容看文档

### loop

loop 循环指令，需要使用 RCX、ECX、CX 来计数。

```
_start:
	mov $10, %cx
loop1:
	mov %cx, %dx
	loop loop1
```

这段代码就相当于 c 语言里这么写。

```
int cx=10;
if cx>0 {
    dx=cx;
    cx--;
}
```

循环结构也可以用 jmp 来实现。
