---
draft: false
date: 2023-07-14 08:00:00 +0800
title: "浮点数（笔记片段）"
summary: "入栈出栈；比较；运算；"
toc: true

categories:
  - assembly-language(汇编语言)

tags:
  - computer-science(计算机科学)
  - programming-language(编程语言)
  - assembly-language(汇编语言)
---

## 前言

这篇笔记需要 x86-64 架构、数据传输、gdb 调试相关的知识

实践的环境：同 [x86-64_架构]()

## 资料

笔记里的代码都在 {demo-assembly}/demo-in-linux/floating/ 目录下

## 正文

### fld、fild

把数据压入 fpu 栈

浮点数用 fld，整数用 fild

每次入栈的时候，栈中的元素会依次上移一个位置，新入栈的元素在 st(0) 的位置

代码示例：{demo-assembly}/demo-in-linux/floating/fld.asm

### fldz、fld1、fldpi

入栈 0.0、入栈 1.0、入栈 pi

### fst、fstp、fist、fistp

把 st(0) 中的数据放到目标操作数上去

浮点数用 fld、fstp，整数用 fist、fistp

fstp、fistp 附带弹栈操作

代码示例：{demo-assembly}/demo-in-linux/floating/fst.asm

### fcom、fcomp、fcomi、fcomip

比较两个操作数。

fcom、fcomp 指令有两种形式

- 无操作数形式，将 st(0) 和 st(1) 进行比较
- 单操作数形式，将源操作数和 st(0) 进行比较

根据比较结果设置 fpu 中的 c0、c2、c3 标志位。一般和 fstsw、sahf 一起用

fcomi、fcomip 进行比较之后，会根据比较结果设置 eflags 中的 zf、pf、cf 标志位

fcomp、fcomip 附带弹栈操作

### fstsw

将 fpu 中的标志位存储到目标操作数

### sahf

用 ah 寄存器的值设置 eflags 中的 sf、zf、af、pf、cf 标志位

### fcomv（fcomvcc）

测试 eflags 的标志位，如果为真，则将源操作数移至目标操作数
源操作数始终是 st(i) 之一，目标操作数始终是 st(0)

### finit

将 fpu 控制、状态、标记、指令指针、数据指针寄存器设置为默认状态
fpu 控制字设置为 037fh（四舍五入，屏蔽所有异常，64 位精度）。状态字清零（未设置异常标志，top 设置为 0）
寄存器堆栈中的数据寄存器保持不变，但全部标记为空（11b）。指令和数据指针都被清空

### fadd、faddp、fiadd

浮点数加法

- 无操作数形式：将 st(0) 加到 st(1)
- 单操作数形式：将源操作数加到 st(0)
- 双操作数形式：将 st(0) 加到 st(i)，或者将 st(i) 加到 st(0)

浮点数用 fadd、faddp；整数用 fiadd；faddp 附带弹栈操作

代码示例：{demo-assembly}/demo-in-linux/floating/fadd.asm

### fsub、fisub、fsubp

浮点数减法

### fimul、fimul、fmulp

浮点数乘法

### fdiv、fidiv、fdivp

浮点数除法

### frndint

根据当前的舍入模式，将 st(0) 舍入为最接近的整数值，结果存入 st(0)

### fabs

对 st(0) 取绝对值

### fchs

把 st(0) 的符号反转

### fsin

计算 st(0) 的正弦近似值，结果存入 st(0)

源操作数的单位必须是弧度，范围是 \[-263, +263\]

### fsqrt

计算 st(0) 的平方根，结果存入 st(0)
