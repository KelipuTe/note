---
draft: false
date: 2023-02-01 08:00:00 +0800
lastmod: 2023-02-01 08:00:00 +0800
title: "并发问题"
summary: "并行和并发；并发问题；并发安全；"
toc: true

categories:
- computer-science(计算机科学)

tags:
- computer-science(计算机科学)
---

### 并行和并发

首先，假设有一个"用手拿起桌子上的杯子"的动作。这个动作的内部被分成了"伸手->抓住杯子->拿起来"这样有先后关系的多个子动作，每一个子动作可以单独被执行。现在，假设有一个人，就叫他慧，他有两个手（如果是触手怪的话就可以有好多手了）。慧的面前有一张桌子，桌子上有两个杯子（多个杯子）。

并行是什么呢，慧的左右手同时做"用手拿起桌子上的杯子"的动作，两个手同时进行，各做各的互不干扰。左手做"伸手"子动作的同时，右手也可以做"伸手"子动作。并行强调，两个或以上的动作，从外面看上去是同时进行的，从内部看，每个时刻可以有多个子动作在进行。

并发是什么呢，慧的左右手同时做"用手拿起桌子上的杯子"的动作，两个手同时进行，但是每次只能完成一个子动作。左手做"伸手"子动作的时候，右手是不能动的。并发强调，两个或以上的动作，从外面看上去是同时进行的，但是从内部看，每个时刻只能有一个子动作在进行。

### 并发问题

#### 用比喻解释

在上面的假设中，假设了两个手和两个杯子。两个手做动作的时候，各自拿一个杯子。这是没有问题的，两个动作都可以独立完成。但是如果假设的时候，是两个手和一个杯子。两个手做动作的时候，拿的是同一个杯子。这就有问题了，两个动作会冲突。

并行场景下，左右手都完成了抓住了杯子子动作，那么左手进行拿起来子动作的时候，右手怎么办。并发场景下，左手完成了拿起来子动作，右手完成了伸手子动作，那么右手进行抓住杯子子动作的时候，抓什么。这个场景中的冲突就是并发问题出现的原因。

#### 用代码解释

用最典型的 `i++` 再来解释一下并发问题。把上面的名词换一下就行了：动作相当于程序代码；子动作相当于 CPU 指令；慧相当于 CPU；杯子相当于临界资源。

`i++` 看上去是一条语句，但是在指令层面，它至少分为三步：1、从变量 i 的内存地址上读取数据；2、对数据做 +1 运算；3、把运算结果放到变量 i 的内存地址上去。

假设 i 是个全局变量，内存地址是 `0x10` 值是 0，现在有两个线程：线程 a 和线程 b 同时执行 `i++`。这里预期的结果应该是 i=2，但是实际执行过程中会发生下面这种情况。

| 时间流逝方向 |      线程 a       |        线程 b        |
|:------:|:---------------:|:------------------:|
|   ↓    |    等待 CPU 调度    |     等待 CPU 调度      |
|   ↓    |   被给予 CPU 资源    |     等待 CPU 调度      |
|   ↓    | 从 0x10 上读取数据（0） |     等待 CPU 调度      |
|   ↓    |   对数据做 +1 运算    |     等待 CPU 调度      |
|   ↓    |   被剥夺 CPU 资源    |     被给予 CPU 资源     |
|   ↓    |    等待 CPU 调度    |  从 0x10 上读取数据（0）   |
|   ↓    |    等待 CPU 调度    |     对数据做 +1 运算     |
|   ↓    |    等待 CPU 调度    | 把运算结果（1）放到 0x10 上去 |
|   ↓    |   被给予 CPU 资源    |   运行结束，归还 CPU 资源   |
|   ↓    | 把运算结果（1）放到 0x10 上去 |         -          |
|   ↓    | 运行结束，归还 CPU 资源  |         -          |

因为线程 a 还没有把运算结果放到 0x10 上去，所以线程 b 从 0x10 上拿到的依然是 0。假设线程 b 没有被剥夺 CPU 资源，完整地跑完了三条指令，那么 i 应该是 1。线程 b 结束运行，归还 CPU 资源。

线程 a 得到 CPU 资源，继续执行。这个时候线程 a 执行的是最后一步，把运算结果（1）放到 0x10 上去。这样就出问题了，实际的结果是 i=1，和期望的结果 i=2 不一致。

所以并发问题一定要从指令层面保证不会出问题，而不是语句层面。

#### 解决方案

并发问题的解决方案的基本思路都是保证临界资源在同一时刻只能被一个对象操作。这个对象可以是多线程环境中的一个线程，分布式系统中的一个客户端（其实也可以认为是线程）。

加锁或者 CAS，都是一样的思路。加锁就是多线程抢同一把锁，CAS 就是多线程抢同一个标志位。只有抢到锁或者标志位的线程，才能操作临界资源。这个时候临界资源就是独享的，就不会出现并发问题。

### 并发安全

不会出现并发问题，那就可以说是并发安全的。
