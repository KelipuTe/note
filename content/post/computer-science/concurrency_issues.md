---
draft: false
date: 2023-02-01 08:00:00 +0800
lastmod: 2023-02-01 08:00:00 +0800
title: "并发问题"
summary: "并行和并发；并发问题；并发安全；"
toc: true

categories:
- computer-science(计算机科学)

tags:
- computer-science(计算机科学)
- concurrent(并发)
---

### 并行和并发

首先，假设有一个"用手拿起桌子上的杯子"的动作。这个动作的内部被分成了"伸手->抓住杯子->拿起来"这样有先后关系的多个子动作，每一个子动作可以单独被执行。现在，假设有一个人，就叫他慧，他有两个手（如果是触手怪的话就可以有好多手了）。慧的面前有一张桌子，桌子上有两个杯子（多个杯子）。

并行是什么呢，慧的左右手同时做"用手拿起桌子上的杯子"的动作，两个手同时进行，各做各的互不干扰。左手做"伸手"子动作的同时，右手也可以做"伸手"子动作。并行强调，两个或以上的动作，从外面看上去是同时进行的，从内部看，每个时刻可以有多个子动作在进行。

并发是什么呢，慧的左右手同时做"用手拿起桌子上的杯子"的动作，两个手同时进行，但是每次只能完成一个子动作。左手做"伸手"子动作的时候，右手是不能动的。并发强调，两个或以上的动作，从外面看上去是同时进行的，但是从内部看，每个时刻只能有一个子动作在进行。

### 并发问题

#### 用比喻解释

在上面的假设中，假设了两个手和两个杯子。两个手做动作的时候，各自拿一个杯子。这是没有问题的，两个动作都可以独立完成。但是如果假设的时候，是两个手和一个杯子。两个手做动作的时候，拿的是同一个杯子。这就有问题了，两个动作会冲突。

并行场景下，左右手都完成了抓住了杯子子动作，那么左手进行拿起来子动作的时候，右手怎么办。并发场景下，左手完成了拿起来子动作，右手完成了伸手子动作，那么右手进行抓住杯子子动作的时候，抓什么。这个场景中的冲突就是并发问题出现的原因。

#### 用代码解释

用最典型的 `i++` 再来解释一下并发问题。把上面的名词换一下就行了：动作相当于程序代码；子动作相当于 CPU 指令；慧相当于 CPU；杯子相当于临界资源。

`i++` 看上去是一条语句，但是在指令层面，它至少分为三步：1、从变量 i 的内存地址上读取数据；2、对数据做 +1 运算；3、把运算结果放到变量 i 的内存地址上去。

假设 i 是个全局变量，内存地址是 `0x10` 值是 0，现在有两个线程：线程 a 和线程 b 同时执行 `i++`。这里预期的结果应该是 i=2，但是实际执行过程中会发生下面这种情况。

| 时间流逝方向 |      线程 a       |        线程 b        |
|:------:|:---------------:|:------------------:|
|   ↓    |    等待 CPU 调度    |     等待 CPU 调度      |
|   ↓    |   被给予 CPU 资源    |     等待 CPU 调度      |
|   ↓    | 从 0x10 上读取数据（0） |     等待 CPU 调度      |
|   ↓    |   对数据做 +1 运算    |     等待 CPU 调度      |
|   ↓    |   被剥夺 CPU 资源    |     被给予 CPU 资源     |
|   ↓    |    等待 CPU 调度    |  从 0x10 上读取数据（0）   |
|   ↓    |    等待 CPU 调度    |     对数据做 +1 运算     |
|   ↓    |    等待 CPU 调度    | 把运算结果（1）放到 0x10 上去 |
|   ↓    |   被给予 CPU 资源    |   运行结束，归还 CPU 资源   |
|   ↓    | 把运算结果（1）放到 0x10 上去 |         -          |
|   ↓    | 运行结束，归还 CPU 资源  |         -          |

因为线程 a 还没有把运算结果放到 0x10 上去，所以线程 b 从 0x10 上拿到的依然是 0。假设线程 b 没有被剥夺 CPU 资源，完整地跑完了三条指令，那么 i 应该是 1。线程 b 结束运行，归还 CPU 资源。

线程 a 得到 CPU 资源，继续执行。这个时候线程 a 执行的是最后一步，把运算结果（1）放到 0x10 上去。这样就出问题了，实际的结果是 i=1，和期望的结果 i=2 不一致。

所以并发问题一定要从指令层面保证不会出问题，而不是语句层面。

#### 解决方案

并发问题的解决方案的基本思路都是保证临界资源在同一时刻只能被一个对象操作。这个对象可以是多线程环境中的一个线程，分布式系统中的一个客户端（其实也可以认为是线程）。

加锁或者 CAS，都是一样的思路。加锁就是多线程抢同一把锁，CAS 就是多线程抢同一个标志位。只有抢到锁或者标志位的线程，才能操作临界资源。这个时候临界资源就相当于是独享的，就不会出现并发问题。

#### 锁机制

常用的锁机制有两种：悲观锁、乐观锁。

悲观锁假定会发生并发冲突，在操作数据之前，需要保证只有自己能操作数据。如果有其他想要操作数据的，它们会被挡住。悲观锁大多依靠底层提供的锁机制。

乐观锁假定不会发生并发冲突，先假定只有自己在操作数据，需要提交的时候，再检查是不是真的只有自己在操作数据。如果有其他在操作数据的，自己会被挡住。乐观锁大多是基于数据版本记录机制实现。

#### CAS

CAS（Compare And Swap）操作是原子操作，包含三个操作数：内存中的值（内存位置 V）、原值（预期原值 A）、新值（新值 B）。如果内存中的值与原值相等，那么处理器会将内存中的值更新为新值。如果内存中的值与原值不相等，处理器不做任何操作。

#### 锁和 CAS+自旋

单纯地看一次操作的效率的话，CAS 的效率肯定是比锁高的。但是并发场景中，不能只看一次操作的效率，而是要看整体操作的效率。

如果并发量很少，也就是冲突不明显的时候。比如锁和 CAS 都是一次就成功。那么整体的效率，CAS 是比锁要高的。

如果并发量很大，也就是冲突明显的时候。锁一次不成功，就会阻塞，然后进入通知队列等着被唤醒了，CPU 就可以空出来干别的事情。但是 CAS 一次不成功，会不停的重试，直到成功。

这个时候问题就来了，假设并发数量是 10000，那么 1 个成功了，那么剩下来的 9999 个，一定是不可能成功的。但是它们依然在不停的重试，一直消耗 CPU 的资源。

### 并发安全

不会出现并发问题，那就可以说是并发安全的。
