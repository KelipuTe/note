<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<search>
  
  <entry>
    <title>如何使用档案馆</title>
    <url>/post/how_to_use/</url>
    <categories>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[前言 再次强调：
帕里特档案馆（重建中，旧篇总计 283，迁移完成 4，新增 8），是个个人档案馆。内容主要是学习笔记和实操过程的记录。
本人能力有限，因此不能保证所有的内容的时效性和正确性。还请各位到访的有缘人务必小心。
本人能力有限，因此不能保证所有的内容的时效性和正确性。还请各位到访的有缘人务必小心。
本人能力有限，因此不能保证所有的内容的时效性和正确性。还请各位到访的有缘人务必小心。
如何使用档案馆 档案馆的内容分为三个部分：
文本 代码，借助 github 图，借助 draw.io 如果文本使用到了代码或者图片，通常在文本的最前面会有一个标题为 资料 的部分。
如果是类似 {xxx}/aaa/bbb/ 这种格式的，就是 github 的项目的代码，需要去 github 上查看。 如果是类似 xxx.drawio.html 这种格式的，就是 draw.io 生成的 html，直接打开就可以预览。 参考到的外部资料通常在文本的最后面会有一个标题为 reference（参考） 的部分。
]]></content>
  </entry>
  
  <entry>
    <title>软件架构评估</title>
    <url>/post/computer-science/software-architecture/architecture_evaluation/</url>
    <categories><category>software-architecture(软件架构)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>software-architecture(软件架构)</tag>
    </tags>
    <content type="html"><![CDATA[架构权衡分析方法 Architecture Tradeoff Analysis Method（ATAM，架构权衡分析方法）
]]></content>
  </entry>
  
  <entry>
    <title>使用 Golang 实现 Web 框架 -- 复杂的 web 框架</title>
    <url>/post/computer-science/programming-language/golang/web/web_v40/</url>
    <categories><category>golang</category>
    </categories>
    <tags>
      <tag>golang</tag>
      <tag>web</tag>
      <tag>http</tag>
      <tag>router(路由)</tag>
      <tag>middleware(中间件)</tag>
    </tags>
    <content type="html"><![CDATA[ go version go1.19
前言 在看这篇之前，建议先看下面这几篇：
使用 Golang 开启 HTTP 服务 使用 Golang 实现 Web 框架 &ndash; router(路由) 使用 Golang 实现 Web 框架 &ndash; middleware(中间件) 路由树和中间件是 web 框架的核心。其他的功能，都是在这两个核心的基础上，再增加亿点点细节而已。
资料 {web-framework-go}/v40 实现功能 主要实现： 路由树（静态、通配符、路径参数、正则表达式）、路由组 全局中间件、可路由的中间件 次要实现： 内存池（请求上下文对象复用） 服务管理（管理多个子服务） 优雅退出、退出时的回调方法 计划实现： 用户认证（中间件实现） 文件操作（上传、下载） 单元测试、集成测试、性能测试 设计文档 路由树 首先是路由树结点的设计。结点的基础数据包括：结点类型、这个路由结点代表的那段路径、命中路由之后的的处理逻辑。
静态路由子结点使用 map 结构存储，查询时直接就可以通过路由段查询子结点。
通配符子结点、路径参数子结点、正则表达式子结点，这三个结点属于特殊结点，而且存在冲突关系，所以单独存储。
为了支持可路由的中间件，路由结点上还需要有存储中间件的地方，这样就可以为每个结点单独设置中间件。
另外，服务在运行的时候只要命中的是同一个路由，那么用到的中间件一定也是相同的，在服务启动的时候就可以把中间件遍历好，然后缓存下来。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // routingNode 路由结点 type routingNode struct { // nodeType 结点类型 nodeType int // part 这个路由结点代表的那段路径 part string // path 从根路由到这个路由结点的全路径 path string // f4handler 命中路由之后的处理逻辑 f4handler HTTPHandleFunc // m3routingTree 路由子树，子结点的 path =&gt; 子树根结点 m3routingTree map[string]*routingNode // p7paramChild 路径参数结点 p7paramChild *routingNode // paramName 路径参数路由和正则表达式路由，都会提取路由参数的名字 paramName string // p7regexpChild 正则表达式结点 p7regexpChild *routingNode // p7regexp 正则表达式 p7regexp *regexp.Regexp // p7anyChild 通配符结点 p7anyChild *routingNode // s5f4middleware 结点上注册的中间件 s5f4middleware []HTTPMiddleware // s5f4middlewareCache 服务启动后，命中结点时，需要用到的所有中间件 s5f4middlewareCache []HTTPMiddleware } 路由树的构造和遍历并不复杂，使用递归逻辑处理即可。不用担心递归带来的性能问题。
对于路由树的递归操作，都发生在服务启动时，这个时候会遍历路由树然后将结果缓存下来。
服务启动后，当请求访问过来时，就可以直接使用缓存里的结果，而不用每次都去遍历路由树。
路由组 路由组就是个语法糖。相当于路由组方法会在路由组内的每个成员注册的时候，附加路由组的路由前缀和路由组定义的中间件。
1 2 3 4 5 6 7 8 9 10 // Group 添加一组路由 func (p7this *HTTPHandler) Group(path string, s5f4mw []HTTPMiddleware, s5routeData []RouteData) { for _, rd := range s5routeData { t4path := path if &#34;/&#34; != rd.Path { t4path = path + rd.Path } p7this.addRoute(rd.Method, t4path, rd.F4handle, s5f4mw...) } } 中间件 全局中间件和可路由中间件是分开放的。全局中间件存储在核心处理逻辑上。可路由中间件存储在路由树结点上。
1 2 3 4 5 6 7 8 9 10 11 12 13 // HTTPHandlerInterface 核心处理逻辑的接口定义 type HTTPHandlerInterface interface { http.Handler ... } // HTTPHandler 核心处理逻辑 type HTTPHandler struct { ... // s5f4middleware 全局中间件 s5f4middleware []HTTPMiddleware ... } 当请求访问过来时，第一站到的是核心处理逻辑，核心处理逻辑会完成全局中间件的组装和执行。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 func (p7this *HTTPHandler) ServeHTTP(i9w http.ResponseWriter, p7r *http.Request) { ... // 倒过来组装，先组装的在里层，里层的后执行 // 最里层应该是找路由然后执行业务代码 t4chain := p7this.doServeHTTP for i := len(p7this.s5f4middleware) - 1; i &gt;= 0; i-- { t4chain = p7this.s5f4middleware[i](t4chain) } // 写入响应数据这个中间件应该由框架开发者处理 // 它是最后一个环节，应该在最外层 t4m := FlashRespMiddleware() t4chain = t4m(t4chain) t4chain(p7ctx) } 在通过全局中间件之后，进入查询路由树的步骤。查询结果里会有路由树结点上的可路由中间件。
使用和全局中间件一样的套路，完成一遍可路由中间件的组装和执行。最后调用路由上的处理逻辑，开始真正的业务逻辑。
1 2 3 4 5 6 7 8 9 10 11 func (p7this *HTTPHandler) doServeHTTP(p7ctx *HTTPContext) { ... p7ri := p7this.findRoute(p7ctx.P7request.Method, p7ctx.P7request.URL.Path) ... // 这里用同样的套路，处理路由上的中间件，最后执行业务代码 t4chain := p7ri.p7node.f4handler for i := len(p7ri.p7node.s5f4middlewareCache) - 1; i &gt;= 0; i-- { t4chain = p7ri.p7node.s5f4middlewareCache[i](t4chain) } t4chain(p7ctx) } 优雅退出 想实现优雅退出，程序就不能阻塞在不可控的位置。这里可以直接把服务丢到协程里去。
然后在最外面，实现一个信号等待的逻辑，这样就可以通过信号控制程序的运行状态。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func (p7this *ServiceManager) Start() { // 启动服务 log.Println(&#34;服务启动中。。。&#34;) for _, p7s := range p7this.s5p7HTTPService { t4p7s := p7s go func() { if err := t4p7s.Start(); nil != err { if http.ErrServerClosed == err { log.Printf(&#34;子服务 %s 已关闭\n&#34;, t4p7s.name) } else { log.Printf(&#34;子服务 %s 异常退出，err:%s\r\n&#34;, t4p7s.name, err) } } }() } log.Println(&#34;服务启动完成。&#34;) // 监听 ctrl+c 信号 c4signal := make(chan os.Signal, 2) signal.Notify(c4signal, os.Interrupt) select { case &lt;-c4signal: ... } } 在可以主动介入程序运行之后，就可以设计主动拒绝新请求的逻辑了。这样可以实现服务不完全停止的情况下，拒绝对外服务
因为服务停止不仅仅是不对外服务这么简单，在服务真正的停止之前，还有很多善后的工作需要做。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // HTTPHandler 核心处理逻辑 type HTTPHandler struct { ... // isRunning 服务是否正在运行 isRunning bool } func (p7this *HTTPHandler) doServeHTTP(p7ctx *HTTPContext) { // 如果服务已经关闭了就直接返回 if !p7this.isRunning { p7ctx.I9writer.WriteHeader(http.StatusInternalServerError) _, _ = p7ctx.I9writer.Write([]byte(&#34;服务已关闭&#34;)) return } ... } 虽然服务停止前有很多善后的工作需要做，但是理论上不会持续很久。
为了防止意外卡死的情况出现，可以再加一层超时强制停止的逻辑。必要的时候，也可以设计主动强制关闭的入口。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func (p7this *ServiceManager) Start() { ... // 监听 ctrl+c 信号 c4signal := make(chan os.Signal, 2) signal.Notify(c4signal, os.Interrupt) select { case &lt;-c4signal: log.Printf(&#34;接收到关闭信号，开始关闭服务，限制 %d 秒内完成。。。\r\n&#34;, p7this.shutdownTimeOut/time.Second) // 再次监听 ctrl+c 信号 go func() { select { case &lt;-c4signal: log.Println(&#34;再次接收到关闭信号，服务直接退出。&#34;) os.Exit(1) } }() time.AfterFunc(p7this.shutdownTimeOut, func() { log.Println(&#34;优雅关闭超时，服务直接退出。&#34;) os.Exit(1) }) p7this.Shutdown() } } 在拒绝新请求之后，由于有可能还有旧的请求没有处理完，所以是不能立刻就关闭服务的，需要等待一段时间。
1 2 3 4 5 6 7 8 9 10 11 func (p7this *ServiceManager) Shutdown() { ... log.Println(&#34;停止接收新请求。&#34;) for _, p7hs := range p7this.s5p7HTTPService { p7hs.Stop() } log.Printf(&#34;等待正在执行的请求结束，等待 %d 秒。。。&#34;, p7this.shutdownWaitTime/time.Second) time.Sleep(p7this.shutdownWaitTime) ... } 服务正式关闭服务之后，可能还有一些收尾的工作需要处理，然后才能彻底退出程序。
比如：系统里如果有缓存的话，可能需要把缓存进行持久化处理；系统关闭时，需要上报数据其他服务等。
这个可以通过回调实现，和中间件的用法类似。不过最后执行的时候，是所有的回调是并发执行的，而不是像中间件一样套起来，一次执行的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func (p7this *ServiceManager) Shutdown() { ... log.Println(&#34;开始执行子服务的关闭回调。。。&#34;) for _, p7hs := range p7this.s5p7HTTPService { log.Printf(&#34;执行子服务 %s 的关闭回调，限制 %d 秒内完成。。。&#34;, p7hs.name, p7this.shutdownCallbackTimeOut/time.Second) for _, f4cb := range p7hs.s5f4shutdownCallback { t4f4cb := f4cb wg.Add(1) go func() { defer wg.Done() t4ctx, t4cancel := context.WithTimeout(context.Background(), p7this.shutdownCallbackTimeOut) defer t4cancel() t4f4cb(t4ctx) }() } } wg.Wait() ... } 到这里核心的部分就差不多了，细节上的实现可以看代码。
]]></content>
  </entry>
  
  <entry>
    <title>使用 Hugo 和 GitHub Pages 搭建站点</title>
    <url>/post/computer-science/application/hugo/hugo-start/</url>
    <categories><category>application(应用)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>Hugo</tag>
      <tag>GitHub Pages</tag>
    </tags>
    <content type="html"><![CDATA[ Windows 11 家庭版 cpu amd64 hugo 0.103.1 Hugo 文档 gohugoio/hugo英文文档中文文档安装 Hugo 在 Hugo Releases页面下载对应操作系统的版本。这里下载的是 hugo_0.103.1_windows-amd64.zip。
下载完成后，解压到想要的位置。这里使用的目录是 D:\hugo\bin。然后将这个目录添加到 系统变量 path 中（我的电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; path）。
搞定之后，可以打开控制台，输出一下版本信息，验证一下安装是否成功。或者试试 hugo help 命令，看看能不能输出帮助信息。
1 2 &gt; hugo version hugo v0.103.1-b665f1e8f16bf043b9d3c087a60866159d71b48d windows/amd64 BuildDate=2022-09-18T13:19:01Z VendorInfo=gohugoio 如果有需要的话，需要安装 extended 版本的。这里下载的是 hugo_extended_0.103.1_windows-amd64.zip。
1 2 &gt; hugo version hugo v0.103.1-b665f1e8f16bf043b9d3c087a60866159d71b48d+extended windows/amd64 BuildDate=2022-09-18T13:19:01Z VendorInfo=gohugoio 创建站点 使用命令创建一个站点，如果没问题的话，hugo 会在当前目录下创建一个名字是 project-name 的目录。
1 &gt; hugo new site {project-name} 新建的站点没有任何内容，可以使用命令创建一个内容页面。新创建的文件会在目录 content/ 里。创建内容页面的时候也可以带上目录。
1 2 &gt; hugo new helloworld.md &gt; hugo new posts/helloworld.md 安装主题 这里就是和别的站点工具不一样的地方了，比如 hexo 和 jekyll，如果没有安装主题的话，是会有一个默认的主题的。
但是 hugo 没有默认主题，需要去主题库下载一个，然后添加到站点里并配置好，这样才能启动站点。如果没有安装主题就启动的话，会报没有模板的错误。
可以去 官方的主题库找一个喜欢的。然后按照主题提供的文档配置一下。
Hugo NexT Hugo NexT这个主题是从 Hexo NexT 移植过来的。
GitHub 项目地址 hugo-next/hugo-theme-next。
按着 Hexo NexT 主题提供的的文档走，把主题配置到站点中。
别忘了先 git init，然后使用命令下载主题 git submodule add https://github.com/hugo-next/hugo-theme-next.git themes/hugo-theme-next。
如果需要升级主题的话，就进入 {path-to-project}/themes/github-style 目录，执行 git pull 命令，拉取最新的代码。
然后把 {path-to-project}themes/hugo-theme-next/exampleSite/ 目录下所有的文件复制到 {path-to-project}/ 目录下覆盖。
最后删除原来的配置文件 config.toml，然后就可以使用命令 hugo server 启动服务了。
另外需要注意的是，这个主题需要 hugo extended 版本，如果用的不是 extended 版本，启动的时候会报下面这样的错，提示去安装 extended 版本。
1 2 3 4 5 6 &gt; hugo server Start building sites … hugo v0.103.1-b665f1e8f16bf043b9d3c087a60866159d71b48d windows/amd64 BuildDate=2022-09-18T13:19:01Z VendorInfo=gohugoio WARN 2022/09/20 21:12:38 Hugo NexT 主题使用了 SCSS 框架，请到官方地址下载 Hugo Extended 版本：https://github.com/gohugoio/hugo/releases ERROR 2022/09/20 21:12:38 Because that use SCSS framework in Hugo NexT, Please download Hugo extended version on offical site: https://github.com/gohugoio/hugo/releases Error: Error building site: TOCSS: failed to transform &#34;main.scss&#34; (text/x-scss). Check your Hugo installation; you need the extended version to build SCSS/SASS.: this feature is not available in your current Hugo version, see https://goo.gl/YMrWcn for more information github-style（选看） github-style这个主题是 github 的页面风格。
GitHub 项目地址 MeiK2333/github-style。
按着 github-style 主题提供的的文档走，把主题配置到站点中。
别忘了先 git init，然后使用命令下载主题 git submodule add git@github.com:MeiK2333/github-style.git themes/github-style。
如果需要升级主题的话，就进入 {path-to-project}/themes/github-style 目录，执行 git pull 命令，拉取最新的代码。
在 content/ 里创建 post/ 目录，后面所有的内容页面都放到这个目录下面，要不然站点里不会展示。
最后在配置文件 config.toml 里设置主题 theme = &quot;github-style&quot;。然后就可以使用命令 hugo server 启动服务了。
站点是没有问题的，可以正常地跑起来。但是这个主题貌似没有实现标签分类，也可能是本人没有找到，所以就放弃继续使用了。
部署到 GitHub Pages 使用命令 hugo -t {theme-name} 来把发布用的目录编译出来。这里就是 hugo -t hugo-theme-next。
默认情况下会编译到 {path-to-project}/publish/ 目录。 可以通过编辑配置文件，在配置文件里添加 publishDir: docs，来修改这个目录。
push 到 github.io 的时候，如果使用的是 publish/ 目录。那么要 push publish/ 目录上去，然后设置 GitHub Pages 的 Branch 为 master 和 /(root)。
如果使用的是 docs/ 目录，那么就要 push 整个项目上去，然后设置 GitHub Pages 的 Branch 为 master 和 docs/。
reference（参考） hugo个人博客搭建并部署到GitHub【 for Windows】]]></content>
  </entry>
  
  <entry>
    <title>使用 Golang 实现 Web 框架 -- middleware(中间件)</title>
    <url>/post/computer-science/programming-language/golang/web/middleware/</url>
    <categories><category>golang</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>golang</tag>
      <tag>web</tag>
      <tag>http</tag>
      <tag>middleware(中间件)</tag>
    </tags>
    <content type="html"><![CDATA[ go version go1.19
资料 {demo-golang}/demo/web/middleware/ web.drawio.html 中间件 web 框架的中间件可以理解成一种 aop 方案的实现。
可以借助洋葱模型、责任链设计模式、链式调用的概念来理解中间件的整体结构。
中间件的结构示例见图：web.drawio.html 4-2。
定义中间件的时候需要关注两个重要的组成部分：路由的对应的处理方法和中间件的处理方法。
这两个部分定义一起规定了中间件该怎么定义，中间件定义需要围绕这两个定义去实现，要不然调用链条串不起来。
1 2 // HTTPHandleFunc 路由对应的处理方法的定义 type HTTPHandleFunc func(p7ctx *HTTPContext) 1 2 // HTTPMiddleware 中间件的处理方法的定义 type HTTPMiddleware func(next HTTPHandleFunc) HTTPHandleFunc 具体的中间件的实现方式，就像下面这样。
1 2 3 4 5 6 7 8 9 func DemoMiddleware() HTTPMiddleware { return func(next HTTPHandleFunc) HTTPHandleFunc { return func(p7ctx *HTTPContext) { // before DemoMiddleware next(p7ctx) // after DemoMiddleware } } } 假设定义两个中间件。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func AMiddleware() HTTPMiddleware { return func(next HTTPHandleFunc) HTTPHandleFunc { return func(p7ctx *HTTPContext) { // before AMiddleware next(p7ctx) // after AMiddleware } } } func BMiddleware() HTTPMiddleware { return func(next HTTPHandleFunc) HTTPHandleFunc { return func(p7ctx *HTTPContext) { // before BMiddleware next(p7ctx) // after BMiddleware } } } 然后这么链起来，B 在内层，A 在外层。
1 2 3 4 5 6 7 8 9 // serve 是最内层业务代码 chain := serve // 组装中间件 mb := BMiddleware() chain = mb(chain) ma := AMiddleware() chain = mb(chain) // 执行 chain(ctx) 最后的效果等价于下面这样的伪代码。
1 2 3 4 5 // before AMiddleware // before BMiddleware serve(p7ctx) // after BMiddleware // after AMiddleware 可路由的中间件 可路由的中间件就是在路由树的基础上，分别给每个路由树结点设置中间件。
这样在路由匹配到某个路由结点之后，不仅可以获取到路由的处理方法，还可以获取到路由上设置的中间件。
然后把这些中间件，按照定义好的顺序，套起来即可。
]]></content>
  </entry>
  
  <entry>
    <title>使用 Golang 实现 Web 框架 -- router(路由)</title>
    <url>/post/computer-science/programming-language/golang/web/router/</url>
    <categories><category>golang</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>golang</tag>
      <tag>web</tag>
      <tag>http</tag>
      <tag>router(路由)</tag>
    </tags>
    <content type="html"><![CDATA[ go version go1.19
资料 {demo-golang}/demo/web/router/ web.drawio.html 路由 路由的作用是通过请求的路径找到对应的处理方法。
简单的路由可以使用 map 结构，就是单纯的字符串匹配。map 的 key 就是路由的路径，value 就是路由的处理方法。
接收到请求时，用请求的路径直接去 map 里找有没有对应的处理方法。但是这种结构无法满足路径参数路由、正则匹配路由、通配符路由这样的需求。
这些需求需要使用到路由树结构，路由树的结点在存储静态子结点的同时，还可以额外设置特殊子结点。在找不到静态路由时，可以继续判断有没有特殊结点可以选择。
路由树的结构示例见图：web.drawio.html 2-2。
路由树的设计没有强制的要求，按照实际场景的需求，合理的设计路由树的构建和查询规则即可。
路由组 路由组其实就是额外提供的方便使用的接口而已，相当于对路由的注册功能做了一层包装。
路由组的内部，会把定义到路由组上的路由路径前缀和中间件，附加到路由组内的每一个路由上去。
]]></content>
  </entry>
  
  <entry>
    <title>关于帕里特档案馆和西柊慧音</title>
    <url>/about/</url>
    <categories>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[帕里特档案馆（重建中，旧篇总计 283，迁移完成 4，新增 8），是个个人档案馆。内容主要是学习笔记和实操过程的记录。
本人能力有限，因此不能保证所有的内容的时效性和正确性。还请各位到访的有缘人务必小心。
站点基于 hugo 0.103.1 extended 版本搭建。使用的主题是 Hugo NexT。
站点预计会部属在 github pages 和 gitee pages 上。
如果有问题，欢迎批评指正。同时也欢迎建设性意见。
本人的联系方式，QQ：786907650；微信号：wxid_k3uqy9xeryn422。
有意交流者，请至少备注是谁和从哪来。
]]></content>
  </entry>
  
  <entry>
    <title>Golang 泛型的基本使用方式</title>
    <url>/post/computer-science/programming-language/golang/genericity/</url>
    <categories><category>golang</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>golang</tag>
      <tag>genericity</tag>
    </tags>
    <content type="html"><![CDATA[资料 {demo-golang}/demo/genericity/ reference（参考） Go 泛型十年磨一剑 go 1.18泛型]]></content>
  </entry>
  
  <entry>
    <title>使用 Golang 开启 HTTP 服务</title>
    <url>/post/computer-science/programming-language/golang/web/http/</url>
    <categories><category>golang</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>golang</tag>
      <tag>web</tag>
      <tag>http</tag>
    </tags>
    <content type="html"><![CDATA[ go version go1.19
资料 {demo-golang}/demo/web/http/ 开启 HTTP 服务 在 Go 中有多种方式，可以开启 HTTP 服务。但是总的来说基本就下面两大类思路（本质上其实是一类）。
使用官方提供的封装好的 net/http 包。 直接使用 net 包从 TCP 开始自行实现。 使用 net/http 包的时候，需要关注的最核心的部分，就是 Handler 接口 (src/net/http/server.go)。
1 2 3 type Handler interface { ServeHTTP(ResponseWriter, *Request) } 开启 HTTP 服务和 HTTP 请求被处理的流程大致如下：
直接或间接地创建 Server 结构体 (src/net/http/server.go) 的实例。 调用 Server 的 ListenAndServe() 方法。 ListenAndServe() 调用 net.Listen() (src/net/dial.go)，启动 TCP 服务。 net.Listen() 返回一个 net.Listener 接口 (src/net/dial.go) 的实例。 调用 net.Listener 的 Accept() 方法，就可以获取连接上来的 TCP 连接。 新开启一个协程，把这个 TCP 连接丢进去处理。自己则继续监听有没有别的 TCP 连接。 处理流程继续往下，会遇到这行代码：serverHandler{c.server}.ServeHTTP(w, w.req)。 这里调用的就是 Handler 的 ServeHTTP() 方法。再往下就进入框架或者业务处理流程了。 ]]></content>
  </entry>
  
  <entry>
    <title>2-3-4 树</title>
    <url>/post/computer-science/data-structure/2-3-4_tree/</url>
    <categories><category>data-structure(数据结构)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>data-structure(数据结构)</tag>
      <tag>b-tree</tag>
    </tags>
    <content type="html"><![CDATA[前言 在看 2-3-4 树之前，建议先看 2-3 树。相似的操作在 2-3-4 树不会重复详细的描述。
资料 2-3-4_tree.drawio.html 2-3-4 树 2-3-4 树就是 4 阶 B-树 2-3-4 树和红黑树是等价的： 2-3-4 树的结点个数 = 红黑树的黑色结点个数。 把 2-3-4 树的三结点和四结点拆开，就可以变成红黑树。 把红黑树的红结点移动到和父结点同层，就会变成 2-3-4 树。 2-3-4 树的性质 1、满足二叉查找树的基本性质。
2、结点可以存放一个元素、两个元素。
假设结点结构从左到右分别为：子树 1、元素 1、子树 2、元素 2、子树 3、元素 3、子树 4。 对于存放一个元素的结点。其形态为：子树 1、元素 1、子树 2。 子树 1 存放比 元素 1 小的元素； 子树 2 存放比 元素 1 大的元素。 对于存放两个元素的结点，其形态为：子树 1、元素 1、子树 2、元素 2、子树 3。 子树 1 存放比 元素 1 和 元素 2 都小的元素； 子树 2 存放在 元素 1 和 元素 2 之间的元素； 子树 3 存放比 元素 1 和 元素 2 都大的元素。 对于存放三个元素的结点，其形态为：子树 1、元素 1、子树 2、元素 2、子树 3、元素 3、子树 4。 子树 1 存放比 元素 1、元素 2、元素 3 都小的元素； 子树 2 存放在 元素 1 和 元素 2 之间的元素； 子树 3 存放在 元素 2 和 元素 3 之间的元素； 子树 4 存放比 元素 1、元素 2、元素 3 都大的元素。 3、2-3-4 树是绝对平衡的二叉查找树，所有叶子结点都在同一层上。从根结点到任意一个叶子结点所经过的结点数是相同的。
2-3-4 树的插入 下面列举的情况并不一定覆盖所有的场景，但是典型场景都有了，没有提到的场景可以根据典型场景推导。
只上溢不旋转的情况 1、空树。（类似 2-3 树的第 1 种情况）
2、二结点。（类似 2-3 树的第 2 种情况）
3、三结点。
添加结点 =&gt; 变四结点。（见图：2-3-4_tree.drawio.html 2-2-6）
4、没有父结点的四结点。
添加结点 =&gt; 变五结点 =&gt; 上溢（层数增加）。（见图：2-3-4_tree.drawio.html 2-4-2）
5、有父结点的四结点（父结点不是四结点）。
添加结点 =&gt; 变五结点 =&gt; 上溢（层数不增加）。（见图：2-3-4_tree.drawio.html 2-4-4）
这种情况，四结点是父结点哪个子结点，都是一样的处理逻辑，上溢一次。
这里，父结点可以是二结点也可以是三结点。
6、有父结点的四结点（父结点是四结点）。
添加结点 =&gt; 变五结点 =&gt; 上溢（父结点变五结点）=&gt; 父结点上溢（层数增加）。（见图：2-3-4_tree.drawio.html 2-6）
这种情况，四结点是父结点哪个子结点，都是一样的处理逻辑，上溢两次。
可以通过旋转抵消上溢的情况 1、有父结点的四结点（父结点是四结点、兄弟结点不是四结点）。
添加结点 =&gt; 变五结点 =&gt; 兄弟结点有空位 =&gt; 旋转结点到兄弟结点（抵消上溢，层数不增加）。
这种情况，如果只上溢的话，会上溢两次（自己上溢一次、父结点上溢一次），树的深度增加了，可能影响查询效率。
但是这个时候其实 2-3-4 树是不满的，兄弟结点是有空位的。这时候就可以通过旋转，重新平衡 2-3-4 树。
根据 2-3-4 树有空位的兄弟结点的位置，旋转的情况分为六种，处理方式是差不多的：
向右旋转一次（见图：2-3-4_tree.drawio.html 4-2-2） 向左旋转一次（见图：2-3-4_tree.drawio.html 4-2-4） 向右旋转两次（见图：2-3-4_tree.drawio.html 4-6） 向左旋转两次（无图，参考向右旋转两次的图）。 向右旋转三次（无图，参考向右旋转两次的图）。 向左旋转三次（无图，参考向右旋转两次的图）。 2、有父结点的四结点（父结点是四结点、兄弟结点是四结点、祖父结点是四结点、叔叔结点不是四结点）。
添加结点 =&gt; 变五结点 =&gt; 父结点和兄弟结点都没有空位，无法旋转，只能上溢（父结点变五结点） =&gt; 叔叔结点有空位 =&gt; 旋转结点到叔叔结点（抵消上溢，层数不增加）。
这种情况，如果只上溢的话，会上溢三次（自己上溢一次、父结点上溢一次、祖父结点上溢一次），树的深度增加了，可能影响查询效率。
但是这个时候其实 2-3-4 树是不满的，叔叔结点是有空位的。这时候就可以通过旋转，重新平衡 2-3-4 树。
这里第一次的上溢是避免不了的。上溢之后，重新以父结点为参照，这时就可以看做上面第一种情况。
根据 2-3-4 树有空位的叔叔结点的位置，旋转的情况分为六种，处理方式是差不多的：
（上溢一次后）向右旋转一次（无图，参考向右旋转三次的图）。 （上溢一次后）向左旋转一次（无图，参考向右旋转三次的图）。 （上溢一次后）向右旋转两次（无图，参考向右旋转三次的图）。 （上溢一次后）向左旋转两次（无图，参考向右旋转三次的图）。 （上溢一次后）向右旋转三次（见图：2-3-4_tree.drawio.html 4-8） （上溢一次后）向左旋转三次（无图，参考向右旋转三次的图）。 2-3-4 树的删除 下面列举的情况并不一定覆盖所有的场景，但是典型场景都有了，没有提到的场景可以根据典型场景推导。
删除叶子结点 1、删除三结点的结点。（类似 2-3 树的第 1 种情况）
2、删除四结点的结点。
直接删掉就好了，不会破坏 2-3-4 树的性质。（见图：2-3-4_tree.drawio.html 6-2-4）
3、删除二结点的结点（父结点是二结点、兄弟结点是二结点）。（类似 2-3 树的第 2 种情况）
4、删除二结点的结点（父结点是三结点、兄弟结点是二结点）。（类似 2-3 树的第 3 种情况）
5、删除二结点的结点（父结点是四结点，兄弟结点是二结点）。（类似第 3 种情况）
删除结点 =&gt; 父结点少一个子树 =&gt; 父结点下溢（其中一个结点，层次不变） =&gt; 下溢结点和兄弟结点融合。（见图：2-3-4_tree.drawio.html 6-4-6）
6、删除二结点的结点（父结点是二结点、兄弟结点是三结点）。（类似 2-3 树的第 4 种情况）
7、删除二结点的结点（父结点是三结点、兄弟结点是三结点）。（类似 2-3 树的第 5 种情况）
8、删除二结点的结点（父结点是四结点、兄弟结点是三结点）。（类似第 6 种情况）
删除结点 =&gt; 父结点少一个子树 =&gt; 兄弟结点可以借一个结点 =&gt; 旋转结点到删除结点的位置。（见图：2-3-4_tree.drawio.html 6-6-6）
另外，还有向左旋转三次的情况（见图：2-3-4_tree.drawio.html 6-10-4），向右旋转三次的处理方式是一样的。
9、删除二结点的结点（父结点是二结点、兄弟结点是四结点）。
删除结点 =&gt; 父结点少一个子树 =&gt; 兄弟结点可以借一个结点 =&gt; 旋转结点到删除结点的位置。（见图：2-3-4_tree.drawio.html 6-8-2）
这种情况，删掉结点之后，自己这个位置就是空的了。也就是父结点变得少一个子树，这会破坏 2-3-4 树的性质。
和上面第 3 种情况不同的是，在第 3 种情况中，兄弟结点是二结点，借不出结点。而这里可以借一个结点过来，把这个子树补上，这样就不破坏 2-3-4 树的性质了。
图里的例子是向左旋转一次的情况，向右旋转一次的处理方式是一样的。
10、删除二结点的结点（父结点是三结点、兄弟结点是四结点）。（类似第 9 种情况）
删除结点 =&gt; 父结点少一个子树 =&gt; 兄弟结点可以借一个结点 =&gt; 旋转结点到删除结点的位置。（见图：2-3-4_tree.drawio.html 6-8-4）
11、删除二结点的结点（父结点是四结点、兄弟结点是四结点）。（类似第 9 种情况）
删除结点 =&gt; 父结点少一个子树 =&gt; 兄弟结点可以借一个结点 =&gt; 旋转结点到删除结点的位置。（见图：2-3-4_tree.drawio.html 6-8-6）
12、删除二结点的结点（父结点是二结点、兄弟结点是二结点、祖父结点是二结点、叔叔结点是二结点）。（类似 2-3 树的第 6 种情况）
13、删除二结点的结点（父结点是二结点、兄弟结点是二结点、祖父结点是三结点、叔叔结点是二结点）。（类似 2-3 树的第 7 种情况）
祖父结点是四结点的处理逻辑是一样的。
14、删除二结点的结点（父结点是二结点、兄弟结点是二结点、祖父结点是三结点、叔叔结点是三结点）。（类似 2-3 树的第 8 种情况）
叔叔结点是四结点的处理逻辑是一样的。
删除的不是叶子结点 这种情况需和平衡二叉树一样，找到中序遍历的前驱结点或者后继结点，把这两个结点互换位置，这个时候要删除的结点会被换到叶子结点的位置，然后再删除。
2-3-4 树转换成红黑树 1、三结点其中一个元素转化为红黑树的红结点，左右哪个元素都可以。四结点中两边的元素转化为红黑树的红结点。 2、拆分三结点和四结点，和父结点连接的一定是黑结点 （见图：2-3-4_tree.drawio.html 12-2） reference（参考） 掌握了2-3-4树也就掌握了红黑树，不信进来看看，建议收藏！ 理解2-3-4树bilibili&ndash;木子喵neko【neko】红黑树/插入【算法编程#11】【neko】红黑树/删除【算法编程#12】]]></content>
  </entry>
  
  <entry>
    <title>2-3 树</title>
    <url>/post/computer-science/data-structure/2-3_tree/</url>
    <categories><category>data-structure(数据结构)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>data-structure(数据结构)</tag>
      <tag>b-tree</tag>
    </tags>
    <content type="html"><![CDATA[资料 2-3_tree.drawio.html 2-3 树 2-3 树就是 3 阶 B-树。 把 2-3 树的三结点拆开，就可以变成红黑树。 2-3 树的性质 1、满足二叉查找树的基本性质。
2、结点可以存放一个元素、两个元素。
假设结点结构从左到右分别为：子树 1、元素 1、子树 2、元素 2、子树 3。 对于存放一个元素的结点，其形态为：子树 1、元素 1、子树 2。 子树 1 存放比 元素 1 小的元素； 子树 2 存放比 元素 1 大的元素。 对于存放两个元素的结点，其形态为：子树 1、元素 1、子树 2、元素 2、子树 3。 子树 1 存放比 元素 1 和 元素 2 都小的元素； 子树 2 存放在 元素 1 和 元素 2 之间的元素； 子树 3 存放比 元素 1 和 元素 2 都大的元素。 3、2-3 树是绝对平衡的二叉查找树，所有叶子结点都在同一层上。从根结点到任意一个叶子结点所经过的结点数是相同的。
2-3 树的插入 下面列举的情况并不一定覆盖所有的场景，但是典型场景都有了，没有提到的场景可以根据典型场景推导。
只上溢不旋转的情况 1、空树。
添加结点 =&gt; 变二结点。（见图：2-3_tree.drawio.html 2-2-2）
2、二结点。
添加结点 =&gt; 变三结点。（见图：2-3_tree.drawio.html 2-2-4）
3、没有父结点的三结点。
添加结点 =&gt; 变四结点 =&gt; 上溢（层数增加）。（见图：2-3_tree.drawio.html 2-4-2）
4、有父结点的三结点（父结点不是三结点）。
添加结点 =&gt; 变四结点 =&gt; 上溢（层数不增加）。（见图：2-3_tree.drawio.html 2-4-4）
这种情况，三结点是父结点哪个子结点，都是一样的处理逻辑，上溢一次。
5、有父结点的三结点（父结点是三结点）。
添加结点 =&gt; 变四结点 =&gt; 上溢（父结点变四结点）=&gt; 父结点上溢（层数增加）。（见图：2-3_tree.drawio.html 2-6）
这种情况，四结点是父结点哪个子结点，都是一样的处理逻辑，上溢两次。
可以通过旋转抵消上溢的情况 1、有父结点的三结点（父结点是三结点、兄弟结点不是三结点）。
添加结点 =&gt; 变四结点 =&gt; 兄弟结点有空位 =&gt; 旋转结点到兄弟结点（抵消上溢，层数不增加）。
这种情况，如果只上溢的话，会上溢两次（自己上溢一次、父结点上溢一次），树的深度增加了，可能影响查询效率。
但是这个时候其实 2-3 树是不满的，兄弟结点是有空位的。这时候就可以通过旋转，重新平衡 2-3 树。
根据 2-3 树有空位的兄弟结点的位置，旋转的情况分为四种，处理方式是差不多的：
向右旋转一次（见图：2-3_tree.drawio.html 4-2-2） 向左旋转一次（见图：2-3_tree.drawio.html 4-2-4） 向右旋转两次（见图：2-3_tree.drawio.html 4-4） 向左旋转两次（无图，参考向右旋转两次的图）。 2、有父结点的三结点（父结点是三结点、兄弟结点是三结点、祖父结点是三结点、叔叔结点不是三结点）。
添加结点 =&gt; 变四结点 =&gt; 父结点和兄弟结点都没有空位，无法旋转，只能上溢（父结点变四结点） =&gt; 叔叔结点有空位 =&gt; 旋转结点到叔叔结点（抵消上溢，层数不增加）。
这种情况，如果只上溢的话，会上溢三次（自己上溢一次、父结点上溢一次、祖父结点上溢一次），树的深度增加了，可能影响查询效率。
但是这个时候其实 2-3 树是不满的，叔叔结点是有空位的。这时候就可以通过旋转，重新平衡 2-3 树。
这里第一次的上溢是避免不了的。上溢之后，重新以父结点为参照，这时就可以看做上面第一种情况。
根据 2-3 树有空位的叔叔结点的位置，旋转的情况分为四种，处理方式是差不多的：
（上溢一次后）向右旋转一次（见图：2-3_tree.drawio.html 4-6-2） （上溢一次后）向左旋转一次（无图，参考向右旋转一次的图） （上溢一次后）向右旋转两次（见图：2-3_tree.drawio.html 4-6-4） （上溢一次后）向左旋转两次（无图，参考向右旋转两次的图）。 2-3 树的删除 下面列举的情况并不一定覆盖所有的场景，但是典型场景都有了，没有提到的场景可以根据典型场景推导。
删除叶子结点 1、删除三结点的结点。
直接删掉就好了，不会破坏 2-3 树的性质。（见图：2-3_tree.drawio.html 6-2）
2、删除二结点的结点（父结点是二结点、兄弟结点是二结点）。
删除结点 =&gt; 父结点少一个子树 =&gt; 父结点下溢（唯一的结点，层次减少） =&gt; 父结点和兄弟结点融合。（见图：2-3_tree.drawio.html 6-4-2）
这种情况，删掉结点之后，自己这个位置就是空的了。也就是父结点变得少一个子树，这会破坏 2-3 树的性质。
处理方式是，就把父结点放到下面一层去，和兄弟结点融合成一个结点，这样就不会破坏 2-3 树的性质了。
图里的例子是父结点的子树 1 被删空了，子树 2 被删空的情况是一样的处理方式。
3、删除二结点的结点（父结点是三结点、兄弟结点都是二结点）。（类似第 2 种情况）
删除结点 =&gt; 父结点少一个子树 =&gt; 父结点下溢（其中一个结点，层次不变） =&gt; 下溢结点和兄弟结点融合。（见图：2-3_tree.drawio.html 6-4-4）
4、删除二结点的结点（父结点是二结点、兄弟结点是三结点）。
删除结点 =&gt; 父结点少一个子树 =&gt; 兄弟结点可以借一个结点 =&gt; 旋转结点到删除结点的位置。（见图：2-3_tree.drawio.html 6-6-2）
这种情况，删掉结点之后，自己这个位置就是空的了。也就是父结点变得少一个子树，这会破坏 2-3 树的性质。
和上面第 2 种情况不同的是，在第 2 种情况中，兄弟结点是二结点，借不出结点。而这里可以借一个结点过来，把这个子树补上，这样就不破坏 2-3 树的性质了。
图里的例子是向左旋转一次的情况，向右旋转一次的处理方式是一样的。
另外，还有向左旋转两次的情况（见图：2-3_tree.drawio.html 6-10-2），向右旋转两次的处理方式是一样的。
5、删除二结点的结点（父结点是三结点、兄弟结点是三结点）。
删除结点 =&gt; 父结点少一个子树 =&gt; 兄弟结点可以借一个结点 =&gt; 旋转结点到删除结点的位置。（见图：2-3_tree.drawio.html 6-6-4）
图里的例子是向左旋转一次的情况，向右旋转一次的处理方式是一样的。
6、删除二结点的结点（父结点是二结点、兄弟结点是二结点、祖父结点是二结点、叔叔结点是二结点）。
删除结点 =&gt; 父结点少一个子树 =&gt; 父结点下溢（父结点和兄弟结点融合） =&gt; 祖父结点少一个子树 =&gt; 祖父结点下溢（唯一的结点，层次减少） =&gt; 祖父结点和叔叔结点融合。（见图：2-3_tree.drawio.html 6-12-2）
这种情况，初始场景类似上面第 2 种情况，解决方案也是类似第 2 种情况的：下溢 + 融合。初始场景处理完之后，重新以父结点为参照，又是类似上面第 2 种情况，再来一遍就好了。
7、删除二结点的结点（父结点是二结点、兄弟结点是二结点、祖父结点是三结点、叔叔结点是二结点）。
删除结点 =&gt; 父结点少一个子树 =&gt; 父结点下溢（父结点和兄弟结点融合） =&gt; 祖父结点少一个子树 =&gt; 祖父结点下溢（其中一个结点，层次不变） =&gt; 下溢结点和叔叔结点融合。（见图：2-3_tree.drawio.html 6-12-4）
这种情况，初始场景类似上面第 2 种情况，解决方案也是类似第 2 种情况的：下溢 + 融合。初始场景处理完之后，重新以父结点为参照，类似上面第 3 种情况，解决方案也是类似第 3 种情况的：下溢 + 融合。
8、删除二结点的结点（父结点是二结点、兄弟结点是二结点、祖父结点是三结点、叔叔结点是三结点）。
删除结点 =&gt; 父结点少一个子树 =&gt; 父结点下溢（父结点和兄弟结点融合） =&gt; 祖父结点少一个子树 =&gt; 叔叔结点可以借一个结点 =&gt; 旋转结点到祖父结点的删除结点的位置。（见图：2-3_tree.drawio.html 6-14）
这种情况，初始场景类似上面第 2 种情况，解决方案也是类似第 2 种情况的：下溢 + 融合。初始场景处理完之后，重新以父结点为参照，类似上面第 4 种情况，解决方案也是类似第 4 种情况的：旋转。
删除的不是叶子结点 这种情况需和平衡二叉树一样，找到中序遍历的前驱结点或者后继结点，把这两个结点互换位置，这个时候要删除的结点会被换到叶子结点的位置，然后再删除。
2-3 树转换成红黑树 1、三结点其中一个元素转化为红黑树的红结点，左右哪个元素都可以。 2、拆分三结点，和父结点连接的一定是黑结点。 （见图：2-3_tree.drawio.html 10-2） reference（参考） 二三树、B树(多路平衡查找树)、B+树二叉树，红黑树，23树，B树，B+树2-3树的删除bilibili&ndash;天羽神奈2-3树的定义与搜索图解2-3树插入节点方法2-3树删除节点图解及示例]]></content>
  </entry>
  
  <entry>
    <title>使用 Jekyll 主题</title>
    <url>/post/computer-science/application/jekyll/jekyll-theme/</url>
    <categories><category>application(应用)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>Ruby</tag>
      <tag>Jekyll</tag>
      <tag>GitHub Pages</tag>
    </tags>
    <content type="html"><![CDATA[环境 Windows 11 家庭版 Ruby 3.1.2 RubyGems 3.3.7 Jekyll 4.2.2 jekyll-TeXt-theme Github：https://github.com/kitian616/jekyll-TeXt-theme官方文档：https://tianqi.name/jekyll-TeXt-theme/第 1 步，从 Github 上把项目下载下来。
第 2 步，安装 Ruby 依赖包。
&gt; bundle install --path vendor/bundle[DEPRECATED] The `--path` flag is deprecated because it relies on being remembered across bundler invocations, which bundler will no longer do in future versions. Instead please use `bundle config set --local path &#39;vendor/bundle&#39;`, and stop using this flag一大堆输出。。。Using jekyll-text-theme 2.2.6 from source at `.`Bundle complete! 3 Gemfile dependencies, 41 gems now installed.Bundled gems are installed into `./vendor/bundle`Post-install message from html-pipeline:-------------------------------------------------Thank you for installing html-pipeline!You must bundle Filter gem dependencies.See html-pipeline README.md for more details.https://github.com/jch/html-pipeline#dependencies------------------------------------------------- 安装完成后，可以使用 Jekyll 集成的那个开发用的服务器，然后使用浏览器在本地进行预览。
这里同样会遇到 webrick 无法加载的那个异常情况，解决方法是一样的。
jekyll-theme-chirpy Github：https://github.com/cotes2020/jekyll-theme-chirpy官方文档（同时也是个 Demo）：https://chirpy.cotes.page/个人感觉，这个主题比上面那个正在用的要好看不少。
但是无奈，按照官方文档走流程的时候，在发布流程的 Github Action 步骤卡住了。而且没有找到解决方案，遂遗憾放弃。
]]></content>
  </entry>
  
  <entry>
    <title>使用 Jekyll 和 GitHub Pages 搭建站点</title>
    <url>/post/computer-science/application/jekyll/jekyll-start/</url>
    <categories><category>application(应用)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>Ruby</tag>
      <tag>Jekyll</tag>
      <tag>GitHub Pages</tag>
    </tags>
    <content type="html"><![CDATA[环境 Windows 11 家庭版 Ruby 3.1.2 RubyGems 3.3.7 Jekyll 4.2.2 安装 Jekyll 在官方文档中有详细的安装 Jekyll 的流程说明。
Jekyll 官方文档的中文版：http://jekyllcn.com/。
第 1 步，安装 Ruby。
Ruby 官方网站的中文版：http://www.ruby-lang.org/zh_cn/。
进入 Ruby 下载页面：http://www.ruby-lang.org/zh_cn/downloads/下载页面的文档指出，Windows 可以用 RubyInstaller：https://rubyinstaller.org/。
安装 Ruby 的方法
每个流行的平台都有多种工具可用于安装 Ruby：
Linux/UNIX 平台，可以使用第三方工具（如 rbenv 或 RVM）或使用系统中的包管理系统。 macOS 平台，可以使用第三方工具（如 rbenv 或 RVM）。 Windows 平台，可以使用 RubyInstaller。 进入 RubyInstaller 下载页面，页面右侧的说明会告诉你该下哪一个版本的。
Which version to download?
If you don’t know what version to install and you’re getting started with Ruby, we recommend that you use the Ruby+Devkit 3.1.X (x64) installer.
下载 Ruby+Devkit 3.1.2-1 (x64) 完成后，双击运行，启动 Ruby 安装向导，然后一路 next 即可。
记得勾选 Add Ruby executables to your PATH，把 Ruby 的运行目录添加到 Windows 的环境变量 PATH 里，要不然在命令行窗口（CMD）里不能直接用命令。
安装过程中，安装向导可能会卡住，等一会就行。RubyInstaller 会把 Ruby 和 RubyGems 一起装了。RubyGems 是一个 Ruby 程序，用来管理 Ruby 包的。
安装完成后，可以在命令行里使用命令输出一下版本信息，看看安装是否成功。
&gt; ruby -vruby 3.1.2p20 (2022-04-12 revision 4491bb740a) [x64-mingw-ucrt] &gt; gem -v3.3.7 第 2 步，安装 Jekyll。
使用 RubyGems 安装 Jekyll。
&gt; gem install jekyll一大堆输出。。。Done installing documentation for unicode-display_width, terminal-table, safe_yaml, rouge, forwardable-extended, pathutil, mercenary, liquid, kramdown, kramdown-parser-gfm, ffi, rb-inotify, rb-fsevent, listen, jekyll-watch, sassc, jekyll-sass-converter, concurrent-ruby, i18n, http_parser.rb, eventmachine, em-websocket, colorator, public_suffix, addressable, jekyll after 24 seconds26 gems installed 安装过程需要几分钟，等它装完即可。如果长时间没有反应，可以在命令行按一下回车，不排除可能是 Windows 命令行卡住了没输出信息。
安装完成后，可以在命令行里使用命令输出一下版本信息，看看安装是否成功。
&gt; jekyll -vjekyll 4.2.2 生成模板 使用 jekyll 生成模板。
这里是在 D 盘的 workspace/github.io 目录里生成模板。
&gt; jekyll new github.ioRunning bundle install in D:/workspace/github.io...一大堆输出。。。New jekyll site installed in D:/workspace/github.io. Bundler 可以认为是一个针对项目的包管理程序。它通过项目目录下的 Gemfile 文件来管理项目依赖。Bundler 在安装依赖时，会使用 RubyGems。
开发服务器 Jekyll 集成了一个开发用的服务器，可以使用浏览器在本地进行预览。
&gt; jekyll serveConfiguration file: D:/workspace/github.io/_config.ymlSource: D:/workspace/github.ioDestination: D:/workspace/github.io/_siteIncremental build: disabled. Enable with --incrementalGenerating...Jekyll Feed: Generating feed for postsdone in 0.808 seconds.Please add the following to your Gemfile to avoid polling for changes:gem &#39;wdm&#39;, &#39;&gt;= 0.1.0&#39; if Gem.win_platform?Auto-regeneration: enabled for &#39;D:/workspace/github.io&#39;Server address: http://127.0.0.1:4000/Server running... press ctrl-c to stop. 正常情况应该是输出上面的内容，然后就用浏览器访问 http://localhost:4000/ 查看博客了。
异常情况 &gt; jekyll serveConfiguration file: D:/workspace/github.io/_config.ymlSource: D:/workspace/github.ioDestination: D:/workspace/github.io/_siteIncremental build: disabled. Enable with --incrementalGenerating...Jekyll Feed: Generating feed for postsdone in 0.827 seconds.Please add the following to your Gemfile to avoid polling for changes:gem &#39;wdm&#39;, &#39;&gt;= 0.1.0&#39; if Gem.win_platform?Auto-regeneration: enabled for &#39;D:/workspace/github.io&#39;------------------------------------------------Jekyll 4.2.2 Please append `--trace` to the `serve` commandfor any additional information or backtrace.------------------------------------------------C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve/servlet.rb:3:in `require&#39;: cannot load such file -- webrick (LoadError)from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve/servlet.rb:3:in `&lt;top (required)&gt;&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:179:in `require_relative&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:179:in `setup&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:100:in `process&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `block in process_with_graceful_fail&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `each&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `process_with_graceful_fail&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:86:in `block (2 levels) in init_with_program&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `block in execute&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `each&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `execute&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/program.rb:44:in `go&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary.rb:21:in `program&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/exe/jekyll:15:in `&lt;top (required)&gt;&#39;from C:/Ruby31-x64/bin/jekyll:32:in `load&#39;from C:/Ruby31-x64/bin/jekyll:32:in `&lt;main&gt;&#39; 输出的信息提示使用 --trace 参数，看看执行过程中发生了什么。但是实际上下 1 行已经提示了，webrick 无法加载。
------------------------------------------------Jekyll 4.2.2 Please append `--trace` to the `serve` commandfor any additional information or backtrace.------------------------------------------------C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve/servlet.rb:3:in `require&#39;: cannot load such file -- webrick (LoadError) 这里用一下 --trace 参数，输出没啥变化，依然提示 webrick 无法加载。
&gt; jekyll serve --traceConfiguration file: D:/workspace/github.io/_config.ymlSource: D:/workspace/github.ioDestination: D:/workspace/github.io/_siteIncremental build: disabled. Enable with --incrementalGenerating...Jekyll Feed: Generating feed for postsdone in 0.747 seconds.Please add the following to your Gemfile to avoid polling for changes:gem &#39;wdm&#39;, &#39;&gt;= 0.1.0&#39; if Gem.win_platform?Auto-regeneration: enabled for &#39;D:/workspace/github.io&#39;C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve/servlet.rb:3:in `require&#39;: cannot load such file -- webrick (LoadError)from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve/servlet.rb:3:in `&lt;top (required)&gt;&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:179:in `require_relative&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:179:in `setup&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:100:in `process&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `block in process_with_graceful_fail&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `each&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `process_with_graceful_fail&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:86:in `block (2 levels) in init_with_program&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `block in execute&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `each&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `execute&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/program.rb:44:in `go&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary.rb:21:in `program&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/exe/jekyll:15:in `&lt;top (required)&gt;&#39;from C:/Ruby31-x64/bin/jekyll:32:in `load&#39;from C:/Ruby31-x64/bin/jekyll:32:in `&lt;main&gt;&#39; 这时可以回到上面使用 jekyll 生成模板的地方，从输出的信息中可以发现 Bundler 并没有安装 webrick。所以这里手动执行命令安装 webrick。
&gt; bundle add webrickFetching gem metadata from https://rubygems.org/..........Resolving dependencies...Fetching gem metadata from https://rubygems.org/..........Resolving dependencies... 等待安装完成，应该就可以使用 jekyll serve 命令了。
推送项目到 GitHub Pages GitHub Pages 官方文档：https://pages.github.com/按照要求建一个名字叫 {username}.github.io 仓库，然后把项目推上去就行了。
然后就可以通过 https://{username}.github.io 访问了。
]]></content>
  </entry>
  
  <entry>
    <title>站点示例</title>
    <url>/flinks.html</url>
    <categories>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[如想要交换友情链接，请在评论区留下你的站点信息，格式参考如下：
名称： NexT 主题 说明： 保持简单的易用性和强大的功能。 站标： https://hugo-next.eu.org/imgs/hugo_next_avatar.png网址： https://hugo-next.eu.org]]></content>
  </entry>
  
</search>