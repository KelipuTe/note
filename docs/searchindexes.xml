<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<search>
  
  <entry>
    <title>如何使用档案馆</title>
    <url>/post/how_to_use/</url>
    <categories>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[前言 再次强调：
帕里特档案馆（重建中，旧篇总计 283，迁移完成 8，新增 6），是个个人档案馆。
内容主要是学习笔记和实操过程的记录。
本人能力有限，因此不能保证所有的内容的时效性和正确性。还请各位到访的有缘人务必小心。
本人能力有限，因此不能保证所有的内容的时效性和正确性。还请各位到访的有缘人务必小心。
本人能力有限，因此不能保证所有的内容的时效性和正确性。还请各位到访的有缘人务必小心。
如何使用档案馆 档案馆的内容分为三个部分：
文本 代码，借助 github 图，借助 draw.io 如果文本使用到了代码或者图片，通常在文本的最前面会有一个标题为 资料 的部分。
如果是类似 {xxx}/aaa/bbb/ 这种格式的，就是 github 的项目的代码，需要去 github 上查看。 其中 {demo-c}、{tcp-service-c} 是私有仓库，暂不对外开放。
如果是类似 xxx.drawio.html 这种格式的，就是 draw.io 生成的 html，直接打开就可以预览。 参考到的外部资料通常在文本的最后面会有一个标题为 reference（参考） 的部分。
]]></content>
  </entry>
  
  <entry>
    <title>使用 Golang 实现 Web 框架 -- 复杂的 web 框架</title>
    <url>/post/computer-science/programming-language/golang/web/web_v40/</url>
    <categories><category>golang</category>
    </categories>
    <tags>
      <tag>golang</tag>
      <tag>web</tag>
      <tag>http</tag>
      <tag>router(路由)</tag>
      <tag>middleware(中间件)</tag>
    </tags>
    <content type="html"><![CDATA[ go version go1.19
前言 在看这篇之前，建议先看下面这几篇：
使用 Golang 开启 HTTP 服务 使用 Golang 实现 Web 框架 &ndash; router(路由) 使用 Golang 实现 Web 框架 &ndash; middleware(中间件) 路由树和中间件是 web 框架的核心。其他的功能，都是在这两个核心的基础上，再增加亿点点细节而已。
资料 {web-framework-go}/v40 实现功能 主要实现： 路由树（静态、通配符、路径参数、正则表达式）、路由组 全局中间件、可路由的中间件 次要实现： 内存池（请求上下文对象复用） 服务管理（管理多个子服务） 优雅退出、退出时的回调方法 计划实现： 用户认证（中间件实现） 文件操作（上传、下载） 单元测试、集成测试、性能测试 设计文档 路由树 首先是路由树结点的设计。结点的基础数据包括：结点类型、这个路由结点代表的那段路径、命中路由之后的的处理逻辑。
静态路由子结点使用 map 结构存储，查询时直接就可以通过路由段查询子结点。
通配符子结点、路径参数子结点、正则表达式子结点，这三个结点属于特殊结点，而且存在冲突关系，所以单独存储。
为了支持可路由的中间件，路由结点上还需要有存储中间件的地方，这样就可以为每个结点单独设置中间件。
另外，服务在运行的时候只要命中的是同一个路由，那么用到的中间件一定也是相同的，在服务启动的时候就可以把中间件遍历好，然后缓存下来。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 // routingNode 路由结点 type routingNode struct { // nodeType 结点类型 nodeType int // part 这个路由结点代表的那段路径 part string // path 从根路由到这个路由结点的全路径 path string // f4handler 命中路由之后的处理逻辑 f4handler HTTPHandleFunc // m3routingTree 路由子树，子结点的 path =&gt; 子树根结点 m3routingTree map[string]*routingNode // p7paramChild 路径参数结点 p7paramChild *routingNode // paramName 路径参数路由和正则表达式路由，都会提取路由参数的名字 paramName string // p7regexpChild 正则表达式结点 p7regexpChild *routingNode // p7regexp 正则表达式 p7regexp *regexp.Regexp // p7anyChild 通配符结点 p7anyChild *routingNode // s5f4middleware 结点上注册的中间件 s5f4middleware []HTTPMiddleware // s5f4middlewareCache 服务启动后，命中结点时，需要用到的所有中间件 s5f4middlewareCache []HTTPMiddleware } 路由树的构造和遍历并不复杂，使用递归逻辑处理即可。不用担心递归带来的性能问题。
对于路由树的递归操作，都发生在服务启动时，这个时候会遍历路由树然后将结果缓存下来。
服务启动后，当请求访问过来时，就可以直接使用缓存里的结果，而不用每次都去遍历路由树。
路由组 路由组就是个语法糖。相当于路由组方法会在路由组内的每个成员注册的时候，附加路由组的路由前缀和路由组定义的中间件。
1 2 3 4 5 6 7 8 9 10 // Group 添加一组路由 func (p7this *HTTPHandler) Group(path string, s5f4mw []HTTPMiddleware, s5routeData []RouteData) { for _, rd := range s5routeData { t4path := path if &#34;/&#34; != rd.Path { t4path = path + rd.Path } p7this.addRoute(rd.Method, t4path, rd.F4handle, s5f4mw...) } } 中间件 全局中间件和可路由中间件是分开放的。全局中间件存储在核心处理逻辑上。可路由中间件存储在路由树结点上。
1 2 3 4 5 6 7 8 9 10 11 12 13 // HTTPHandlerInterface 核心处理逻辑的接口定义 type HTTPHandlerInterface interface { http.Handler ... } // HTTPHandler 核心处理逻辑 type HTTPHandler struct { ... // s5f4middleware 全局中间件 s5f4middleware []HTTPMiddleware ... } 当请求访问过来时，第一站到的是核心处理逻辑，核心处理逻辑会完成全局中间件的组装和执行。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 func (p7this *HTTPHandler) ServeHTTP(i9w http.ResponseWriter, p7r *http.Request) { ... // 倒过来组装，先组装的在里层，里层的后执行 // 最里层应该是找路由然后执行业务代码 t4chain := p7this.doServeHTTP for i := len(p7this.s5f4middleware) - 1; i &gt;= 0; i-- { t4chain = p7this.s5f4middleware[i](t4chain) } // 写入响应数据这个中间件应该由框架开发者处理 // 它是最后一个环节，应该在最外层 t4m := FlashRespMiddleware() t4chain = t4m(t4chain) t4chain(p7ctx) } 在通过全局中间件之后，进入查询路由树的步骤。查询结果里会有路由树结点上的可路由中间件。
使用和全局中间件一样的套路，完成一遍可路由中间件的组装和执行。最后调用路由上的处理逻辑，开始真正的业务逻辑。
1 2 3 4 5 6 7 8 9 10 11 func (p7this *HTTPHandler) doServeHTTP(p7ctx *HTTPContext) { ... p7ri := p7this.findRoute(p7ctx.P7request.Method, p7ctx.P7request.URL.Path) ... // 这里用同样的套路，处理路由上的中间件，最后执行业务代码 t4chain := p7ri.p7node.f4handler for i := len(p7ri.p7node.s5f4middlewareCache) - 1; i &gt;= 0; i-- { t4chain = p7ri.p7node.s5f4middlewareCache[i](t4chain) } t4chain(p7ctx) } 优雅退出 想实现优雅退出，程序就不能阻塞在不可控的位置。这里可以直接把服务丢到协程里去。
然后在最外面，实现一个信号等待的逻辑，这样就可以通过信号控制程序的运行状态。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 func (p7this *ServiceManager) Start() { // 启动服务 log.Println(&#34;服务启动中。。。&#34;) for _, p7s := range p7this.s5p7HTTPService { t4p7s := p7s go func() { if err := t4p7s.Start(); nil != err { if http.ErrServerClosed == err { log.Printf(&#34;子服务 %s 已关闭\n&#34;, t4p7s.name) } else { log.Printf(&#34;子服务 %s 异常退出，err:%s\r\n&#34;, t4p7s.name, err) } } }() } log.Println(&#34;服务启动完成。&#34;) // 监听 ctrl+c 信号 c4signal := make(chan os.Signal, 2) signal.Notify(c4signal, os.Interrupt) select { case &lt;-c4signal: ... } } 在可以主动介入程序运行之后，就可以设计主动拒绝新请求的逻辑了。这样可以实现服务不完全停止的情况下，拒绝对外服务
因为服务停止不仅仅是不对外服务这么简单，在服务真正的停止之前，还有很多善后的工作需要做。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // HTTPHandler 核心处理逻辑 type HTTPHandler struct { ... // isRunning 服务是否正在运行 isRunning bool } func (p7this *HTTPHandler) doServeHTTP(p7ctx *HTTPContext) { // 如果服务已经关闭了就直接返回 if !p7this.isRunning { p7ctx.I9writer.WriteHeader(http.StatusInternalServerError) _, _ = p7ctx.I9writer.Write([]byte(&#34;服务已关闭&#34;)) return } ... } 虽然服务停止前有很多善后的工作需要做，但是理论上不会持续很久。
为了防止意外卡死的情况出现，可以再加一层超时强制停止的逻辑。必要的时候，也可以设计主动强制关闭的入口。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 func (p7this *ServiceManager) Start() { ... // 监听 ctrl+c 信号 c4signal := make(chan os.Signal, 2) signal.Notify(c4signal, os.Interrupt) select { case &lt;-c4signal: log.Printf(&#34;接收到关闭信号，开始关闭服务，限制 %d 秒内完成。。。\r\n&#34;, p7this.shutdownTimeOut/time.Second) // 再次监听 ctrl+c 信号 go func() { select { case &lt;-c4signal: log.Println(&#34;再次接收到关闭信号，服务直接退出。&#34;) os.Exit(1) } }() time.AfterFunc(p7this.shutdownTimeOut, func() { log.Println(&#34;优雅关闭超时，服务直接退出。&#34;) os.Exit(1) }) p7this.Shutdown() } } 在拒绝新请求之后，由于有可能还有旧的请求没有处理完，所以是不能立刻就关闭服务的，需要等待一段时间。
1 2 3 4 5 6 7 8 9 10 11 func (p7this *ServiceManager) Shutdown() { ... log.Println(&#34;停止接收新请求。&#34;) for _, p7hs := range p7this.s5p7HTTPService { p7hs.Stop() } log.Printf(&#34;等待正在执行的请求结束，等待 %d 秒。。。&#34;, p7this.shutdownWaitTime/time.Second) time.Sleep(p7this.shutdownWaitTime) ... } 服务正式关闭服务之后，可能还有一些收尾的工作需要处理，然后才能彻底退出程序。
比如：系统里如果有缓存的话，可能需要把缓存进行持久化处理；系统关闭时，需要上报数据其他服务等。
这个可以通过回调实现，和中间件的用法类似。不过最后执行的时候，是所有的回调是并发执行的，而不是像中间件一样套起来，一次执行的。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func (p7this *ServiceManager) Shutdown() { ... log.Println(&#34;开始执行子服务的关闭回调。。。&#34;) for _, p7hs := range p7this.s5p7HTTPService { log.Printf(&#34;执行子服务 %s 的关闭回调，限制 %d 秒内完成。。。&#34;, p7hs.name, p7this.shutdownCallbackTimeOut/time.Second) for _, f4cb := range p7hs.s5f4shutdownCallback { t4f4cb := f4cb wg.Add(1) go func() { defer wg.Done() t4ctx, t4cancel := context.WithTimeout(context.Background(), p7this.shutdownCallbackTimeOut) defer t4cancel() t4f4cb(t4ctx) }() } } wg.Wait() ... } 到这里核心的部分就差不多了，细节上的实现可以看代码。
]]></content>
  </entry>
  
  <entry>
    <title>使用 Hugo 和 GitHub Pages 搭建站点</title>
    <url>/post/computer-science/application/hugo/hugo-start/</url>
    <categories><category>application(应用)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>Hugo</tag>
      <tag>GitHub Pages</tag>
    </tags>
    <content type="html"><![CDATA[ Windows 11 家庭版 cpu amd64 hugo 0.103.1 Hugo 文档 gohugoio/hugo英文文档中文文档安装 Hugo 在 Hugo Releases页面下载对应操作系统的版本。这里下载的是 hugo_0.103.1_windows-amd64.zip。
下载完成后，解压到想要的位置。这里使用的目录是 D:\hugo\bin。然后将这个目录添加到 系统变量 path 中（我的电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 环境变量 -&gt; 系统变量 -&gt; path）。
搞定之后，可以打开控制台，输出一下版本信息，验证一下安装是否成功。或者试试 hugo help 命令，看看能不能输出帮助信息。
1 2 &gt; hugo version hugo v0.103.1-b665f1e8f16bf043b9d3c087a60866159d71b48d windows/amd64 BuildDate=2022-09-18T13:19:01Z VendorInfo=gohugoio 如果有需要的话，需要安装 extended 版本的。这里下载的是 hugo_extended_0.103.1_windows-amd64.zip。
1 2 &gt; hugo version hugo v0.103.1-b665f1e8f16bf043b9d3c087a60866159d71b48d+extended windows/amd64 BuildDate=2022-09-18T13:19:01Z VendorInfo=gohugoio 创建站点 使用命令创建一个站点，如果没问题的话，hugo 会在当前目录下创建一个名字是 project-name 的目录。
1 &gt; hugo new site {project-name} 新建的站点没有任何内容，可以使用命令创建一个内容页面。新创建的文件会在目录 content/ 里。创建内容页面的时候也可以带上目录。
1 2 &gt; hugo new helloworld.md &gt; hugo new posts/helloworld.md 安装主题 这里就是和别的站点工具不一样的地方了，比如 hexo 和 jekyll，如果没有安装主题的话，是会有一个默认的主题的。
但是 hugo 没有默认主题，需要去主题库下载一个，然后添加到站点里并配置好，这样才能启动站点。如果没有安装主题就启动的话，会报没有模板的错误。
可以去 官方的主题库找一个喜欢的。然后按照主题提供的文档配置一下。
Hugo NexT Hugo NexT这个主题是从 Hexo NexT 移植过来的。
GitHub 项目地址 hugo-next/hugo-theme-next。
按着 Hexo NexT 主题提供的的文档走，把主题配置到站点中。
别忘了先 git init，然后使用命令下载主题 git submodule add https://github.com/hugo-next/hugo-theme-next.git themes/hugo-theme-next。
如果需要升级主题的话，就进入 {path-to-project}/themes/github-style 目录，执行 git pull 命令，拉取最新的代码。
然后把 {path-to-project}themes/hugo-theme-next/exampleSite/ 目录下所有的文件复制到 {path-to-project}/ 目录下覆盖。
最后删除原来的配置文件 config.toml，然后就可以使用命令 hugo server 启动服务了。
另外需要注意的是，这个主题需要 hugo extended 版本，如果用的不是 extended 版本，启动的时候会报下面这样的错，提示去安装 extended 版本。
1 2 3 4 5 6 &gt; hugo server Start building sites … hugo v0.103.1-b665f1e8f16bf043b9d3c087a60866159d71b48d windows/amd64 BuildDate=2022-09-18T13:19:01Z VendorInfo=gohugoio WARN 2022/09/20 21:12:38 Hugo NexT 主题使用了 SCSS 框架，请到官方地址下载 Hugo Extended 版本：https://github.com/gohugoio/hugo/releases ERROR 2022/09/20 21:12:38 Because that use SCSS framework in Hugo NexT, Please download Hugo extended version on offical site: https://github.com/gohugoio/hugo/releases Error: Error building site: TOCSS: failed to transform &#34;main.scss&#34; (text/x-scss). Check your Hugo installation; you need the extended version to build SCSS/SASS.: this feature is not available in your current Hugo version, see https://goo.gl/YMrWcn for more information github-style（选看） github-style这个主题是 github 的页面风格。
GitHub 项目地址 MeiK2333/github-style。
按着 github-style 主题提供的的文档走，把主题配置到站点中。
别忘了先 git init，然后使用命令下载主题 git submodule add git@github.com:MeiK2333/github-style.git themes/github-style。
如果需要升级主题的话，就进入 {path-to-project}/themes/github-style 目录，执行 git pull 命令，拉取最新的代码。
在 content/ 里创建 post/ 目录，后面所有的内容页面都放到这个目录下面，要不然站点里不会展示。
最后在配置文件 config.toml 里设置主题 theme = &quot;github-style&quot;。然后就可以使用命令 hugo server 启动服务了。
站点是没有问题的，可以正常地跑起来。但是这个主题貌似没有实现标签分类，也可能是本人没有找到，所以就放弃继续使用了。
部署到 GitHub Pages 使用命令 hugo -t {theme-name} 来把发布用的目录编译出来。这里就是 hugo -t hugo-theme-next。
默认情况下会编译到 {path-to-project}/publish/ 目录。 可以通过编辑配置文件，在配置文件里添加 publishDir: docs，来修改这个目录。
push 到 github.io 的时候，如果使用的是 publish/ 目录。那么要 push publish/ 目录上去，然后设置 GitHub Pages 的 Branch 为 master 和 /(root)。
如果使用的是 docs/ 目录，那么就要 push 整个项目上去，然后设置 GitHub Pages 的 Branch 为 master 和 docs/。
reference（参考） hugo个人博客搭建并部署到GitHub【 for Windows】]]></content>
  </entry>
  
  <entry>
    <title>使用 Golang 实现 Web 框架 -- middleware(中间件)</title>
    <url>/post/computer-science/programming-language/golang/web/middleware/</url>
    <categories><category>golang</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>golang</tag>
      <tag>web</tag>
      <tag>http</tag>
      <tag>middleware(中间件)</tag>
    </tags>
    <content type="html"><![CDATA[ go version go1.19
资料 {demo-golang}/demo/web/middleware/ web.drawio.html 中间件 web 框架的中间件可以理解成一种 aop 方案的实现。
可以借助洋葱模型、责任链设计模式、链式调用的概念来理解中间件的整体结构。
中间件的结构示例见图：web.drawio.html 4-2。
定义中间件的时候需要关注两个重要的组成部分：路由的对应的处理方法和中间件的处理方法。
这两个部分定义一起规定了中间件该怎么定义，中间件定义需要围绕这两个定义去实现，要不然调用链条串不起来。
1 2 // HTTPHandleFunc 路由对应的处理方法的定义 type HTTPHandleFunc func(p7ctx *HTTPContext) 1 2 // HTTPMiddleware 中间件的处理方法的定义 type HTTPMiddleware func(next HTTPHandleFunc) HTTPHandleFunc 具体的中间件的实现方式，就像下面这样。
1 2 3 4 5 6 7 8 9 func DemoMiddleware() HTTPMiddleware { return func(next HTTPHandleFunc) HTTPHandleFunc { return func(p7ctx *HTTPContext) { // before DemoMiddleware next(p7ctx) // after DemoMiddleware } } } 假设定义两个中间件。
1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 func AMiddleware() HTTPMiddleware { return func(next HTTPHandleFunc) HTTPHandleFunc { return func(p7ctx *HTTPContext) { // before AMiddleware next(p7ctx) // after AMiddleware } } } func BMiddleware() HTTPMiddleware { return func(next HTTPHandleFunc) HTTPHandleFunc { return func(p7ctx *HTTPContext) { // before BMiddleware next(p7ctx) // after BMiddleware } } } 然后这么链起来，B 在内层，A 在外层。
1 2 3 4 5 6 7 8 9 // serve 是最内层业务代码 chain := serve // 组装中间件 mb := BMiddleware() chain = mb(chain) ma := AMiddleware() chain = mb(chain) // 执行 chain(ctx) 最后的效果等价于下面这样的伪代码。
1 2 3 4 5 // before AMiddleware // before BMiddleware serve(p7ctx) // after BMiddleware // after AMiddleware 可路由的中间件 可路由的中间件就是在路由树的基础上，分别给每个路由树结点设置中间件。
这样在路由匹配到某个路由结点之后，不仅可以获取到路由的处理方法，还可以获取到路由上设置的中间件。
然后把这些中间件，按照定义好的顺序，套起来即可。
]]></content>
  </entry>
  
  <entry>
    <title>使用 Golang 实现 Web 框架 -- router(路由)</title>
    <url>/post/computer-science/programming-language/golang/web/router/</url>
    <categories><category>golang</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>golang</tag>
      <tag>web</tag>
      <tag>http</tag>
      <tag>router(路由)</tag>
    </tags>
    <content type="html"><![CDATA[ go version go1.19
资料 {demo-golang}/demo/web/router/ web.drawio.html 路由 路由的作用是通过请求的路径找到对应的处理方法。
简单的路由可以使用 map 结构，就是单纯的字符串匹配。map 的 key 就是路由的路径，value 就是路由的处理方法。
接收到请求时，用请求的路径直接去 map 里找有没有对应的处理方法。但是这种结构无法满足路径参数路由、正则匹配路由、通配符路由这样的需求。
这些需求需要使用到路由树结构，路由树的结点在存储静态子结点的同时，还可以额外设置特殊子结点。在找不到静态路由时，可以继续判断有没有特殊结点可以选择。
路由树的结构示例见图：web.drawio.html 2-2。
路由树的设计没有强制的要求，按照实际场景的需求，合理的设计路由树的构建和查询规则即可。
路由组 路由组其实就是额外提供的方便使用的接口而已，相当于对路由的注册功能做了一层包装。
路由组的内部，会把定义到路由组上的路由路径前缀和中间件，附加到路由组内的每一个路由上去。
]]></content>
  </entry>
  
  <entry>
    <title>关于帕里特档案馆和西柊慧音</title>
    <url>/about/</url>
    <categories>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[帕里特档案馆（重建中，旧篇总计 283，迁移完成 8，新增 6），是个个人档案馆。
内容主要是学习笔记和实操过程的记录。
本人能力有限，因此不能保证所有的内容的时效性和正确性。还请各位到访的有缘人务必小心。
站点基于 hugo 0.103.1 extended 版本搭建。使用的主题是 Hugo NexT。
站点预计会部属在 github pages 和 gitee pages 上。
如果有问题，欢迎批评指正。同时也欢迎建设性意见。
和本人的交流方式，QQ：786907650；微信号：wxid_k3uqy9xeryn422。昵称和头像都是一样的。
有意交流者，请至少备注是谁和从哪来。
]]></content>
  </entry>
  
  <entry>
    <title>使用 Golang 开启 HTTP 服务</title>
    <url>/post/computer-science/programming-language/golang/web/http/</url>
    <categories><category>golang</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>golang</tag>
      <tag>web</tag>
      <tag>http</tag>
    </tags>
    <content type="html"><![CDATA[ go version go1.19
资料 {demo-golang}/demo/web/http/ 开启 HTTP 服务 在 Go 中有多种方式，可以开启 HTTP 服务。但是总的来说基本就下面两大类思路（本质上其实是一类）。
使用官方提供的封装好的 net/http 包。 直接使用 net 包从 TCP 开始自行实现。 使用 net/http 包的时候，需要关注的最核心的部分，就是 Handler 接口 (src/net/http/server.go)。
1 2 3 type Handler interface { ServeHTTP(ResponseWriter, *Request) } 开启 HTTP 服务和 HTTP 请求被处理的流程大致如下：
直接或间接地创建 Server 结构体 (src/net/http/server.go) 的实例。 调用 Server 的 ListenAndServe() 方法。 ListenAndServe() 调用 net.Listen() (src/net/dial.go)，启动 TCP 服务。 net.Listen() 返回一个 net.Listener 接口 (src/net/dial.go) 的实例。 调用 net.Listener 的 Accept() 方法，就可以获取连接上来的 TCP 连接。 新开启一个协程，把这个 TCP 连接丢进去处理。自己则继续监听有没有别的 TCP 连接。 处理流程继续往下，会遇到这行代码：serverHandler{c.server}.ServeHTTP(w, w.req)。 这里调用的就是 Handler 的 ServeHTTP() 方法。再往下就进入框架或者业务处理流程了。 ]]></content>
  </entry>
  
  <entry>
    <title>2-3-4 树</title>
    <url>/post/computer-science/data-structure/2-3-4_tree/</url>
    <categories><category>data-structure(数据结构)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>data-structure(数据结构)</tag>
      <tag>b-tree</tag>
    </tags>
    <content type="html"><![CDATA[前言 在看 2-3-4 树之前，建议先看 2-3 树。相似的操作在 2-3-4 树不会重复详细的描述。
资料 2-3-4_tree.drawio.html 2-3-4 树 2-3-4 树就是 4 阶 B-树 2-3-4 树和红黑树是等价的： 2-3-4 树的结点个数 = 红黑树的黑色结点个数。 把 2-3-4 树的三结点和四结点拆开，就可以变成红黑树。 把红黑树的红结点移动到和父结点同层，就会变成 2-3-4 树。 2-3-4 树的性质 1、满足二叉查找树的基本性质。
2、结点可以存放一个元素、两个元素。
假设结点结构从左到右分别为：子树 1、元素 1、子树 2、元素 2、子树 3、元素 3、子树 4。 对于存放一个元素的结点。其形态为：子树 1、元素 1、子树 2。 子树 1 存放比 元素 1 小的元素； 子树 2 存放比 元素 1 大的元素。 对于存放两个元素的结点，其形态为：子树 1、元素 1、子树 2、元素 2、子树 3。 子树 1 存放比 元素 1 和 元素 2 都小的元素； 子树 2 存放在 元素 1 和 元素 2 之间的元素； 子树 3 存放比 元素 1 和 元素 2 都大的元素。 对于存放三个元素的结点，其形态为：子树 1、元素 1、子树 2、元素 2、子树 3、元素 3、子树 4。 子树 1 存放比 元素 1、元素 2、元素 3 都小的元素； 子树 2 存放在 元素 1 和 元素 2 之间的元素； 子树 3 存放在 元素 2 和 元素 3 之间的元素； 子树 4 存放比 元素 1、元素 2、元素 3 都大的元素。 3、2-3-4 树是绝对平衡的二叉查找树，所有叶子结点都在同一层上。从根结点到任意一个叶子结点所经过的结点数是相同的。
2-3-4 树的插入 下面列举的情况并不一定覆盖所有的场景，但是典型场景都有了，没有提到的场景可以根据典型场景推导。
只上溢不旋转的情况 1、空树。（类似 2-3 树的第 1 种情况）
2、二结点。（类似 2-3 树的第 2 种情况）
3、三结点。
添加结点 =&gt; 变四结点。（见图：2-3-4_tree.drawio.html 2-2-6）
4、没有父结点的四结点。
添加结点 =&gt; 变五结点 =&gt; 上溢（层数增加）。（见图：2-3-4_tree.drawio.html 2-4-2）
5、有父结点的四结点（父结点不是四结点）。
添加结点 =&gt; 变五结点 =&gt; 上溢（层数不增加）。（见图：2-3-4_tree.drawio.html 2-4-4）
这种情况，四结点是父结点哪个子结点，都是一样的处理逻辑，上溢一次。
这里，父结点可以是二结点也可以是三结点。
6、有父结点的四结点（父结点是四结点）。
添加结点 =&gt; 变五结点 =&gt; 上溢（父结点变五结点）=&gt; 父结点上溢（层数增加）。（见图：2-3-4_tree.drawio.html 2-6）
这种情况，四结点是父结点哪个子结点，都是一样的处理逻辑，上溢两次。
可以通过旋转抵消上溢的情况 1、有父结点的四结点（父结点是四结点、兄弟结点不是四结点）。
添加结点 =&gt; 变五结点 =&gt; 兄弟结点有空位 =&gt; 旋转结点到兄弟结点（抵消上溢，层数不增加）。
这种情况，如果只上溢的话，会上溢两次（自己上溢一次、父结点上溢一次），树的深度增加了，可能影响查询效率。
但是这个时候其实 2-3-4 树是不满的，兄弟结点是有空位的。这时候就可以通过旋转，重新平衡 2-3-4 树。
根据 2-3-4 树有空位的兄弟结点的位置，旋转的情况分为六种，处理方式是差不多的：
向右旋转一次（见图：2-3-4_tree.drawio.html 4-2-2） 向左旋转一次（见图：2-3-4_tree.drawio.html 4-2-4） 向右旋转两次（见图：2-3-4_tree.drawio.html 4-6） 向左旋转两次（无图，参考向右旋转两次的图）。 向右旋转三次（无图，参考向右旋转两次的图）。 向左旋转三次（无图，参考向右旋转两次的图）。 2、有父结点的四结点（父结点是四结点、兄弟结点是四结点、祖父结点是四结点、叔叔结点不是四结点）。
添加结点 =&gt; 变五结点 =&gt; 父结点和兄弟结点都没有空位，无法旋转，只能上溢（父结点变五结点） =&gt; 叔叔结点有空位 =&gt; 旋转结点到叔叔结点（抵消上溢，层数不增加）。
这种情况，如果只上溢的话，会上溢三次（自己上溢一次、父结点上溢一次、祖父结点上溢一次），树的深度增加了，可能影响查询效率。
但是这个时候其实 2-3-4 树是不满的，叔叔结点是有空位的。这时候就可以通过旋转，重新平衡 2-3-4 树。
这里第一次的上溢是避免不了的。上溢之后，重新以父结点为参照，这时就可以看做上面第一种情况。
根据 2-3-4 树有空位的叔叔结点的位置，旋转的情况分为六种，处理方式是差不多的：
（上溢一次后）向右旋转一次（无图，参考向右旋转三次的图）。 （上溢一次后）向左旋转一次（无图，参考向右旋转三次的图）。 （上溢一次后）向右旋转两次（无图，参考向右旋转三次的图）。 （上溢一次后）向左旋转两次（无图，参考向右旋转三次的图）。 （上溢一次后）向右旋转三次（见图：2-3-4_tree.drawio.html 4-8） （上溢一次后）向左旋转三次（无图，参考向右旋转三次的图）。 2-3-4 树的删除 下面列举的情况并不一定覆盖所有的场景，但是典型场景都有了，没有提到的场景可以根据典型场景推导。
删除叶子结点 1、删除三结点的结点。（类似 2-3 树的第 1 种情况）
2、删除四结点的结点。
直接删掉就好了，不会破坏 2-3-4 树的性质。（见图：2-3-4_tree.drawio.html 6-2-4）
3、删除二结点的结点（父结点是二结点、兄弟结点是二结点）。（类似 2-3 树的第 2 种情况）
4、删除二结点的结点（父结点是三结点、兄弟结点是二结点）。（类似 2-3 树的第 3 种情况）
5、删除二结点的结点（父结点是四结点，兄弟结点是二结点）。（类似第 3 种情况）
删除结点 =&gt; 父结点少一个子树 =&gt; 父结点下溢（其中一个结点，层次不变） =&gt; 下溢结点和兄弟结点融合。（见图：2-3-4_tree.drawio.html 6-4-6）
6、删除二结点的结点（父结点是二结点、兄弟结点是三结点）。（类似 2-3 树的第 4 种情况）
7、删除二结点的结点（父结点是三结点、兄弟结点是三结点）。（类似 2-3 树的第 5 种情况）
8、删除二结点的结点（父结点是四结点、兄弟结点是三结点）。（类似第 6 种情况）
删除结点 =&gt; 父结点少一个子树 =&gt; 兄弟结点可以借一个结点 =&gt; 旋转结点到删除结点的位置。（见图：2-3-4_tree.drawio.html 6-6-6）
另外，还有向左旋转三次的情况（见图：2-3-4_tree.drawio.html 6-10-4），向右旋转三次的处理方式是一样的。
9、删除二结点的结点（父结点是二结点、兄弟结点是四结点）。
删除结点 =&gt; 父结点少一个子树 =&gt; 兄弟结点可以借一个结点 =&gt; 旋转结点到删除结点的位置。（见图：2-3-4_tree.drawio.html 6-8-2）
这种情况，删掉结点之后，自己这个位置就是空的了。也就是父结点变得少一个子树，这会破坏 2-3-4 树的性质。
和上面第 3 种情况不同的是，在第 3 种情况中，兄弟结点是二结点，借不出结点。而这里可以借一个结点过来，把这个子树补上，这样就不破坏 2-3-4 树的性质了。
图里的例子是向左旋转一次的情况，向右旋转一次的处理方式是一样的。
10、删除二结点的结点（父结点是三结点、兄弟结点是四结点）。（类似第 9 种情况）
删除结点 =&gt; 父结点少一个子树 =&gt; 兄弟结点可以借一个结点 =&gt; 旋转结点到删除结点的位置。（见图：2-3-4_tree.drawio.html 6-8-4）
11、删除二结点的结点（父结点是四结点、兄弟结点是四结点）。（类似第 9 种情况）
删除结点 =&gt; 父结点少一个子树 =&gt; 兄弟结点可以借一个结点 =&gt; 旋转结点到删除结点的位置。（见图：2-3-4_tree.drawio.html 6-8-6）
12、删除二结点的结点（父结点是二结点、兄弟结点是二结点、祖父结点是二结点、叔叔结点是二结点）。（类似 2-3 树的第 6 种情况）
13、删除二结点的结点（父结点是二结点、兄弟结点是二结点、祖父结点是三结点、叔叔结点是二结点）。（类似 2-3 树的第 7 种情况）
祖父结点是四结点的处理逻辑是一样的。
14、删除二结点的结点（父结点是二结点、兄弟结点是二结点、祖父结点是三结点、叔叔结点是三结点）。（类似 2-3 树的第 8 种情况）
叔叔结点是四结点的处理逻辑是一样的。
删除的不是叶子结点 这种情况需和平衡二叉树一样，找到中序遍历的前驱结点或者后继结点，把这两个结点互换位置，这个时候要删除的结点会被换到叶子结点的位置，然后再删除。
2-3-4 树转换成红黑树 1、三结点其中一个元素转化为红黑树的红结点，左右哪个元素都可以。四结点中两边的元素转化为红黑树的红结点。 2、拆分三结点和四结点，和父结点连接的一定是黑结点 （见图：2-3-4_tree.drawio.html 12-2） reference（参考） 掌握了2-3-4树也就掌握了红黑树，不信进来看看，建议收藏！ 理解2-3-4树bilibili&ndash;木子喵neko【neko】红黑树/插入【算法编程#11】【neko】红黑树/删除【算法编程#12】]]></content>
  </entry>
  
  <entry>
    <title>2-3 树</title>
    <url>/post/computer-science/data-structure/2-3_tree/</url>
    <categories><category>data-structure(数据结构)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>data-structure(数据结构)</tag>
      <tag>b-tree</tag>
    </tags>
    <content type="html"><![CDATA[资料 2-3_tree.drawio.html 2-3 树 2-3 树就是 3 阶 B-树。 把 2-3 树的三结点拆开，就可以变成红黑树。 2-3 树的性质 1、满足二叉查找树的基本性质。
2、结点可以存放一个元素、两个元素。
假设结点结构从左到右分别为：子树 1、元素 1、子树 2、元素 2、子树 3。 对于存放一个元素的结点，其形态为：子树 1、元素 1、子树 2。 子树 1 存放比 元素 1 小的元素； 子树 2 存放比 元素 1 大的元素。 对于存放两个元素的结点，其形态为：子树 1、元素 1、子树 2、元素 2、子树 3。 子树 1 存放比 元素 1 和 元素 2 都小的元素； 子树 2 存放在 元素 1 和 元素 2 之间的元素； 子树 3 存放比 元素 1 和 元素 2 都大的元素。 3、2-3 树是绝对平衡的二叉查找树，所有叶子结点都在同一层上。从根结点到任意一个叶子结点所经过的结点数是相同的。
2-3 树的插入 下面列举的情况并不一定覆盖所有的场景，但是典型场景都有了，没有提到的场景可以根据典型场景推导。
只上溢不旋转的情况 1、空树。
添加结点 =&gt; 变二结点。（见图：2-3_tree.drawio.html 2-2-2）
2、二结点。
添加结点 =&gt; 变三结点。（见图：2-3_tree.drawio.html 2-2-4）
3、没有父结点的三结点。
添加结点 =&gt; 变四结点 =&gt; 上溢（层数增加）。（见图：2-3_tree.drawio.html 2-4-2）
4、有父结点的三结点（父结点不是三结点）。
添加结点 =&gt; 变四结点 =&gt; 上溢（层数不增加）。（见图：2-3_tree.drawio.html 2-4-4）
这种情况，三结点是父结点哪个子结点，都是一样的处理逻辑，上溢一次。
5、有父结点的三结点（父结点是三结点）。
添加结点 =&gt; 变四结点 =&gt; 上溢（父结点变四结点）=&gt; 父结点上溢（层数增加）。（见图：2-3_tree.drawio.html 2-6）
这种情况，四结点是父结点哪个子结点，都是一样的处理逻辑，上溢两次。
可以通过旋转抵消上溢的情况 1、有父结点的三结点（父结点是三结点、兄弟结点不是三结点）。
添加结点 =&gt; 变四结点 =&gt; 兄弟结点有空位 =&gt; 旋转结点到兄弟结点（抵消上溢，层数不增加）。
这种情况，如果只上溢的话，会上溢两次（自己上溢一次、父结点上溢一次），树的深度增加了，可能影响查询效率。
但是这个时候其实 2-3 树是不满的，兄弟结点是有空位的。这时候就可以通过旋转，重新平衡 2-3 树。
根据 2-3 树有空位的兄弟结点的位置，旋转的情况分为四种，处理方式是差不多的：
向右旋转一次（见图：2-3_tree.drawio.html 4-2-2） 向左旋转一次（见图：2-3_tree.drawio.html 4-2-4） 向右旋转两次（见图：2-3_tree.drawio.html 4-4） 向左旋转两次（无图，参考向右旋转两次的图）。 2、有父结点的三结点（父结点是三结点、兄弟结点是三结点、祖父结点是三结点、叔叔结点不是三结点）。
添加结点 =&gt; 变四结点 =&gt; 父结点和兄弟结点都没有空位，无法旋转，只能上溢（父结点变四结点） =&gt; 叔叔结点有空位 =&gt; 旋转结点到叔叔结点（抵消上溢，层数不增加）。
这种情况，如果只上溢的话，会上溢三次（自己上溢一次、父结点上溢一次、祖父结点上溢一次），树的深度增加了，可能影响查询效率。
但是这个时候其实 2-3 树是不满的，叔叔结点是有空位的。这时候就可以通过旋转，重新平衡 2-3 树。
这里第一次的上溢是避免不了的。上溢之后，重新以父结点为参照，这时就可以看做上面第一种情况。
根据 2-3 树有空位的叔叔结点的位置，旋转的情况分为四种，处理方式是差不多的：
（上溢一次后）向右旋转一次（见图：2-3_tree.drawio.html 4-6-2） （上溢一次后）向左旋转一次（无图，参考向右旋转一次的图） （上溢一次后）向右旋转两次（见图：2-3_tree.drawio.html 4-6-4） （上溢一次后）向左旋转两次（无图，参考向右旋转两次的图）。 2-3 树的删除 下面列举的情况并不一定覆盖所有的场景，但是典型场景都有了，没有提到的场景可以根据典型场景推导。
删除叶子结点 1、删除三结点的结点。
直接删掉就好了，不会破坏 2-3 树的性质。（见图：2-3_tree.drawio.html 6-2）
2、删除二结点的结点（父结点是二结点、兄弟结点是二结点）。
删除结点 =&gt; 父结点少一个子树 =&gt; 父结点下溢（唯一的结点，层次减少） =&gt; 父结点和兄弟结点融合。（见图：2-3_tree.drawio.html 6-4-2）
这种情况，删掉结点之后，自己这个位置就是空的了。也就是父结点变得少一个子树，这会破坏 2-3 树的性质。
处理方式是，就把父结点放到下面一层去，和兄弟结点融合成一个结点，这样就不会破坏 2-3 树的性质了。
图里的例子是父结点的子树 1 被删空了，子树 2 被删空的情况是一样的处理方式。
3、删除二结点的结点（父结点是三结点、兄弟结点都是二结点）。（类似第 2 种情况）
删除结点 =&gt; 父结点少一个子树 =&gt; 父结点下溢（其中一个结点，层次不变） =&gt; 下溢结点和兄弟结点融合。（见图：2-3_tree.drawio.html 6-4-4）
4、删除二结点的结点（父结点是二结点、兄弟结点是三结点）。
删除结点 =&gt; 父结点少一个子树 =&gt; 兄弟结点可以借一个结点 =&gt; 旋转结点到删除结点的位置。（见图：2-3_tree.drawio.html 6-6-2）
这种情况，删掉结点之后，自己这个位置就是空的了。也就是父结点变得少一个子树，这会破坏 2-3 树的性质。
和上面第 2 种情况不同的是，在第 2 种情况中，兄弟结点是二结点，借不出结点。而这里可以借一个结点过来，把这个子树补上，这样就不破坏 2-3 树的性质了。
图里的例子是向左旋转一次的情况，向右旋转一次的处理方式是一样的。
另外，还有向左旋转两次的情况（见图：2-3_tree.drawio.html 6-10-2），向右旋转两次的处理方式是一样的。
5、删除二结点的结点（父结点是三结点、兄弟结点是三结点）。
删除结点 =&gt; 父结点少一个子树 =&gt; 兄弟结点可以借一个结点 =&gt; 旋转结点到删除结点的位置。（见图：2-3_tree.drawio.html 6-6-4）
图里的例子是向左旋转一次的情况，向右旋转一次的处理方式是一样的。
6、删除二结点的结点（父结点是二结点、兄弟结点是二结点、祖父结点是二结点、叔叔结点是二结点）。
删除结点 =&gt; 父结点少一个子树 =&gt; 父结点下溢（父结点和兄弟结点融合） =&gt; 祖父结点少一个子树 =&gt; 祖父结点下溢（唯一的结点，层次减少） =&gt; 祖父结点和叔叔结点融合。（见图：2-3_tree.drawio.html 6-12-2）
这种情况，初始场景类似上面第 2 种情况，解决方案也是类似第 2 种情况的：下溢 + 融合。初始场景处理完之后，重新以父结点为参照，又是类似上面第 2 种情况，再来一遍就好了。
7、删除二结点的结点（父结点是二结点、兄弟结点是二结点、祖父结点是三结点、叔叔结点是二结点）。
删除结点 =&gt; 父结点少一个子树 =&gt; 父结点下溢（父结点和兄弟结点融合） =&gt; 祖父结点少一个子树 =&gt; 祖父结点下溢（其中一个结点，层次不变） =&gt; 下溢结点和叔叔结点融合。（见图：2-3_tree.drawio.html 6-12-4）
这种情况，初始场景类似上面第 2 种情况，解决方案也是类似第 2 种情况的：下溢 + 融合。初始场景处理完之后，重新以父结点为参照，类似上面第 3 种情况，解决方案也是类似第 3 种情况的：下溢 + 融合。
8、删除二结点的结点（父结点是二结点、兄弟结点是二结点、祖父结点是三结点、叔叔结点是三结点）。
删除结点 =&gt; 父结点少一个子树 =&gt; 父结点下溢（父结点和兄弟结点融合） =&gt; 祖父结点少一个子树 =&gt; 叔叔结点可以借一个结点 =&gt; 旋转结点到祖父结点的删除结点的位置。（见图：2-3_tree.drawio.html 6-14）
这种情况，初始场景类似上面第 2 种情况，解决方案也是类似第 2 种情况的：下溢 + 融合。初始场景处理完之后，重新以父结点为参照，类似上面第 4 种情况，解决方案也是类似第 4 种情况的：旋转。
删除的不是叶子结点 这种情况需和平衡二叉树一样，找到中序遍历的前驱结点或者后继结点，把这两个结点互换位置，这个时候要删除的结点会被换到叶子结点的位置，然后再删除。
2-3 树转换成红黑树 1、三结点其中一个元素转化为红黑树的红结点，左右哪个元素都可以。 2、拆分三结点，和父结点连接的一定是黑结点。 （见图：2-3_tree.drawio.html 10-2） reference（参考） 二三树、B树(多路平衡查找树)、B+树二叉树，红黑树，23树，B树，B+树2-3树的删除bilibili&ndash;天羽神奈2-3树的定义与搜索图解2-3树插入节点方法2-3树删除节点图解及示例]]></content>
  </entry>
  
  <entry>
    <title>Virtual Memory（虚拟内存）</title>
    <url>/post/computer-science/operating-system/memory/virtual_memory/</url>
    <categories><category>operating-system(操作系统)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>operating-system(操作系统)</tag>
      <tag>memory(内存)</tag>
    </tags>
    <content type="html"><![CDATA[资料 virtual_memory.drawio.html 虚拟内存涉及的知识点（笔记里不一定有） virtual memory（虚拟内存） memory protection（内存保护） dynamic memory allocation（动态分配内存） virtual memory address（虚拟内存地址） physical memory address（物理内存地址） memory management unit（MMU、内存管理单元） segmented memory management（段式管理） segment（段） segment table（段表） memory fragmentation（内存碎片） page memory management（页式管理） page（页） page table（页表） missing page interruption（缺页中断） multi-level page table（多级页表） Translation Lookaside Buffer（TLB、页表缓存） segmented paged memory management（段页式管理） 虚拟内存 单片机的 CPU 可以直接操作物理内存地址。但是，在这种情况下是无法同时运行多个程序的。
如果多个程序都操作了同一块物理内存，那么他们就可能会互相影响，最终可能导致程序崩溃。
操作系统使用虚拟内存将进程与物理内存进行隔离，为每个进程分配独立的一套虚拟内存地址，这样每个进程就互不干涉。
虚拟内存地址（virtual memory address）：程序使用的内存地址 物理内存地址（physical memory address）：硬件里面的内存地址 虚拟内存地址和物理内存地址的映射由操作系统为进程提供，进程不需要管数据到底存在哪块物理内存上。
进程使用的虚拟地址，会通过 CPU 芯片中的内存管理单元（Memory Management Unit、MMU）的映射关系，来转换变成物理地址，然后再通过物理地址访问内存。
另外，虚拟内存可以使得进程的运行内存超过物理内存大小。因为程序运行符合局部性原理，不是所有的内存都是同时在使用的。
操作系统主要有两种管理内存的方式：内存分段（Segmentation）和内存分页（Paging）。
段式管理 程序由若干个逻辑分段组成，如：代码分段、数据分段、栈段、堆段等。（见图：virtual_memory.drawio.html 2-2）
虚拟地址由段选择子和段内偏移量两部分组成。
段选择子保存在段寄存器。段选择子里的段号用作段表的索引。段表保存段基地址、段界限和特权等级等。（见图：virtual_memory.drawio.html 2-4）
虚拟地址中的段内偏移量应该位于 0 和段界限之间，如果段内偏移量是合法的，就将段基地址加上段内偏移量得到物理内存地址。
段式管理的不足 段式管理的不足主要有两点：1、内存碎片；2、内存交换的效率低。
内存碎片有两种：
外部碎片：多个不连续的小物理内存，导致新的程序由于内存不够无法被装载。 内部碎片：程序所有的数据都被装载到了物理内存，但是这个程序有部分的数据可能并不是很常使用，这会导致内存的浪费。 内存交换可以解决外部碎片的问题。可以把程序占用的内存写到硬盘上，然后再从硬盘上读回到内存。在 Linux 中，内存交换空间（Swap 空间），这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。
对于多进程的系统来说，用分段的方式，很容易产生内存碎片。内存交换又受硬盘速度限制，效率低。
页式管理 整个虚拟内存空间和物理内存空间都被切成一个个固定尺寸大小的内存空间（内存页）。
分页可以让内存交换时，读写的数据少一点。在 Linux 中，每一页的大小为 4KB。
虚拟地址与物理地址之间通过页表来映射。（见图：virtual_memory.drawio.html 4-2）
页表存储在内存里，每个进程都有自己的页表。（见图：virtual_memory.drawio.html 4-4）
从页表的性质来看，保存在内存中的页表承担的职责是将虚拟地址翻译成物理地址，所以页表一定要覆盖全部虚拟地址空间。内存管理单元负责将虚拟内存地址转换成物理地址。
虚拟地址分为两部分：页号和页内偏移。页号作为页表的索引，页表包含物理页每页所在物理内存的基地址，这个基地址与页内偏移的组合就形成了物理内存地址。
页表里的页表项中除了物理地址之外，还有一些标记属性的数据，比如控制一个页的读写权限，标记该页是否存在等。在内存访问方面，操作系统提供了更好的安全性。
对于一个内存地址转换，分三个步骤：
1、把虚拟内存地址，切分成页号和偏移量。 2、根据页号，从页表里面，查询对应的物理页号。 3、拿物理页号，加上前面的偏移量，就得到了物理内存地址。 当进程访问的虚拟地址在页表中查不到时，系统会产生一个缺页异常。然后进入系统内核空间，分配物理内存，更新进程页表，最后再返回用户空间，恢复进程的运行。
页式管理的优点 由于内存空间都是预先划分好的，所以释放的内存都是以页为单位释放的，不会产生无法给进程使用的小内存。
如果内存空间不够，操作系统会把其他正在运行的进程中的最近没被使用的内存页面给释放掉，也就是暂时写在硬盘上，称为换出（Swap Out）。
一旦需要的时候，再加载进来，称为换入（Swap In）。所以，一次性写入磁盘的也只有少数的一个页或者几个页，不会花太多时间，内存交换的效率就相对比较高。
分页的方式使得在加载程序的时候，不需要一次性都把程序加载到物理内存中。只有在程序运行中，需要用到对应虚拟内存页里面的指令和数据时，再加载到物理内存里面去。
简单分页的缺陷 简单分页有空间上的缺陷。
在 32 位的环境下，虚拟地址空间共有 4GB（2^32）。假设一个页的大小是 4KB（2^12），每个页表项 4 个字节。
那么 4GB 空间就需要 100 万（2^20）个页，大概 4MB 来存储页表。每个进程都有自己的虚拟地址空间（页表）。那么，100 个进程就需要 400MB 来存储页表。
多级页表（Multi-Level Page Table）可以解决简单分页的空间上的缺陷。
多级页表 多级页表把 100 多万个页表项再分页，用一个一级页表 4KB 表示全部的虚拟地址空间，一级页表一共有 1024 个页表项。每个一级页表项对应一个二级页表，每个二级页表也有 1024 个页表项。
（见图：virtual_memory.drawio.html 4-6）
二级页表可以在需要时进行创建。每个进程都有 4GB 的虚拟地址空间，而对于大多数程序来说，其使用到的空间远未达到 4GB，所以大多数的页表项都是空的。这样就可以节省下很多的空间。
多级页表解决了空间上的问题，但是转换工序带来了时间上的开销。
对于 64 位的系统，多级页表变成了四级目录，分别是：
PGD（page global directory、全局页目录项） PUD（page upper directory、上层页目录项） PMD（page middle directory、中间页目录项） PTE（page table entry、页表项）。 页表缓存 根据局部性原理，程序在一段时间内的执行会集中在整个程序的其中一个部分。相应地，执行所访问的存储空间也局限于某个内存区域。
利用这一特性，可以在 CPU 里放一块缓存，用来存放最常访问的页表项。这个缓存就是页表缓存（Translation Lookaside Buffer、TLB、快表、转址旁路缓存等）
段页式管理 内存分段和内存分页可以组合起来在同一个系统中使用。
先将程序划分为多个逻辑段，接着再把每个段划分为多个页。地址结构由段号、段内页号、页内位移三部分组成。
每个程序一张段表，每个段一张页表，段表中的地址是页表的起始地址，而页表中的地址则是物理页号。
（见图：virtual_memory.drawio.html 6-2）
段页式地址变换中要得到物理地址须经过三次内存访问：
访问段表，得到页表起始地址 访问页表，得到物理页号 将物理页号与页内位移组合，得到物理地址 可用软、硬件相结合的方法实现，虽然增加了硬件成本和系统开销，但提高了内存的利用率。
reference（参考） Crash Course Computer Science（计算机科学速成课） bilibiliCrashCourse 字幕组Youtube 原视频小林coding图解系统]]></content>
  </entry>
  
  <entry>
    <title>AVL-Tree（平衡二叉树）</title>
    <url>/post/computer-science/data-structure/avl_tree/</url>
    <categories><category>data-structure(数据结构)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>data-structure(数据结构)</tag>
      <tag>binary-search-tree(二叉查找树)</tag>
    </tags>
    <content type="html"><![CDATA[资料 {demo-c}/data-structure/balanced_binary_tree.c balanced_binary_tree.drawio.html 平衡二叉树 AVL-Tree（balanced binary tree、平衡二叉树）是一种特殊的二叉排序树。
平衡二叉树的性质 1、满足二叉查找树的基本性质。 2、每个结点的左右子树的高度之差的绝对值（平衡因子）最多为 1。 平衡二叉树的插入 左旋和右旋 （见图：balanced_binary_tree.drawio.html 2-2）
4 种需要平衡的场景 1、LL 型
LL 型，直接右旋 x 结点。（见图：balanced_binary_tree.drawio.html 4-2）
2、LR 型
LR 型，直接右旋 x 结点，依然不平衡。（见图：balanced_binary_tree.drawio.html 4-4-2）
需要先左旋 y 结点，再右旋 x 结点。（见图：balanced_binary_tree.drawio.html 4-4-4）
3、RR 型
RR 型，直接左旋 x 结点。（见图：balanced_binary_tree.drawio.html 6-2）
4、RL 型
RL 型，直接左旋 x 结点，依然不平衡。（见图：balanced_binary_tree.drawio.html 6-4-2）
需要先右旋 y 结点，再左旋 x 结点。（见图：balanced_binary_tree.drawio.html 6-4-4）
平衡二叉树的删除 平衡二叉树的删除和二插叉查找树的删除步骤是差不多的。
区别在于，平衡二叉树删除结点之后，需要依次向上检查每一个结点是否平衡。
reference（参考） 平衡二叉树（AVL树）及C语言实现]]></content>
  </entry>
  
  <entry>
    <title>Linux memory（Linux 内存）</title>
    <url>/post/computer-science/operating-system/memory/linux_memory/</url>
    <categories><category>operating-system(操作系统)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>operating-system(操作系统)</tag>
      <tag>memory(内存)</tag>
    </tags>
    <content type="html"><![CDATA[资料 linux_memory.drawio.html 页式管理 Linux 内存主要采用的是页式内存管理，但是由于 Intel 处理器的发展史，Linux 无法避免分段管理。
因为操作系统必须按照硬件结构设计，所以 Linux 的内核必须服从 CPU 的硬件结构。
虚拟地址空间 在 Linux 中，虚拟地址空间被分为内核空间和用户空间。
32 位系统，内核空间占用 1G，位于最高处，剩下的 3G 是用户空间。 （见图：linux_memory.drawio.html 2-2） 64 位系统，内核空间和用户空间都是 128T，分别占据整个内存空间的最高和最低处，剩下的中间部分是未定义的。 （见图：linux_memory.drawio.html 2-4） 进程在用户态时，只能访问用户空间内存。只有进入内核态后，才可以访问内核空间的内存。
虽然每个进程都各自有独立的虚拟内存，但是虚拟内存中的内核地址，关联的是相同的物理内存。
这样，进程切换到内核态后，就可以很方便地访问内核空间内存。
用户空间分布 32 位系统的用户空间分布的情况：
程序文件段（.text），包括二进制可执行代码。 已初始化数据段（.data），包括静态常量。 未初始化数据段（.bss），包括未初始化的静态变量。 堆段，包括动态分配的内存，从低地址开始向上增长。 文件映射段，包括动态库、共享内存等，从低地址开始向上增长。 栈段，包括局部变量和函数调用的上下文等。栈的大小是固定的，一般是 8 MB。当然系统也提供了参数，以便自定义大小. （见图：linux_memory.drawio.html 2-6） 在这 6 个内存段中，堆和文件映射段的内存是动态分配的。
比如，使用 C 标准库的 malloc() 或者 mmap()，就可以分别在堆和文件映射段动态分配内存。
malloc malloc() 不是系统调用，而是 C 库里的函数，用于动态分配内存。
malloc 申请内存的时候，会有两种方式向操作系统申请堆内存:
通过 brk() 系统调用从堆分配内存，通过 brk 将堆顶指针向高地址移动，获得新的内存空间。 （见图：linux_memory.drawio.html 4-2） 通过 mmap() 系统调用在文件映射区域分配内存，也就是从文件映射区拿一块内存。 （见图：linux_memory.drawio.html 4-4） malloc 源码默认定义了一个阈值：如果用户分配的内存小于 128 KB，则使用 brk；如果用户分配的内存大于 128 KB，则使用 mmap。
分类内存采用两种方式的原因有两个：1、避免堆内存碎片；2、避免频繁的进行系统调用。
malloc 分配的是虚拟内存。如果分配后的虚拟内存没有被访问的话，是不会将虚拟内存不会映射到物理内存，这样就不会占用物理内存了。
只有在访问已分配的虚拟地址空间的时候，操作系统通过查找页表，发现虚拟内存对应的页没有在物理内存中，就会触发缺页中断。然后操作系统会建立虚拟内存和物理内存之间的映射关系。
堆内存碎片 假设，先 malloc 2+2+2 K 的内存，然后 free 2+2 K。因为通过 brk 从堆空间分配的内存，并不会归还给操作系统。所以，这时 malloc 内存池就有 4K 的空闲。
如果这个时候 malloc 小于 4K ，就可以直接从内存池分配，如果 malloc 大于 4K，就必须再从堆上申请。
如果程序后来的 malloc 都大于 4K ，那么这个空闲的 4K 就变成了无法使用到的内存碎片。（见图：linux_memory.drawio.html 4-6）
生产环境的程序通常会长时间运行，所以这样的碎片有可能会越积越多，尤其是如果频繁的 malloc 和 free 小块内存。
malloc 在分配内存的时候，并不是按用户预期申请的字节数来分配内存空间大小，而是会预分配更大的空间作为内存池。具体会预分配多大的空间，跟 malloc 使用的内存管理器有关系。
内存池 brk 和 mmap 都是系统调用。执行系统调用是要进入内核态的，然后在回到用户态，运行态的切换会耗费不少时间。 如果都用 mmap 来分配内存，等于每次都要执行系统调用。
另外，因为 mmap 分配的内存每次释放的时候，都会归还给操作系统，于是每次 mmap 分配的虚拟地址都是缺页状态的，然后在第一次访问该虚拟地址的时候，就会触发缺页中断。
频繁通过 mmap 分配的内存话，不仅每次都会发生运行态的切换，还会发生缺页中断（在第一次访问虚拟地址后），这样会导致 CPU 消耗较大。
为了改进这两个问题，malloc 通过 brk 系统调用在堆空间申请内存的时候，由于堆空间是连续的，所以直接预分配更大的内存来作为内存池，当内存释放的时候，就缓存在内存池中。
等下次在申请内存的时候，就直接从内存池取出对应的内存块就行了，而且可能这个内存块的虚拟地址与物理地址的映射关系还存在，这样不仅减少了系统调用的次数，也减少了缺页中断的次数，这将大大降低 CPU 的消耗。
/proc/{pid}/maps 程序运行后可以通过 /proc/{pid}/maps 文件查看进程的内存分布情况。
02dc7000-02de8000 rw-p 00000000 00:00 0 [heap] 02de8000 - 02dc7000 = 21000，也就是在 heap（堆上）分配了 21000 字节。如果 malloc 是通过 mmap 分配的，右边显示 [heap] 的那个位置就啥都没有。
需要注意的是，程序中返回的地址应该是 02dc7010 而不是 02dc7000。前面的 16 字节（0x10）是内存块的头信息。内存块头信息在 《Linux\Unix 系统编程手册》 第 7 章里有提到。
图片：linux-memory.drawio/6-2、内存块头信息 free 如果 malloc 通过 brk 方式申请的内存，free 内存后，堆内存还存在。这是因为内存会被放入 malloc 的内存池里，当进程再次申请内存时就可以直接复用。当进程退出后，操作系统就会回收进程的所有资源。
如果 malloc 通过 mmap 方式申请的内存，free 释放内存后就会立刻归还给操作系统。也就是，如果是通过 brk 方式申请的内存，free 后，依然可以在 /proc/{pid}/maps 文件里看到，因为内存还没有被归还给操作系统。如果是通过 mmap 方式申请的内存，free 后，就看不到了。
free 函数使用的时候只传入一个内存地址，没有传入内存大小。内存大小被存在了这个指针指向的内存块的内存块的头信息里。
reference（参考） Crash Course Computer Science（计算机科学速成课） bilibiliCrashCourse 字幕组Youtube 原视频小林coding图解系统Linux 文档malloc(3) - allocate and free dynamic memoryproc(5) - process information pseudo-filesystem《Linux\Unix 系统编程手册》 第 7 章 ]]></content>
  </entry>
  
  <entry>
    <title>使用 Jekyll 主题</title>
    <url>/post/computer-science/application/jekyll/jekyll-theme/</url>
    <categories><category>application(应用)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>Ruby</tag>
      <tag>Jekyll</tag>
      <tag>GitHub Pages</tag>
    </tags>
    <content type="html"><![CDATA[环境 Windows 11 家庭版 Ruby 3.1.2 RubyGems 3.3.7 Jekyll 4.2.2 jekyll-TeXt-theme Github：https://github.com/kitian616/jekyll-TeXt-theme官方文档：https://tianqi.name/jekyll-TeXt-theme/第 1 步，从 Github 上把项目下载下来。
第 2 步，安装 Ruby 依赖包。
&gt; bundle install --path vendor/bundle[DEPRECATED] The `--path` flag is deprecated because it relies on being remembered across bundler invocations, which bundler will no longer do in future versions. Instead please use `bundle config set --local path &#39;vendor/bundle&#39;`, and stop using this flag一大堆输出。。。Using jekyll-text-theme 2.2.6 from source at `.`Bundle complete! 3 Gemfile dependencies, 41 gems now installed.Bundled gems are installed into `./vendor/bundle`Post-install message from html-pipeline:-------------------------------------------------Thank you for installing html-pipeline!You must bundle Filter gem dependencies.See html-pipeline README.md for more details.https://github.com/jch/html-pipeline#dependencies------------------------------------------------- 安装完成后，可以使用 Jekyll 集成的那个开发用的服务器，然后使用浏览器在本地进行预览。
这里同样会遇到 webrick 无法加载的那个异常情况，解决方法是一样的。
jekyll-theme-chirpy Github：https://github.com/cotes2020/jekyll-theme-chirpy官方文档（同时也是个 Demo）：https://chirpy.cotes.page/个人感觉，这个主题比上面那个正在用的要好看不少。
但是无奈，按照官方文档走流程的时候，在发布流程的 Github Action 步骤卡住了。而且没有找到解决方案，遂遗憾放弃。
]]></content>
  </entry>
  
  <entry>
    <title>使用 Jekyll 和 GitHub Pages 搭建站点</title>
    <url>/post/computer-science/application/jekyll/jekyll-start/</url>
    <categories><category>application(应用)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>Ruby</tag>
      <tag>Jekyll</tag>
      <tag>GitHub Pages</tag>
    </tags>
    <content type="html"><![CDATA[环境 Windows 11 家庭版 Ruby 3.1.2 RubyGems 3.3.7 Jekyll 4.2.2 安装 Jekyll 在官方文档中有详细的安装 Jekyll 的流程说明。
Jekyll 官方文档的中文版：http://jekyllcn.com/。
第 1 步，安装 Ruby。
Ruby 官方网站的中文版：http://www.ruby-lang.org/zh_cn/。
进入 Ruby 下载页面：http://www.ruby-lang.org/zh_cn/downloads/下载页面的文档指出，Windows 可以用 RubyInstaller：https://rubyinstaller.org/。
安装 Ruby 的方法
每个流行的平台都有多种工具可用于安装 Ruby：
Linux/UNIX 平台，可以使用第三方工具（如 rbenv 或 RVM）或使用系统中的包管理系统。 macOS 平台，可以使用第三方工具（如 rbenv 或 RVM）。 Windows 平台，可以使用 RubyInstaller。 进入 RubyInstaller 下载页面，页面右侧的说明会告诉你该下哪一个版本的。
Which version to download?
If you don’t know what version to install and you’re getting started with Ruby, we recommend that you use the Ruby+Devkit 3.1.X (x64) installer.
下载 Ruby+Devkit 3.1.2-1 (x64) 完成后，双击运行，启动 Ruby 安装向导，然后一路 next 即可。
记得勾选 Add Ruby executables to your PATH，把 Ruby 的运行目录添加到 Windows 的环境变量 PATH 里，要不然在命令行窗口（CMD）里不能直接用命令。
安装过程中，安装向导可能会卡住，等一会就行。RubyInstaller 会把 Ruby 和 RubyGems 一起装了。RubyGems 是一个 Ruby 程序，用来管理 Ruby 包的。
安装完成后，可以在命令行里使用命令输出一下版本信息，看看安装是否成功。
&gt; ruby -vruby 3.1.2p20 (2022-04-12 revision 4491bb740a) [x64-mingw-ucrt] &gt; gem -v3.3.7 第 2 步，安装 Jekyll。
使用 RubyGems 安装 Jekyll。
&gt; gem install jekyll一大堆输出。。。Done installing documentation for unicode-display_width, terminal-table, safe_yaml, rouge, forwardable-extended, pathutil, mercenary, liquid, kramdown, kramdown-parser-gfm, ffi, rb-inotify, rb-fsevent, listen, jekyll-watch, sassc, jekyll-sass-converter, concurrent-ruby, i18n, http_parser.rb, eventmachine, em-websocket, colorator, public_suffix, addressable, jekyll after 24 seconds26 gems installed 安装过程需要几分钟，等它装完即可。如果长时间没有反应，可以在命令行按一下回车，不排除可能是 Windows 命令行卡住了没输出信息。
安装完成后，可以在命令行里使用命令输出一下版本信息，看看安装是否成功。
&gt; jekyll -vjekyll 4.2.2 生成模板 使用 jekyll 生成模板。
这里是在 D 盘的 workspace/github.io 目录里生成模板。
&gt; jekyll new github.ioRunning bundle install in D:/workspace/github.io...一大堆输出。。。New jekyll site installed in D:/workspace/github.io. Bundler 可以认为是一个针对项目的包管理程序。它通过项目目录下的 Gemfile 文件来管理项目依赖。Bundler 在安装依赖时，会使用 RubyGems。
开发服务器 Jekyll 集成了一个开发用的服务器，可以使用浏览器在本地进行预览。
&gt; jekyll serveConfiguration file: D:/workspace/github.io/_config.ymlSource: D:/workspace/github.ioDestination: D:/workspace/github.io/_siteIncremental build: disabled. Enable with --incrementalGenerating...Jekyll Feed: Generating feed for postsdone in 0.808 seconds.Please add the following to your Gemfile to avoid polling for changes:gem &#39;wdm&#39;, &#39;&gt;= 0.1.0&#39; if Gem.win_platform?Auto-regeneration: enabled for &#39;D:/workspace/github.io&#39;Server address: http://127.0.0.1:4000/Server running... press ctrl-c to stop. 正常情况应该是输出上面的内容，然后就用浏览器访问 http://localhost:4000/ 查看博客了。
异常情况 &gt; jekyll serveConfiguration file: D:/workspace/github.io/_config.ymlSource: D:/workspace/github.ioDestination: D:/workspace/github.io/_siteIncremental build: disabled. Enable with --incrementalGenerating...Jekyll Feed: Generating feed for postsdone in 0.827 seconds.Please add the following to your Gemfile to avoid polling for changes:gem &#39;wdm&#39;, &#39;&gt;= 0.1.0&#39; if Gem.win_platform?Auto-regeneration: enabled for &#39;D:/workspace/github.io&#39;------------------------------------------------Jekyll 4.2.2 Please append `--trace` to the `serve` commandfor any additional information or backtrace.------------------------------------------------C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve/servlet.rb:3:in `require&#39;: cannot load such file -- webrick (LoadError)from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve/servlet.rb:3:in `&lt;top (required)&gt;&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:179:in `require_relative&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:179:in `setup&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:100:in `process&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `block in process_with_graceful_fail&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `each&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `process_with_graceful_fail&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:86:in `block (2 levels) in init_with_program&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `block in execute&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `each&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `execute&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/program.rb:44:in `go&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary.rb:21:in `program&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/exe/jekyll:15:in `&lt;top (required)&gt;&#39;from C:/Ruby31-x64/bin/jekyll:32:in `load&#39;from C:/Ruby31-x64/bin/jekyll:32:in `&lt;main&gt;&#39; 输出的信息提示使用 --trace 参数，看看执行过程中发生了什么。但是实际上下 1 行已经提示了，webrick 无法加载。
------------------------------------------------Jekyll 4.2.2 Please append `--trace` to the `serve` commandfor any additional information or backtrace.------------------------------------------------C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve/servlet.rb:3:in `require&#39;: cannot load such file -- webrick (LoadError) 这里用一下 --trace 参数，输出没啥变化，依然提示 webrick 无法加载。
&gt; jekyll serve --traceConfiguration file: D:/workspace/github.io/_config.ymlSource: D:/workspace/github.ioDestination: D:/workspace/github.io/_siteIncremental build: disabled. Enable with --incrementalGenerating...Jekyll Feed: Generating feed for postsdone in 0.747 seconds.Please add the following to your Gemfile to avoid polling for changes:gem &#39;wdm&#39;, &#39;&gt;= 0.1.0&#39; if Gem.win_platform?Auto-regeneration: enabled for &#39;D:/workspace/github.io&#39;C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve/servlet.rb:3:in `require&#39;: cannot load such file -- webrick (LoadError)from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve/servlet.rb:3:in `&lt;top (required)&gt;&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:179:in `require_relative&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:179:in `setup&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:100:in `process&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `block in process_with_graceful_fail&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `each&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/command.rb:91:in `process_with_graceful_fail&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/lib/jekyll/commands/serve.rb:86:in `block (2 levels) in init_with_program&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `block in execute&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `each&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/command.rb:221:in `execute&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary/program.rb:44:in `go&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/mercenary-0.4.0/lib/mercenary.rb:21:in `program&#39;from C:/Ruby31-x64/lib/ruby/gems/3.1.0/gems/jekyll-4.2.2/exe/jekyll:15:in `&lt;top (required)&gt;&#39;from C:/Ruby31-x64/bin/jekyll:32:in `load&#39;from C:/Ruby31-x64/bin/jekyll:32:in `&lt;main&gt;&#39; 这时可以回到上面使用 jekyll 生成模板的地方，从输出的信息中可以发现 Bundler 并没有安装 webrick。所以这里手动执行命令安装 webrick。
&gt; bundle add webrickFetching gem metadata from https://rubygems.org/..........Resolving dependencies...Fetching gem metadata from https://rubygems.org/..........Resolving dependencies... 等待安装完成，应该就可以使用 jekyll serve 命令了。
推送项目到 GitHub Pages GitHub Pages 官方文档：https://pages.github.com/按照要求建一个名字叫 {username}.github.io 仓库，然后把项目推上去就行了。
然后就可以通过 https://{username}.github.io 访问了。
]]></content>
  </entry>
  
  <entry>
    <title>BT 种子和磁力链接</title>
    <url>/post/computer-science/protocol/bit-torrent/</url>
    <categories><category>protocol(协议)</category>
    </categories>
    <tags>
      <tag>computer-science(计算机科学)</tag>
      <tag>protocol(协议)</tag>
    </tags>
    <content type="html"><![CDATA[BT 种子 BT 种子，实际上指的是由 BitTorrent 协议所生成的一个包含资源信息的文件。
与传统的网络传输协议不同，BitTorrent 协议是一种以 P2P（peer-to-peer、用户对用户）模式为主的资源分享协议。采用的是一种去中心化的思想，不需要一个专门的文件发布者或者发布平台。
从理论上来说，一个 BT 种子只要发布了，种子所包含的资源就永远存在于互联网上。
平常所使用的 HTTP、FTP 等协议需要一个中心发布者在网络上发布文件，即一种点对多的模式。当然，如果中心发布者由于某种原因被封了或者发布者删除了资源，那么就无法下载资源了。
BitTorrent BitTorrent 协议的思想是将一个文件划分为大小相等的 n 块，每块大小必须为 2 的整数次方。
例如一个 100M 的文件，按照每块 1024kb 的大小被分为 100 个小块，每块中包含索引信息和 Hash 值，而我们的下载过程实际上就是块的交换过程。
BitTorrent 协议的资源发布者会根据要求，制作一个包含资源下载信息，例如 Tracker 服务器地址、文件大小、文件名、块文件大小等信息的 .torrent 文件，这个过程也就是平时说的做种。
如果要下载 BT 资源，首先要得到对应的 .torrent 文件，然后用专门的下载软件，例如 BitComet（比特彗星），下载过程大概为：
1、读取 .torrent 文件信息，载入内存。 2、得到文件内的 Tracker 地址，连接 Tracker 服务器。 3、Tracker 服务器回应下载请求，记录你的 IP 并告知其它下载者的 IP 地址。 4、你与其他在线的下载者连接，交换各自没有的块。 5、验证得到的块信息，若不同，则需要重新下载。 磁力链接 由上文可以看出，Tracker 是很重要的一个东西。一但 Tracker 服务器被封，就无法进行下载了。由此，Magnet URI scheme（磁力链接）诞生了。
磁力链接，是对等网络中进行信息检索和下载文档的电脑程序。和基于位置连接的统一资源定位符不同，磁力链接是基于 metadata（元数据）文件内容，属于统一资源名称。
也就是说，磁力链接不基于文档的IP地址或定位符，而是在分布式数据库中，通过散列函数值来识别、搜索来下载文档。
因为不依赖一个处于启动状态的主机来下载文档，所以特别适用没有中心服务器的对等网络。
磁力链接利用 DHT（distributed hash table、分布式哈希表）和 PEX（peer exchange、节点信息交换）实现了资源的随意传播，根本无法禁止。
磁力链接下载的本质是将每一个人都变为 Tracker 服务器，将资源与下载者对应起来，每位下载者保存部分信息。这样，在下载资源时，只需寻找拥有所需资源的下载者。
简单理解就是，A 认识 B，B 认识 C，C 认识 D 和 E。如果 A 想认识 E，就可以通过 B 和 C 的介绍来认识 D，不需要 A 一个个去寻找 E。
magnet:?xt=urn:btih:xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 上面是一个常见的磁力链接。
magnet：为协议名。 xt：exact topic，资源定位点。 urn：Uniform Resource Name，资源名。 btih：BitTorrent info hash，表示种子散列函数。 最主要的就是 btih 后面唯一的一串 16 进制的数字。 图种 图种就是把包含 BT 种子的压缩文件隐藏在图片中。
下面的操作是在 windows 11 系统环境下操作的。
需要准备一张图片 1.jpg 和一个压缩文件 2.rar。然后新建一个 .bat 后缀的批处理文件，把下面的代码放进去。
1 copy /b 1.jpg+2.rar 3.jpg copy /b 是一个基础的 DOS 命令，作用是合并文件。
把图片、压缩文件、批处理文件放在同一个目录。然后执行批处理文件，之心完成后就会得到一张图片 3.jpg。
这个图片实际上同时文件含了图片和压缩文件。如果把图片 3.jpg 的后缀名改成 .rar，这个时候图片就变成了压缩文件。
这个压缩文件是可以解压的，压缩文件的内容就是 2.rar 的内容。
]]></content>
  </entry>
  
  <entry>
    <title>站点示例</title>
    <url>/flinks.html</url>
    <categories>
    </categories>
    <tags>
    </tags>
    <content type="html"><![CDATA[如想要交换友情链接，请在评论区留下你的站点信息，格式参考如下：
名称： NexT 主题 说明： 保持简单的易用性和强大的功能。 站标： https://hugo-next.eu.org/imgs/hugo_next_avatar.png网址： https://hugo-next.eu.org]]></content>
  </entry>
  
</search>