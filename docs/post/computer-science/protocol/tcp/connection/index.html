<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.103.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="TCP 连接"><meta itemprop=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=keywords content="computer-science(计算机科学),protocol(协议),tcp"><meta property="og:type" content="article"><meta property="og:title" content="TCP 连接"><meta property="og:description" content><meta property="og:image" content="/image/pid49256268.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/computer-science/protocol/tcp/connection/"><meta property="og:site_name" content="帕里特档案馆"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="西柊慧音"><meta property="article:published_time" content="2022-05-02 08:00:00 +0800 CST"><meta property="article:modified_time" content="2022-05-02 08:00:00 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.4da9279b6033ade10d67092d7bfb660265f9fa46c40974f17b13bfe235396546.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"connection","permalink":"/post/computer-science/protocol/tcp/connection/","title":"TCP 连接","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>TCP 连接 - 帕里特档案馆</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>帕里特档案馆</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>重建中</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>111</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#连接>连接</a><ul><li><a href=#连接数>连接数</a></li><li><a href=#保活机制>保活机制</a></li><li><a href=#fast-open>Fast Open</a></li><li><a href=#查看-tcp-连接状态>查看 TCP 连接状态</a></li></ul></li><li><a href=#三次握手>三次握手</a><ul><li><a href=#第一次握手>第一次握手</a></li><li><a href=#第二次握手>第二次握手</a></li><li><a href=#第三次握手>第三次握手</a></li><li><a href=#为什么需要三次握手>为什么需要三次握手</a></li></ul></li><li><a href=#三次握手在内核中的流程>三次握手在内核中的流程</a><ul><li><a href=#半连接队列和全连接队列>半连接队列和全连接队列</a></li><li><a href=#syn-攻击>SYN 攻击</a></li></ul></li><li><a href=#关闭连接>关闭连接</a></li><li><a href=#四次挥手>四次挥手</a><ul><li><a href=#第一次挥手>第一次挥手</a></li><li><a href=#第二次挥手>第二次挥手</a></li><li><a href=#第二次挥手的优化>第二次挥手的优化</a></li><li><a href=#第三次挥手>第三次挥手</a></li><li><a href=#第四次挥手>第四次挥手</a></li><li><a href=#为什么要有-time_wait-状态>为什么要有 time_wait 状态</a></li><li><a href=#为什么-time_wait-等待-2-msl>为什么 time_wait 等待 2 MSL</a></li><li><a href=#处于-time_wait-状态的连接过多会造成的问题>处于 time_wait 状态的连接过多会造成的问题</a></li><li><a href=#解决处于-time_wait-状态的连接过多的方案>解决处于 time_wait 状态的连接过多的方案</a></li><li><a href=#双方同时关闭>双方同时关闭</a></li></ul></li><li><a href=#参考>参考</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=西柊慧音 src=/imgs/img-lazy-loading.gif data-src=/image/pid49256268.jpg><p class=site-author-name itemprop=name>西柊慧音</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>111</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>19</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>67</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/KelipuTe title="Github → https://github.com/KelipuTe" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=xhy_1365@sina.com title="E-Mail → xhy_1365@sina.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>E-Mail</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/computer-science/protocol/tcp/connection/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=name content="西柊慧音"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="西柊慧音"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="TCP 连接"><meta itemprop=description content="TCP 连接"></span><header class=post-header><h1 class=post-title itemprop="name headline">TCP 连接</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2022-05-02 08:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2022-05-02 08:00:00 +0800 CST">2022-05-02</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/protocol%E5%8D%8F%E8%AE%AE itemprop=url rel=index><span itemprop=name>protocol(协议)</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>5262</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>11分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/post/computer-science/protocol/tcp/connection/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h3 id=连接>连接</h3><p>连接一定是一对一的、唯一的。连接的唯一性由 TCP 四元组（源地址、源端口号、目标地址、目标端口号）保证。源地址、目标地址在 IP 报文中，源端口号、目标端口号在 TCP 报文中。</p><p>建立一个 TCP 连接需要三个信息的共识：由 IP 地址和端口号组成的 Socket、序列号、窗口大小。</p><h4 id=连接数>连接数</h4><p>$最大连接数 = 端 IP 数 \times 端端口数$</p><p>对于 IPv4 来说：$端 IP 数 = 2^{32}$、$端端口数 = 2^{16}$。但是，端最大并发连接数远不能达到理论上限。</p><ul><li>1、socket 文件也是文件，受系统对文件描述符的限制。</li><li>2、每个连接都需要消耗内存，而系统内存有限。</li></ul><h4 id=保活机制>保活机制</h4><p>在一个时间段内，如果没有任何连接相关的活动，TCP 保活机制就会开始作用。每隔一段时间，发送一个探测报文，如果连续几个探测报文没有得到应答，则认为当前连接已死亡。</p><p>在 Linux 内核中可以设置，保活时间、保活探测次数、保活探测时间间隔三个参数。</p><ul><li>net.ipv4.tcp_keepalive_time，默认保活时间是 7200 秒。</li><li>net.ipv4.tcp_keepalive_intvl ，默认每次检测间隔 75 秒。</li><li>net.ipv4.tcp_keepalive_probes，默认检测 9 次无响应，就认为连接死亡。</li></ul><p>也就是最少也要经过 7875 秒，系统才能发现一个死亡的连接。</p><h4 id=fast-open>Fast Open</h4><p>客户端在向服务端发起 HTTP GET 请求时，一个完整的交互需要 2.5 个 RTT 时延。如果算上第三次握手可以携带数据，这时也需要 2 个 RTT 时延。但是当下一次发起请求时，又需要再来一次。</p><p>Linux 3.7 提供了 TCP Fast Open 功能，可以减少 TCP 连接建立时的时延。</p><p>第一次建立连接的时候，服务端在第二次握手的时候产生一个加密的 Cookie ，和 ACK + SYN 报文一起返回。</p><p>客户端可以缓存这个 Cookie，下一次发起请求的时候，在第一次握手时，直接发送 SYN + Cookie + HTTP GET。</p><p>这样服务端直接从 Cookie 中获取相关信息，就可以跳过三次握手的过程。这时 HTTP GET 请求就只需要 1 个 RTT。</p><p>客户端可以一直用这个 Cookie，直到服务端认为 Cookie 无效（通常是过期了）。</p><p>在 Linux 中，通过设置 <code>/proc/sys/net/ipv4/tcp_fastopen</code> 来操作 TCP Fast Open。一共有 4 个值：0（关闭）；1（作为发起端使用）；2（作为响应端使用）；3（作为任意一端使用）。</p><h4 id=查看-tcp-连接状态>查看 TCP 连接状态</h4><p>在 Linux 中：</p><ul><li><code>netstat -napt</code>：查看 TCP 连接状态</li><li><code>ss</code>：查看 TCP 全连接队列的状态</li></ul><p>在 Windows 中，可以使用软件 Wireshark 抓包。</p><h3 id=三次握手>三次握手</h3><p>初始时，发起端和响应端都处于关闭状态。响应端开始主动监听己方系统的某个端口号是建立连接的前提。</p><h4 id=第一次握手>第一次握手</h4><p>发起端发送 SYN 报文，控制位 SYN 设置为 1，序列号初始化为 client_isn。</p><h5 id=第一次握手一直丢包>第一次握手一直丢包</h5><p>发起端会进行超时重传，在重复 5 次发送 SYN 报文之后断开。每次重传间隔时间为：1、3、7、15、31，符合 RTO 翻倍的逻辑。</p><p>在 Linux 中，第一次握手的超时重传的次数可以通过 <code>/proc/sys/net/ipv4/tcp_syn_retries</code> 设置。默认是 5 次。</p><h5 id=第一次握手的优化>第一次握手的优化</h5><p>优化发起端第一次握手的超时重试的次数（<code>/proc/sys/net/ipv4/tcp_syn_retries</code>），直接给应用程序报错。</p><h4 id=第二次握手>第二次握手</h4><p>响应端应答 ACK 报文，控制位 ACK 设置为 1，确认应答号设置为 client_isn + 1。同时发送己方的 SYN 报文，控制位 SYN 设置为 1，序列号初始化为 server_isn。</p><h5 id=第二次握手一直丢包>第二次握手一直丢包</h5><p>第一种情况：响应端没收到第三次握手的 ACK 报文。</p><p>响应端会进行超时重传，重传第二次握手的 ACK + SYN 报文，次数不定。</p><p>在 Linux 中，第二次握手的超时重传次数可以通过 <code>/proc/sys/net/ipv4/tcp_synack_retries</code> 设置。默认是 5 次。</p><p>第二种情况：发起端没收到第二次握手的 ACK + SYN 报文。</p><p>发起端会进行超时重传，重传第一次握手的 SYN 报文。</p><p>响应端收到 SYN 报文，应答第二次握手的 ACK + SYN 报文，然后重新设定超时重传的计时器。</p><p>最后，发起端在重复 5 次发送 SYN 之后断开。</p><h5 id=第二次握手的优化>第二次握手的优化</h5><p>1、增加半连接队列和全连接队列的长度。</p><p>注意：只增加半连接队列是无效的。</p><ul><li><code>/proc/sys/net/ipv4/tcp_max_syn_backlog</code>、</li><li><code>/proc/sys/net/core/somaxconn</code>、</li><li>系统函数 listen（
<a href=https://man7.org/linux/man-pages/man2/listen.2.html title="listen(2) - listen for connections on a socket" rel="noopener external nofollow noreferrer" target=_blank class=exturl>listen(2) - listen for connections on a socket
<i class="fa fa-external-link-alt"></i>
</a>） 的 backlog 参数。</li></ul><p>2、开启 cookie，<code>/proc/sys/net/ipv4/tcp_syncookies</code>。</p><p>3、优化响应端第二次握手的超时重试的次数（<code>/proc/sys/net/ipv4/tcp_synack_retries</code>），直接给应用程序报错。</p><h4 id=第三次握手>第三次握手</h4><p>发起端应答 ACK 报文，控制位 ACK 设置为 1，确认应答号设置为 server_isn + 1。</p><p>第三次握手的时候就可以携带数据了，前两次是不可以的。</p><h5 id=第三次握手一直丢包>第三次握手一直丢包</h5><p>响应端会进行第二次握手的超时重传，在重复 5 次发送 ACK + SYN 报文之后断开。</p><p>响应端断开后，发起端依然处于 established 的状态，不会断开。</p><p>这个时候如果发起端发送报文，就会一直重传，在 Linux 中，默认重传 15 次后停止。这个属于 TCP 建立连接后的重传次数。在 Linux 中，可以通过 <code>/proc/sys/net/ipv4/tcp_retries2</code> 设置。</p><p>最终由 TCP 的保活机制决定发起端什么时候断开连接。</p><h4 id=为什么需要三次握手>为什么需要三次握手</h4><p>1、同步双方的序列号</p><p>发起端和响应端，各自发送并确认己方序列号的逻辑。如果是独立的过程，最多需要两个来回也就是四次握手。但是响应端的答可以和问同时进行，所以可以合并为三次。</p><p>2、防止历史连接和资源浪费</p><p>发起端由于某种原因发起一次连接后关闭，然后又发起一次。这时前一次连接的无效的 SYN 报文依然可能到达响应端。但是响应端并不知道这两个报文的先后顺序，所以都会应答 ACK + SYN 报文。这时响应端会初始化两个连接。</p><p>发起端接到两个应答报文后，可以通过自己的上下文判断，是历史连接还是新的连接。如果是历史连接，发起端需要发送 RST 报文告知响应端断开历史连接。如果是新的连接，发起端就进行第三次握手建立连接。如果没有第三次握手，响应端两个建立到一半的连接就无法取舍，从而造成资源浪费。</p><h3 id=三次握手在内核中的流程>三次握手在内核中的流程</h3><h4 id=半连接队列和全连接队列>半连接队列和全连接队列</h4><p>响应端收到发起端的 SYN 之后，内核会把连接存储到半连接队列（SYN 队列）中，然后响应 ACK + SYN。</p><p>当响应端接收到发起端第三次握手的 ACK 报文之后，内核会把连接从半连接队列中移除，
然后，内核会创建新的连接并添加到全连接队列（Accept 队列），等待应用程序调用系统函数 accept（
<a href=https://man7.org/linux/man-pages/man2/accept.2.html title="accept(2) - accept a connection on a socket" rel="noopener external nofollow noreferrer" target=_blank class=exturl>accept(2) - accept a connection on a socket
<i class="fa fa-external-link-alt"></i>
</a>） 把连接取走。</p><p>不管是半连接队列还是全连接队列都有队列长度，超过限制时会直接丢弃或者返回 RST 报文。</p><p>半连接队列的最大值，取决于三个参数：</p><ul><li><p><code>net.ipv4.tcp_max_syn_backlog</code></p></li><li><p><code>/proc/sys/net/core/somaxconn</code></p></li><li><p>系统函数 listen 的 backlog 参数。</p></li><li><p>当 <code>max_syn_backlog > min(somaxconn, backlog)</code> 时， 半连接队列最⼤值为 <code>min(somaxconn,backlog) * 2</code>。</p></li><li><p>当 <code>max_syn_backlog &lt; min(somaxconn, backlog)</code> 时， 半连接队列最⼤值为 <code>max_syn_backlog * 2</code>。</p></li></ul><p>全连接队列的长度取决于两个参数，全连接队列的大小是两个参数值的最小值。</p><ul><li><code>/proc/sys/net/core/somaxconn</code>，Linux 默认 128。</li><li>系统函数 listen 的 backlog 参数，Nginx 默认 511。</li></ul><p><code>/proc/sys/net/ipv4/tcp_abort_on_overflow</code>，控制全连接队列满时的动作。</p><ul><li><code>tcp_abort_on_overflow = 0</code>，全连接队列满时，丢弃 ACK。Linux 默认 0。</li><li><code>tcp_abort_on_overflow = 1</code>，全连接队列满时，发送 RST 包，断掉连接。</li></ul><p>对于突发流量，应该设置 <code>tcp_abort_on_overflow = 0</code>，让客户端重发。如果持续不断有连接被丢弃，也不应该设置 1，而是应该修改全连接队列的大小。</p><p>丢弃连接的条件：</p><ul><li>1、半连接队列满了，且没有开启 tcp_syncookies。</li><li>2、全连接队列满了，且没有重传 SYN + ACK 包的连接请求大于 1.</li><li>3、没有开启 tcp_syncookies，且 <code>max_syn_backlog - 当前半连接队列长度 &lt; (max_syn_backlog >> 2)</code></li></ul><h4 id=syn-攻击>SYN 攻击</h4><p>SYN 攻击与 SYN 洪泛、DDos 攻击的思路差不多。攻击者同一时间向服务端发送大量伪造的 IP 地址不同的 SYN 报文。大量没有得到应答的连接最终会占满服务端的 SYN 队列，使得不能为正常用户提供服务。</p><p>解决方案 1：修改 Linux 参数，控制队列大小和队列满时的操作。</p><ul><li>net.core.netdev_max_backlog，队列最大值。</li><li>net.ipv4.tcp_max_syn_backlog，连接处于 syn_rcvd 状态的最大值。</li><li>net.ipv4.tcp_abort_on_overflow，队列满时的操作。</li></ul><p>解决方案 2：开启 cookie。</p><ul><li><code>net.ipv4.tcp_syncookies = 1</code>。</li></ul><p>开启后，当 SYN 队列满时，后续的连接不进入 SYN 队列。响应端会计算一个 cookie，放在 ACK + SYN 报文的序列号中返回。当接收到 ACK 时，验证合法性，如果合法，就放入 Accept 队列。</p><p>解决方案 3：减少 ACK + SYN 重传的次数（/proc/sys/net/ipv4/tcp_synack_retries）。</p><h3 id=关闭连接>关闭连接</h3><p>关闭连接的方式有两种，FIN 报文和 RST 报文。</p><p>如果进程异常退出，Linux 内核就会发送 RST 报文给对方，这个过程不走四次挥手。</p><p>想要安全关闭连接必须通过四次挥手，可以通过系统函数 close（
<a href=https://man7.org/linux/man-pages/man2/close.2.html title="close(2) - close a file descriptor" rel="noopener external nofollow noreferrer" target=_blank class=exturl>close(2) - close a file descriptor
<i class="fa fa-external-link-alt"></i>
</a>） 和系统函数 shutdown（
<a href=https://man7.org/linux/man-pages/man2/shutdown.2.html title="shutdown(2) - shut down part of a full-duplex connection" rel="noopener external nofollow noreferrer" target=_blank class=exturl>shutdown(2) - shut down part of a full-duplex connection
<i class="fa fa-external-link-alt"></i>
</a>）发起。</p><p>调用 close 意味者完全断开连接，进程无法接收和发送数据。调用方这边也叫孤儿连接。shutdown 可以关闭一个方向的连接，可以只关闭读，或者只关闭写，也可以全部关闭。</p><h3 id=四次挥手>四次挥手</h3><h4 id=第一次挥手>第一次挥手</h4><p>发起端发送 FIN 报文，控制位 FIN 设置为 1。</p><h5 id=第一次挥手一直丢包>第一次挥手一直丢包</h5><p>Linux 内核会定时重发 FIN 报文。超过重传次数后会直接关闭连接。</p><p>重传次数由 <code>/proc/sys/net/ipv4/tcp_orphan_retires</code> 控制。参数默认值为 0，但是含义是重传 8 次。这个参数不止对孤儿连接有效，还对所有处于 fin_wait_1 状态的连接有效。</p><p>遭到恶意攻击时，FIN 报文有可能发不出去。</p><ul><li>1、TCP 必须保证报文是有序的，FIN 报文也不例外。如果发送缓冲区还有数据没发送时，FIN 报文是不能提前发送的。</li><li>2、TCP 的流量控制，当接收方窗口为 0 时，发送方就不再发送数据。</li></ul><p>攻击场景：攻击方请求下载大文件，然后将己方的接收窗口设为 0。这样服务端的 FIN 报文发不出去，就会有大量的连接卡在 fin_wait_1 状态。</p><p>这种情况可以调整 Linux 系统的 <code>/proc/sys/net/ipv4/tcp_max_orphans</code> 参数，控制最大孤儿连接数量。防止孤儿连接过多，长时间占用系统资源。这时新增的孤儿连接将不再走四次挥手的流程，而是直接发送 RST 报文强制关闭。</p><h4 id=第二次挥手>第二次挥手</h4><p>响应端应答发起端 ACK 报文。然后进入 closed_wait 状态。也就是等待程序调用 close 关闭连接。如果响应端发现有大量的连接处于 closed_wait 状态，那大概率是程序有 bug，没有及时调用 close。</p><p>响应端处理完现有的报文，然后就会进入第三次挥手的阶段。</p><h4 id=第二次挥手的优化>第二次挥手的优化</h4><p>发起端接收到响应端的 ACK 报文后进入 fin_wait_2 状态。这个状态表示发起端的发送通道已关闭，等待响应端发送 FIN 报文。</p><ul><li>对于 shutdown 关闭的连接，可以一直处于 fin_wait_2 状态。</li><li>对于 close 关闭的连接，由于无法再接收数据，所以 fin_wait_2 状态不能持续太久。<code>/proc/sys/net/ipv4/tcp_fin_timeout</code> 控制这个状态下连接的持续时长，默认是 60 秒，和 time_wait 是一样的。</li></ul><p>孤儿连接，在 60 秒内没有收到 FIN 报文，超时后连接就会直接关闭。</p><h4 id=第三次挥手>第三次挥手</h4><p>响应端发送 FIN 报文，控制位 FIN 设置为 1。</p><p>如果响应端没有待处理的报文，那么第二次挥手和第三次挥手的报文可能是一起发送的。</p><h4 id=第四次挥手>第四次挥手</h4><p>发起端应答响应端 ACK 报文。然后，进入 time_wait 状态，经过 2 MSL 之后，自动关闭。这里发起端指的是主动关闭的那端，主动关闭的那端才会有 time_wait 状态。响应端收到 ACK 报文后，关闭。</p><h5 id=第三次挥手或者第四次挥手一直丢包>第三次挥手或者第四次挥手一直丢包</h5><p>对于响应端来说，都是一直没有收到 ACK 报文。这时 Linux 内核会定时重发 FIN 报文。
重传次数依然由 <code>/proc/sys/net/ipv4/tcp_orphan_retires</code> 参数控制。</p><h4 id=为什么要有-time_wait-状态>为什么要有 time_wait 状态</h4><p>time_wait 状态主要有两个作用：</p><ul><li>1、防止有相同四元组的旧数据包被接收。</li></ul><p>如果没有 time_wait，相同端口的 TCP 连接被复用时，可能会收到上次连接中没有及时到达的被延迟的数据包。2 MSL 的时间，足够让两个方向上的数据包都被丢弃，这样后续的数据包一定都是新的连接产生的。</p><ul><li>2、保证被动关闭连接的一方能被正确关闭。</li></ul><p>如果没有 time_wait，响应端又没收到 ACK 报文时，响应端就会一直卡在 last_ack 状态。
这时发起端使用相同端口建立新的连接时，响应端由于卡在 last_ack 状态，所以会直接返回 RST 终止连接。</p><h4 id=为什么-time_wait-等待-2-msl>为什么 time_wait 等待 2 MSL</h4><p>MSL（Maximum Segment Lifetime、报文最大生存时间）：指的是任何报文在网络上存在的最大时间。</p><p>如果响应端没有接到最后的 ACK 报文，就会重发 FIN 报文。发起端应答 ACK 报文和响应端重发 FIN 报文，一来一回是 2 MSL。</p><p>在 Linux 中，2 MSL 默认是 60 秒。如果需要修改，必须修改 Linux 内核代码里 TCP_TIMEWAIT_LEN 的值。</p><h4 id=处于-time_wait-状态的连接过多会造成的问题>处于 time_wait 状态的连接过多会造成的问题</h4><ul><li>1、每个连接都需要消耗内存。</li><li>2、每个连接都需要占用端口。一般可以开放的端口为 32768~61000。</li></ul><p>如果发起端端口消耗完了，就无法建立新的连接。如果响应端端口消耗完了，理论上可以继续监听新的连接，但是无法处理。</p><h4 id=解决处于-time_wait-状态的连接过多的方案>解决处于 time_wait 状态的连接过多的方案</h4><ul><li>1、net.ipv4.tcp_timestamps 和 net.ipv4.tcp_tw_reuse</li></ul><p><code>net.ipv4.tcp_tw_reuse = 1</code>，这个只能发起端用。开启后，可以复用处于 time_wait 的连接。应用程序在调用系统函数 connect（
<a href=https://man7.org/linux/man-pages/man2/connect.2.html title="connect(2) - initiate a connection on a socket" rel="noopener external nofollow noreferrer" target=_blank class=exturl>connect(2) - initiate a connection on a socket
<i class="fa fa-external-link-alt"></i>
</a>） 时，内核会随机找一个 time_wait 状态超过 1 秒的连接复用。这个选项的前提是 <code>net.ipv4.tcp_timestamps = 1</code>，打开 TCP 时间戳支持。</p><ul><li>2、net.ipv4.tcp_max_tw_buckets</li></ul><p>这个值默认为 18000。当处于 time_wait 状态的连接的数量超过这个值时，系统会将后面的新的进入 time_wait 状态的连接的直接关闭。</p><ul><li>3、通过设置 socket 选项（
<a href=https://man7.org/linux/man-pages/man2/setsockopt.2.html title="setsockopt(2) - get and set options on sockets" rel="noopener external nofollow noreferrer" target=_blank class=exturl>setsockopt(2) - get and set options on sockets
<i class="fa fa-external-link-alt"></i>
</a>）的 so_linger 参数，来设置调用 close 时的行为。</li></ul><p>如果 l_onoff 为非 0， 且 l_linger 值为 0，那么调用 close 后，会立刻该发送⼀个 RST 报文给对端，该 TCP 连接将跳过四次挥手，也就是会跳过 time_wait 状态，直接关闭。</p><h4 id=双方同时关闭>双方同时关闭</h4><p>双方同时关闭的情况有点特殊。两边都认为自己是四次挥手的发起端。在发送 FIN 报文之后，等到了对方的 FIN 报文。</p><p>这时双方在应答对方的 FIN 报文后各自进入 closing 状态。这个状态替代了 fin_wait_2 状态。然后双方在接到 ACK 报文后各自进入 time_wait 状态。</p><h3 id=参考>参考</h3></div><footer class=post-footer><div class=post-tags><a href=/tags/computer-science%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6>computer-science(计算机科学)</a>
<a href=/tags/protocol%e5%8d%8f%e8%ae%ae>protocol(协议)</a>
<a href=/tags/tcp>tcp</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
TCP 连接</li><li class=post-copyright-author><strong>本文作者：</strong>
西柊慧音</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/computer-science/protocol/tcp/connection/ title="TCP 连接">/post/computer-science/protocol/tcp/connection/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/computer-science/protocol/tcp/reliability/ rel=next title="TCP 可靠性"><i class="fa fa-chevron-left"></i> TCP 可靠性</a></div><div class="post-nav-prev post-nav-item"><a href=/post/computer-science/protocol/udp/udp/ rel=prev title=UDP>UDP
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>西柊慧音</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.103.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.1 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":false,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.1","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.c997eeae723f2fcee19ae5066fcc64a49cefb92ddb75904efdb69a223e5a6740.js defer></script></body></html>