<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.103.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Golang 实现简单的 Web 框架 -- router(路由)"><meta itemprop=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=keywords content="computer-science(计算机科学),programming-language(编程语言),framework(框架),web,http,router(路由),golang"><meta property="og:type" content="article"><meta property="og:title" content="Golang 实现简单的 Web 框架 -- router(路由)"><meta property="og:description" content><meta property="og:image" content="/image/pid49256268.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/computer-science/programming-language/framework/web/golang/router_v2/"><meta property="og:site_name" content="帕里特档案馆"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="西柊慧音"><meta property="article:published_time" content="2023-02-09 08:00:00 +0800 CST"><meta property="article:modified_time" content="2023-02-11 08:00:00 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.4da9279b6033ade10d67092d7bfb660265f9fa46c40974f17b13bfe235396546.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"router_v2","permalink":"/post/computer-science/programming-language/framework/web/golang/router_v2/","title":"Golang 实现简单的 Web 框架 -- router(路由)","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Golang 实现简单的 Web 框架 -- router(路由) - 帕里特档案馆</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>帕里特档案馆</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>重建中</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>111</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#资料>资料</a></li><li><a href=#正文>正文</a><ul><li><a href=#web-框架是什么>Web 框架是什么</a><ul><li><a href=#概念解释>概念解释</a></li><li><a href=#比喻解释>比喻解释</a></li><li><a href=#本人想到的最合理的解释>本人想到的最合理的解释</a></li></ul></li><li><a href=#web-框架是怎么被创造出来的>Web 框架是怎么被创造出来的</a></li><li><a href=#从-tcp-开始>从 TCP 开始</a></li><li><a href=#golang-的-net-包和-nethttp-包>Golang 的 &ldquo;net&rdquo; 包和 &ldquo;net/http&rdquo; 包</a></li><li><a href=#从最简单的场景开始>从最简单的场景开始</a></li><li><a href=#处理逻辑需要一些前置后置工作>处理逻辑需要一些前置（后置）工作</a><ul><li><a href=#所有的处理逻辑都需要>所有的处理逻辑都需要</a></li><li><a href=#部分处理逻辑需要>部分处理逻辑需要</a></li></ul></li><li><a href=#路由树>路由树</a><ul><li><a href=#基本概念>基本概念</a></li><li><a href=#路由树的设计golang>路由树的设计（Golang）</a></li><li><a href=#路径参数路由正则匹配路由通配符路由>路径参数路由、正则匹配路由、通配符路由</a></li><li><a href=#路径参数路由正则匹配路由通配符路由的设计golang>路径参数路由、正则匹配路由、通配符路由的设计（Golang）</a></li></ul></li><li><a href=#前置后置工作成对出现>前置（后置）工作成对出现</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=西柊慧音 src=/imgs/img-lazy-loading.gif data-src=/image/pid49256268.jpg><p class=site-author-name itemprop=name>西柊慧音</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>111</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>19</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>67</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/KelipuTe title="Github → https://github.com/KelipuTe" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=xhy_1365@sina.com title="E-Mail → xhy_1365@sina.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>E-Mail</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/computer-science/programming-language/framework/web/golang/router_v2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=name content="西柊慧音"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="西柊慧音"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Golang 实现简单的 Web 框架 -- router(路由)"><meta itemprop=description content="Web 框架是什么；路由是什么；路由树是怎么来的；"></span><header class=post-header><h1 class=post-title itemprop="name headline">Golang 实现简单的 Web 框架 -- router(路由)</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2023-02-09 08:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-02-09 08:00:00 +0800 CST">2023-02-09</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i></span>
<span class=post-meta-item-text>更新于：</span>
<time title=修改时间：2023-02-11T08:00:00+08:00 itemprop=dateModified datetime=2023-02-11T08:00:00+08:00>2023-02-11</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/framework%E6%A1%86%E6%9E%B6 itemprop=url rel=index><span itemprop=name>framework(框架)</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>7744</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>16分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/post/computer-science/programming-language/framework/web/golang/router_v2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h2 id=前言>前言</h2><p>实践的环境：</p><ul><li>CPU AMD64(x86_64)</li><li>Windows 11 家庭版</li><li>go version go1.19 windows/amd64</li></ul><h2 id=资料>资料</h2><ul><li><a href=https://github.com/KelipuTe/demo-golang title={demo-golang} rel="noopener external nofollow noreferrer" target=_blank class=exturl>{demo-golang}
<i class="fa fa-external-link-alt"></i>
</a>/demo/web/router/</li><li><a href=/drawio/computer-science/programming-language/framework/web/web.drawio.html>web.drawio.html</a></li></ul><p>前置笔记：
<a href=/post/computer-science/programming-language/golang/http title="Golang 开启 HTTP 服务">Golang 开启 HTTP 服务</a></p><h2 id=正文>正文</h2><h3 id=web-框架是什么>Web 框架是什么</h3><h4 id=概念解释>概念解释</h4><p>简单的理解，Web 框架就是工程师们在反复开发 WEB 系统的后端服务时，对于 &ldquo;如何处理重复的代码&rdquo; 这个问题，想出的一种解决方案。Web 框架的核心目标主要有：减少重复的代码，提高代码的可维护性；提供常用的组件，提高编程的效率。</p><p>重复的代码分为两种。一种是，在一个工程中，多处都需要使用的代码。另一种是，在多个工程中，都需要使用的代码。Web 框架内部的设计是为了解决在一个工程中的重复的代码，Web 框架本体的设计是为了解决在在多个工程中的重复的代码。</p><p>在一个工程中的重复的代码是指，在一个工程中，有多处的逻辑是相同的，但是编码实现的时候，没有对逻辑进行封装，而是暴力的把代码复制粘贴。这么做会导致，如果这块逻辑有变化，那么所有复制粘贴的地方都需要修改。</p><p>在多个工程中都需要使用的代码是指，在多个项目中，可能都需要路由、中间件、参数校验、日志等常用的组件。这个时候就可以把这些常用的组件打包到一起，下次在需要构建类似的工程的时候，就可以直接拿过来用。</p><h4 id=比喻解释>比喻解释</h4><p>用比喻来理解，Web 框架就相当于毛坯房外加一堆事先准备好的建材。毛坯房是指，房屋的框架结构有了但是里面没有装修。事先准备好的建材是指，在房子外面事先准备好了砖头、水泥、石灰这类最基础的材料。毛坯房本体直接就可以用，如果使用者有别的需要，也对房屋进行不同的装修，添加不同的内饰。</p><p>比如，烘焙店和服装店内部装修肯定是不一样的。在进行装修的时候，可以直接使用事先准备好的建材。如果觉得事先准备好的建材不能满足需求，那就需要自行准备新的建材。比如，烘焙店和服装店如果想加一面墙，那可以直接用事先准备好的砖头、水泥。但是如果烘焙店想铺木地板或者服装店想贴墙纸，那就需要自行准备了。</p><p>这套逻辑套到 Web 框架上来是一样的，毛坯房对应的就是框架的核心组件，事先准备好的建材对应的就是常用的组件。对于 Web 系统来说，主要任务都是处理网络请求（毛坯房本体）。但是具体到不同的业务系统，它们内部处理的具体的业务逻辑肯定是不同的（不同的装修、不同的内饰）。比如，商城系统主要是处理商品和订单的，成绩管理系统主要是处理成绩的。但是有可能会使用相同的组件（事先准备好的建材）。比如，都需要登录、都需要记日志。</p><h4 id=本人想到的最合理的解释>本人想到的最合理的解释</h4><p>如果通过前面的概念和比喻还是不怎么好理解什么是 WEB 框架，那么还有一个更简单的理解，<strong>工程师们想偷懒，他们通过创造并使用 Web 框架这个工具，来达到偷懒的目的</strong>。</p><h3 id=web-框架是怎么被创造出来的>Web 框架是怎么被创造出来的</h3><p>现在是知道有 Web 框架这么个工具了，但是这个工具是怎么被创造出来的呢？想要解释这个问题，就必须回到 Web 框架这个概念还没有出现的 &ldquo;蛮荒时代&rdquo; 去。下面将结合代码来说明这个问题，代码将会使用 Golang 处理 HTTP 1.1 的请求。</p><h3 id=从-tcp-开始>从 TCP 开始</h3><p>别看见 TCP 就紧张，这里不要求深入了解 TCP 的细节，只需要知道 TCP 是一个字节流协议就可以了。字节流协议，它的意思就是说，传输数据的时候，它是以字节为单位的，传输的过程像流水一样，一个字节接着一个字节的。见图：<strong>web.drawio.html 2-2</strong>。</p><p>HTTP 1.1 是基于 TCP 协议实现的，所以 HTTP 1.1 也可以说是一种字节流协议。这里为什么要说这个呢？主要是想强调一下，在计算机的 &ldquo;眼里&rdquo;，HTTP 报文它不是一个整体，而是一个一个字符。HTTP 1.1 报文大概的格式见图：<strong>web.drawio.html 2-4-2、2-4-4</strong>。</p><p>既然发出去的 HTTP 报文就是一串字符，那么如果不说明这串字符怎么解读，那这串字符就毫无意义。所以客户端和服务端会通过约定请求行的 method 和 url 来区分不同的报文，method 和 url 的组合就是路由。</p><p>可以区分不同的报文之后，后面的请求头部和请求体才有意义。分析 HTTP 报文是什么类型，然后根据类型提取报文中的数据的过程就是解析 HTTP 报文的过程。</p><h3 id=golang-的-net-包和-nethttp-包>Golang 的 &ldquo;net&rdquo; 包和 &ldquo;net/http&rdquo; 包</h3><p>在 net 包里，提供了对 TCP 的支持。而 &ldquo;net/http&rdquo; 包就是基于 net 包，实现了对 HTTP 协议的解析。这里就不费劲的从 TCP 开始搞了，怎么使用 TCP 和解析 HTTP 报文对理解 Web 框架其实没啥帮助。所以直接从 &ldquo;net/http&rdquo; 包开始。</p><p>再继续之前，建议先看一下 <strong>前置笔记：Golang 开启 HTTP 服务</strong>。下面会直接从 &ldquo;net/http"包 的 Handler 接口的 ServeHTTP 方法切入。在 ServeHTTP 方法的第二个参数 &ldquo;*Request&rdquo; 里面，就可以拿到已经解析好的 HTTP 请求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>type Handler interface {
</span></span><span style=display:flex><span>	ServeHTTP(ResponseWriter, *Request)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=从最简单的场景开始>从最简单的场景开始</h3><p>假设，所有接口的处理逻辑都是一个完整的整体。</p><p>如果啥都不考虑，那大可以直接用 if-else 的结构去判断 method 和 url，然后在 if-else 分支里面写各自的处理逻辑。如果把处理逻辑封装到方法面去，那这样的代码的逻辑其实是非常清晰的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func ServeHTTP(http.ResponseWriter, *http.Request) {
</span></span><span style=display:flex><span>	if Request.Method == &#34;GET&#34; {
</span></span><span style=display:flex><span>		if Request.URL == &#34;/user/id&#34; {
</span></span><span style=display:flex><span>			// /user/id 的处理逻辑
</span></span><span style=display:flex><span>		} else if Request.URL == &#34;/user/name&#34; {
</span></span><span style=display:flex><span>			// /user/name 的处理逻辑
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	} else if Request.Method == &#34;POST&#34; {
</span></span><span style=display:flex><span>		if Request.URL == &#34;/order/create&#34; {
</span></span><span style=display:flex><span>			// /order/create 的处理逻辑
</span></span><span style=display:flex><span>		} else if Request.URL == &#34;/order/delete&#34; {
</span></span><span style=display:flex><span>			// /order/delete 的处理逻辑
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>即使后面报文的类型越来越多，无非也就是 if-else 的分支多了一点。可以再对 url 的处理做一次封装，代码就可以拆开来了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func ServeHTTP(http.ResponseWriter, *http.Request) {
</span></span><span style=display:flex><span>	if Request.Method == &#34;GET&#34; {
</span></span><span style=display:flex><span>		handleGet()
</span></span><span style=display:flex><span>	} else if Request.Method == &#34;POST&#34; {
</span></span><span style=display:flex><span>		handlePost()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>func handleGet(){
</span></span><span style=display:flex><span>	if Request.URL == &#34;/user/id&#34; {
</span></span><span style=display:flex><span>		// /user/id 的处理逻辑
</span></span><span style=display:flex><span>	} else if Request.URL == &#34;/user/name&#34; {
</span></span><span style=display:flex><span>		// /user/name 的处理逻辑
</span></span><span style=display:flex><span>	} else if xxx {
</span></span><span style=display:flex><span>	} else if xxx {
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>func handlePost(){
</span></span><span style=display:flex><span>	if Request.URL == &#34;/order/create&#34; {
</span></span><span style=display:flex><span>		// /order/create 的处理逻辑
</span></span><span style=display:flex><span>	} else if Request.URL == &#34;/order/delete&#34; {
</span></span><span style=display:flex><span>		// /order/delete 的处理逻辑
</span></span><span style=display:flex><span>	} else if xxx {
</span></span><span style=display:flex><span>	} else if xxx {
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>就目前来看这种给 method 和 url 都写一个 if-else 的分支的写法，似乎并没有什么非常明显的弊端。这种结构也可以使用 map 结构代替。可以是一层的：<code>map[method+url]处理方法</code>，或者嵌套的：<code>map[method]{map[url]处理方法}</code>。</p><h3 id=处理逻辑需要一些前置后置工作>处理逻辑需要一些前置（后置）工作</h3><p>但是实际上并不是 &ldquo;所有接口的处理逻辑都是一个完整的整体&rdquo;。比如，商城系统的下订单和取消订单的接口。下订单的接口的处理逻辑假设为，校验用户+下订单。取消订单的接口的处理逻辑假设为，校验用户+取消订单。</p><p>这里可以换一个角度，把下订单的接口的处理逻辑分成：前置工作 &ldquo;校验用户&rdquo; 和处理逻辑 &ldquo;下订单&rdquo;。把取消订单的接口的处理逻辑分成：前置工作 &ldquo;校验用户&rdquo; 和处理逻辑 &ldquo;取消订单&rdquo;。</p><p>这里讨论的是前置（后置）工作相同的情况。如果每个处理逻辑需要执行的前置（后置）工作不同，那就退回到 &ldquo;所有接口的处理逻辑都是一个完整的整体&rdquo; 那种情况去了。前置（后置）工作相同的情况有几种：所有的处理逻辑都需要，部分处理逻辑需要。</p><h4 id=所有的处理逻辑都需要>所有的处理逻辑都需要</h4><p>这种场景非常好处理，直接在最外面写就好了。哪怕前置（后置）工作有多个或者它们之间有顺序要求的场景。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func ServeHTTP(http.ResponseWriter, *http.Request) {
</span></span><span style=display:flex><span>	// 前置工作 a
</span></span><span style=display:flex><span>	// 前置工作 b
</span></span><span style=display:flex><span>	if Request.Method == &#34;GET&#34; {
</span></span><span style=display:flex><span>		handleGet()
</span></span><span style=display:flex><span>	} else if Request.Method == &#34;POST&#34; {
</span></span><span style=display:flex><span>		handlePost()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	// 后置工作 c
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=部分处理逻辑需要>部分处理逻辑需要</h4><p>这种场景乍一看可以沿用 &ldquo;所有的处理逻辑都需要&rdquo; 的方案，把前置（后置）工作下放到每个 if-else 的分支里面去就好了。但是这么做是有问题的。</p><p>假设 &ldquo;/user/id&rdquo; 和 &ldquo;/user/name&rdquo; 都需要 &ldquo;前置工作 user&rdquo;，"/user/id&rdquo; 自己还需要 &ldquo;前置工作 user-id&rdquo;，"/user/name" 自己还需要 &ldquo;后置工作 user-name&rdquo;。如果按照上面的写法，代码会写成下面这样子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func handleGet(){
</span></span><span style=display:flex><span>	if Request.URL == &#34;/user/id&#34; {
</span></span><span style=display:flex><span>		// 前置工作 user
</span></span><span style=display:flex><span>		// 前置工作 user-id
</span></span><span style=display:flex><span>		// /user/id 的处理逻辑
</span></span><span style=display:flex><span>	} else if Request.URL == &#34;/user/name&#34; {
</span></span><span style=display:flex><span>		// 前置工作 user
</span></span><span style=display:flex><span>		// /user/name 的处理逻辑
</span></span><span style=display:flex><span>		// 后置工作 user-name
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>乍一看问题不大，但是如果后面有 &ldquo;/user/a&rdquo;、"/user/b" 一直到 &ldquo;/user/z&rdquo; 呢？如果要求每个 &ldquo;/user/&rdquo; 开头的，都需要 &ldquo;前置工作 user&rdquo; 呢？这时候上面这种写法，&ldquo;前置工作 user&rdquo; 就要写 n 次，<strong>很麻烦</strong>。如果后面要求变了，要求每个 &ldquo;/user/&rdquo; 开头的都需要 &ldquo;前置工作 user2&rdquo;，或者这里就需要改 n 个地方，<strong>更麻烦</strong>。</p><p>所以要想办法，把这个公共的模块提取出去。比如，变成下面这样（这里写了个伪代码，用的是 SQL 的 LIKE 语法），把有这种要求的 url 前缀单独拿到一个 if-else 的分支里去。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func handleGet(){
</span></span><span style=display:flex><span>	if Request.URL like &#34;/user/%&#34; {
</span></span><span style=display:flex><span>		// 前置工作 user
</span></span><span style=display:flex><span>		if Request.URL == &#34;/user/id&#34; {
</span></span><span style=display:flex><span>			// 前置工作 user-id
</span></span><span style=display:flex><span>			// /user/id 的处理逻辑
</span></span><span style=display:flex><span>		} else if Request.URL == &#34;/user/name&#34; {
</span></span><span style=display:flex><span>			// /user/name 的处理逻辑
</span></span><span style=display:flex><span>			// 后置工作 user-name
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		// 后置工作 user
</span></span><span style=display:flex><span>	} else {
</span></span><span style=display:flex><span>		if Request.URL == &#34;/order/id&#34; {
</span></span><span style=display:flex><span>			// /order/id 的处理逻辑
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>乍一看问题不大，如果要求每个 &ldquo;/user/&rdquo; 开头的从都需要 &ldquo;前置工作 user&rdquo; 变成都需要 &ldquo;前置工作 user2&rdquo;，那么只需要改一处。但是如果前缀的层级很多呢？比如，加一个 &ldquo;/user/info/a&rdquo;，同时要求每个 &ldquo;/user/info/&rdquo; 开头的从都需要 &ldquo;前置工作 user-info&rdquo;。那上面这种写法就要变成。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func handleGet(){
</span></span><span style=display:flex><span>	if Request.URL like &#34;/user/%&#34; {
</span></span><span style=display:flex><span>		// 前置工作 user
</span></span><span style=display:flex><span>		if Request.URL like &#34;/user/info/%&#34; {
</span></span><span style=display:flex><span>			// 前置工作 user-info
</span></span><span style=display:flex><span>			if Request.URL == &#34;/user/info/a&#34; {
</span></span><span style=display:flex><span>				// /user/info/a 的处理逻辑
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		} else {
</span></span><span style=display:flex><span>			if Request.URL == &#34;/user/id&#34; {
</span></span><span style=display:flex><span>				// 前置工作 user-id
</span></span><span style=display:flex><span>				// /user/id 的处理逻辑
</span></span><span style=display:flex><span>			} else if Request.URL == &#34;/user/name&#34; {
</span></span><span style=display:flex><span>				// /user/name 的处理逻辑
</span></span><span style=display:flex><span>				// 后置工作 user-name
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		// 后置工作 user
</span></span><span style=display:flex><span>	} else {
</span></span><span style=display:flex><span>		if Request.URL == &#34;/order/id&#34; {
</span></span><span style=display:flex><span>			// /order/id 的处理逻辑
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样下去 if-else 的层级就会变得越来越深了。if-else 的层级太深，不利于代码的可读性和可维护性。更重要的是，这样的代码改的时候，找起来非常的麻烦，还要担心层级会不会改错了。所以这个问题是需要规避的。那么怎么规避呢？可以使用有层次的结构。</p><p>设想一个场景，图书馆里有大量的书需要分类管理。那么可以先按书内容的类别，分到不同的楼层去。然后再按书的作者，分到不同的书架上去。如果想处理某一类的书，可以只在某个楼层内操作，不会影响到别的楼层。如果想处理某一类的某个作者的书，可以只在某个楼层的某个书架上操作，不会影响到这个楼层的别的书架，更不会影响到别的楼层。</p><p>这里把这种结构画出来就很直观了。见图：<strong>web.drawio.html 4-2</strong>。这种结构在数据结构里对应的就是树形结构。把上面的 method、url、前置（后置）工作对应进去再画一张图。见图：<strong>web.drawio.html 4-4</strong>。</p><h3 id=路由树>路由树</h3><h4 id=基本概念>基本概念</h4><p>到这里，所谓的路由树的概念就呼之欲出了。上面的那棵树的结点中记录了全路径，但是这其实是不需要的。当命中 &rsquo;like &ldquo;/user/%&rdquo;&rsquo; 分支往下走的时候，后面的 url 最前面的那段就肯定是 &ldquo;/user/"。所以这里就可以借助前缀的思路，用 &ldquo;/&rdquo; 作为分隔标志，将上面的那棵树转化成前缀树。见图：<strong>web.drawio.html 4-6-2</strong>。注意有个根结点（&rdquo;/" 结点）。</p><p>这样当一个 HTTP 请求过来的时候，先通过 method 判断应该到哪一棵路由树里去找。然后用 &ldquo;/&rdquo; 将 url 分开，依次去路由树里匹配，如果结点上有前置（后置）工作就需要记录下来。最后找到目标结点时，按照前置工作、处理逻辑、后置工作的顺序依次执行。</p><p>比如，在 <strong>web.drawio.html 4-6-2</strong> 这颗树里，访问 &ldquo;/user/id&rdquo; 的时候。依次会访问："/" 结点；&ldquo;user&rdquo; 结点，记录下 &ldquo;前置工作 user&rdquo; 和 &ldquo;后置工作 user&rdquo;；id 结点，记录下 &ldquo;前置工作 user-id&rdquo; 和 &ldquo;/user/id&rdquo; 的处理逻辑。见图：<strong>web.drawio.html 4-6-4</strong>。</p><p>执行的时候，从逻辑上考虑的话，应该是前面的结点的前置任务应该在前面，前面的结点的后置任务应该在后面。所以上面就应该按照 &ldquo;前置工作 user&rdquo;、&ldquo;前置工作 user-id&rdquo;、"/user/id" 的处理逻辑、&ldquo;后置工作 user&rdquo; 的顺序依次执行。</p><h4 id=路由树的设计golang>路由树的设计（Golang）</h4><h5 id=代码结构设计>代码结构设计</h5><p>路由树，从名字里就可以知道，它首先是一个是树结构，所以，设计工作应该从树结点开始。这里用 <strong>web.drawio.html 4-6-2</strong> 里的那个路由树为例。</p><p>一条完整的路由会被拆成有父子关系的一系列结点。那么，树结点里面一定有一个数据用于标记它是路由中的哪一个部分。然后，还需要知道父子关系，所以，结点需要存储其子结点的信息。这里一般没有回溯的需求，如果需要支持路由的回溯匹配，那么结点就需要记录父结点的信息。</p><p>一条路由最后会对应一个处理方法，这个显然是需要记录的。另外，还有前置工作和后置工作，这部分属于中间件，放到后面说，这里先不搞。所以，代码结构目前应该差不多像下面这样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>// routingNode 路由结点
</span></span><span style=display:flex><span>type routingNode struct {
</span></span><span style=display:flex><span>	// part 这个路由结点代表的那段路径
</span></span><span style=display:flex><span>	part string
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// handler 命中路由之后的处理逻辑
</span></span><span style=display:flex><span>	handler HTTPHandleFunc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// routingTree 路由子树，子结点的 path =&gt; 子树根结点
</span></span><span style=display:flex><span>	routingTree map[string]*routingNode
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=测试用例设计>测试用例设计</h5><p>对于最基本的路由树结构，测试用例设计是非常简单的。</p><table><thead><tr><th>用例编号</th><th>测试用例</th><th>测试目标</th></tr></thead><tbody><tr><td>2</td><td>/user</td><td>根结点（空结点） -> 根结点有 1 个子结点（user）</td></tr><tr><td>4</td><td>/user + /user/info</td><td>user 结点（空结点） -> user 结点有 1 个子结点（info）</td></tr><tr><td>6</td><td>/user + /order</td><td>根结点有 1 个结点（user） -> 根结点有 2 个结点（user、order）</td></tr></tbody></table><p>这样最基本的几种情况就都测到了。</p><h4 id=路径参数路由正则匹配路由通配符路由>路径参数路由、正则匹配路由、通配符路由</h4><p>静态的路由匹配可以用上面的 if-else 分支或者路由树解决。但是一些高级玩法，比如：路径参数路由、正则匹配路由、通配符路由，这样的就没办法整。</p><p>路径参数路由，一般长这样 &ldquo;user/:id&rdquo;，能把路由里的某一段提取出来，放到事先定义好的变量里面。</p><p>正则匹配路由一般长这样 &ldquo;user/:id(/\d/)"，它和路径参数路由很像，区别在于，正则匹配路由在提取出路由里的某一段之后，还需要对数据的格式进行校验。</p><p>通配符路由一般长这样 &ldquo;/user/*"，它就很暴力了，只要路由前面是 &ldquo;/user/&rdquo; 开头的，后面是什么都可以匹配上。</p><p>这里以路径参数路由为例。比如，定义 &ldquo;user/:id&rdquo; 这样一个路径参数路由，在对应的处理方法里，事先定义好了一个变量 id 用于接收 &ldquo;:id&rdquo; 这个位置对应的字符串。</p><p>最终达到的效果是：如果访问的是 &ldquo;user/1&rdquo;，那么变量 id 的值就是字符串 &ldquo;1&rdquo;；如果访问的是 &ldquo;user/2&rdquo;，那么变量 id 的值就是字符串 &ldquo;2&rdquo;；如果访问的是 &ldquo;user/a&rdquo;，那么变量 id 的值就是字符串 &ldquo;a&rdquo;。</p><p>对于这种 &ldquo;:id&rdquo; 的位置可以变的路由。if-else 分支或者 map 是无解的。因为，":id&rdquo; 对应的位置可变，意味着这里会对应无穷多个 if-else 分支。路由树有没有解呢？路由树可以解决，路由树只需要在 user 结点上增加一个特殊的 &ldquo;:id&rdquo; 结点，专门用于处理路径参数路由即可。见图：<strong>web.drawio.html 4-8-2</strong>。</p><p>访问 &ldquo;/user/1&rdquo; 的时候。依次会访问：&rdquo;/" 结点；&ldquo;user&rdquo; 结点。到了 &ldquo;user&rdquo; 结点之后，按照默认逻辑下面要找的是 1 结点，但是 &ldquo;user&rdquo; 结点下面只有 &ldquo;info&rdquo; 结点、&ldquo;id&rdquo; 结点，无法匹配。这个时候就可以尝试匹配 &ldquo;:id&rdquo; 结点，看看 1 符不符合 &ldquo;:id&rdquo; 结点的要求。</p><p>这里 &ldquo;:id&rdquo; 的位置可以是任意的字符串，所以 1 是符合要求的，所以 &ldquo;/user/1&rdquo; 最终调用的就应该是 &ldquo;:id&rdquo; 结点的处理逻辑。见图：<strong>web.drawio.html 4-8-4</strong>。</p><p>但是需要注意的是，这三个玩意匹配的时候可能都能匹配上，所以需要人为的定义这三个特殊的路由，哪个优先匹配，哪个最后匹配。</p><p>最后，写代码的时候，路由注册和路由查询的逻辑建议分开。因为路由注册和路由查询的逻辑看似都是找结点，但是细节上还是有点区别的。路由注册的时候，是严格按照路由层级注册的，而路由查询的时候，需要考虑特殊结点。</p><h4 id=路径参数路由正则匹配路由通配符路由的设计golang>路径参数路由、正则匹配路由、通配符路由的设计（Golang）</h4><h5 id=代码结构设计-1>代码结构设计</h5><p>路径参数路由、正则匹配路由、通配符路由的匹配逻辑和普通结点是不同的，需要能识别出它们。在树结构里，可以通过给结点打上标记来区分不同的结点。</p><p>在上面的设计中，把所有的结点都放到了一个 map 里面管理，这个操作在这里是行不通的。这三种特殊的结点没有实际上的 url，也就提取不出 map 的 key。所以，这三种特殊的结点需要专门的地方来存储。</p><p>而且这三种特殊结点理论上都是唯一的。比如，一个结点上不可能同时有两个路径参数路由。假设，同时存在 &ldquo;/user/:id&rdquo; 和 &ldquo;/user/:name&rdquo;，那么 &ldquo;/user/a&rdquo; 应该命中哪一个呢。另外，通配符结点的后面不应该有子结点，因为，全部都会被通配符结点截胡。</p><p>普通结点里用于标记它是路由中的哪一个部分的那个参数，在这三种结点里面是没啥用的。路径参数路由和正则匹配路由需要一个额外的参数存储参数的名字，正则匹配路由还需要一个参数存储正则表达式。</p><p>所以，上面的代码结构需要增加点东西，目前应该差不多像下面这样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>// routingNode 路由结点
</span></span><span style=display:flex><span>type routingNode struct {
</span></span><span style=display:flex><span>	// nodeType 结点类型
</span></span><span style=display:flex><span>	nodeType int
</span></span><span style=display:flex><span>	// part 这个路由结点代表的那段路径
</span></span><span style=display:flex><span>	part string
</span></span><span style=display:flex><span>	// path 从根路由到这个路由结点的全路径
</span></span><span style=display:flex><span>	path string
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// handler 命中路由之后的处理逻辑
</span></span><span style=display:flex><span>	handler HTTPHandleFunc
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>	// routingTree 路由子树，子结点的 path =&gt; 子树根结点
</span></span><span style=display:flex><span>	routingTree map[string]*routingNode
</span></span><span style=display:flex><span>	// paramChild 路径参数结点
</span></span><span style=display:flex><span>	paramChild *routingNode
</span></span><span style=display:flex><span>	// paramName 路径参数路由和正则表达式路由，都会提取路由参数的名字
</span></span><span style=display:flex><span>	paramName string
</span></span><span style=display:flex><span>	// regexpChild 正则表达式结点
</span></span><span style=display:flex><span>	regexpChild *routingNode
</span></span><span style=display:flex><span>	// regexp 正则表达式
</span></span><span style=display:flex><span>	regexp *regexp.Regexp
</span></span><span style=display:flex><span>	// anyChild 通配符结点
</span></span><span style=display:flex><span>	anyChild *routingNode
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h5 id=测试用例设计-1>测试用例设计</h5><p>三种特殊结点的测试用例设计就稍微复杂一点了。而且因为结点类型变多了，还需要考虑注册结点的时候的顺序的问题。三种特殊结点有可能会干扰注册普通结点时的结点查询逻辑。</p><table><thead><tr><th>用例编号</th><th>测试用例</th><th>测试目标</th></tr></thead><tbody><tr><td>-</td><td>普通结点 + 参数路由结点</td><td>-</td></tr><tr><td>2</td><td>/user + /user/:id</td><td>user 结点（空结点） -> user 结点有 1 个参数路由子结点（:id）</td></tr><tr><td>4</td><td>/user + /user/info + /user/:id</td><td>user 结点有 1 个子结点（info） -> user 结点有 1 个子结点（info）和 1 个参数路由子结点（:id）</td></tr><tr><td>6</td><td>/user + /user/:id + /user/info</td><td>user 结点有 1 个参数路由子结点（:id） -> user 结点有 1 个子结点（info）和 1 个参数路由子结点（:id）</td></tr><tr><td>8</td><td>/user + /user/:id + /user/:id/info</td><td>参数路由结点（:id）（空结点） -> 参数路由结点（:id） 有 1 个子结点（info）</br><strong>注意用例 8 和用例 6 的区别。</strong></td></tr><tr><td>10</td><td>/user + /user/:id + /user/:name</td><td>user 结点有两个参数路由子结点，<strong>报错</strong></td></tr><tr><td>12</td><td>/user + /user/:id + /user/:id/:name</td><td>参数路由结点（:id）（空结点） -> 参数路由结点（:id）有 1 个参数路由子结点（:name）</td></tr><tr><td>-</td><td>普通结点 + 正则表达式结点</td><td>-</td></tr><tr><td>42</td><td>/user + /user/:id(/\d/)</td><td>user 结点（空结点） -> user 结点有 1 个正则表达式子结点（:id）</td></tr><tr><td>44</td><td>/user + /user/info + /user/:id(/\d/)</td><td>user 结点有 1 个子结点（info） -> user 结点有 1 个子结点（info）和 1 个正则表达式子结点（:id）</td></tr><tr><td>46</td><td>/user + /user/:id(/\d/) + /user/info</td><td>user 结点有 1 个正则表达式子结点（:id） -> user 结点有 1 个子结点（info）和 1 个正则表达式子结点（:id）</td></tr><tr><td>48</td><td>/user + /user/:id(/\d/) + /user/:id(/\d/)/info</td><td>正则表达式结点（:id）（空结点） -> 正则表达式结点（:id） 有 1 个子结点（info）</br><strong>注意用例 48 和用例 46 的区别。</strong></td></tr><tr><td>50</td><td>/user + /user/:id(/\d/) + /user/:name(/^[A-Za-z0-9]+$/)</td><td>user 结点有两个正则表达式子结点，<strong>报错</strong></td></tr><tr><td>52</td><td>/user + /user/:id(/\d/) + /user/:id(/\d/)/:name(/^[A-Za-z0-9]+$/)</td><td>正则表达式结点（:id）（空结点） -> 正则表达式结点（:id）有 1 个正则表达式子结点（:name）</td></tr><tr><td>-</td><td>普通结点 + 通配符结点</td><td>-</td></tr><tr><td>82</td><td>/user + /user/*</td><td>user 结点（空结点） -> user 结点有 1 个通配符子结点</td></tr><tr><td>84</td><td>/user + /user/info + /user/*</td><td>user 结点有 1 个子结点（info） -> user 结点有 1 个子结点（info）和 1 个通配符子结点</td></tr><tr><td>86</td><td>/user + /user/* + /user/info</td><td>user 结点有 1 个通配符子结点 -> user 结点有 1 个子结点（info）和 1 个通配符结点子结点</td></tr><tr><td>88</td><td>/user + /user/* + /user/*/info</td><td>通配符结点后面不能有子结点，<strong>报错</strong></td></tr><tr><td>-</td><td>4 种结点混合，这里就不一个一个写了，场景太多了</td><td>-</td></tr></tbody></table><h3 id=前置后置工作成对出现>前置（后置）工作成对出现</h3><p>上面讨论前置（后置）工作的时候，都是以 &ldquo;前置（后置）工作是可以独立执行的整体&rdquo; 为前提讨论的。如果它们之间有合作关系，也就是需要相互传递数据，那么怎么办呢？这个放到下一篇里说：
<a href=/post/computer-science/programming-language/framework/web/golang/middleware_v2 title="Golang 实现简单的 Web 框架 &amp;ndash; middleware(中间件)">Golang 实现简单的 Web 框架 &ndash; middleware(中间件)</a></p></div><footer class=post-footer><div class=post-tags><a href=/tags/computer-science%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6>computer-science(计算机科学)</a>
<a href=/tags/programming-language%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80>programming-language(编程语言)</a>
<a href=/tags/framework%e6%a1%86%e6%9e%b6>framework(框架)</a>
<a href=/tags/web>web</a>
<a href=/tags/http>http</a>
<a href=/tags/router%e8%b7%af%e7%94%b1>router(路由)</a>
<a href=/tags/golang>golang</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
Golang 实现简单的 Web 框架 -- router(路由)</li><li class=post-copyright-author><strong>本文作者：</strong>
西柊慧音</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/computer-science/programming-language/framework/web/golang/router_v2/ title="Golang 实现简单的 Web 框架 -- router(路由)">/post/computer-science/programming-language/framework/web/golang/router_v2/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/computer-science/programming-language/framework/web/golang/middleware_v2/ rel=next title="Golang 实现简单的 Web 框架 -- middleware(中间件)"><i class="fa fa-chevron-left"></i> Golang 实现简单的 Web 框架 -- middleware(中间件)</a></div><div class="post-nav-prev post-nav-item"><a href=/post/computer-science/operating-system/linux/elf/ rel=prev title="ELF 文件">ELF 文件
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>西柊慧音</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.103.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.1 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":false,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.1","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.c997eeae723f2fcee19ae5066fcc64a49cefb92ddb75904efdb69a223e5a6740.js defer></script></body></html>