<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.103.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="Golang 实现简单的 Web 框架 -- router(路由)"><meta itemprop=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=keywords content="computer-science(计算机科学),programming-language(编程语言),framework(框架),web,http,router(路由),golang"><meta property="og:type" content="article"><meta property="og:title" content="Golang 实现简单的 Web 框架 -- router(路由)"><meta property="og:description" content><meta property="og:image" content="/image/pid49256268.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/computer-science/programming-language/framework/web/golang/router_v2/"><meta property="og:site_name" content="帕里特档案馆"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="西柊慧音"><meta property="article:published_time" content="2023-02-09 08:00:00 +0800 CST"><meta property="article:modified_time" content="2023-02-11 08:00:00 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.4da9279b6033ade10d67092d7bfb660265f9fa46c40974f17b13bfe235396546.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"router_v2","permalink":"/post/computer-science/programming-language/framework/web/golang/router_v2/","title":"Golang 实现简单的 Web 框架 -- router(路由)","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>Golang 实现简单的 Web 框架 -- router(路由) - 帕里特档案馆</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>帕里特档案馆</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>重建中</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>49</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#资料>资料</a></li><li><a href=#什么是-web-框架>什么是 WEB 框架</a></li><li><a href=#从-tcp-开始>从 TCP 开始</a></li><li><a href=#golang-的-net-包和-nethttp-包>Golang 的 <code>net</code> 包和 <code>net/http</code> 包</a></li><li><a href=#从最简单的场景开始>从最简单的场景开始</a></li><li><a href=#处理逻辑执行前需要一些前置后置工作>处理逻辑执行前需要一些前置（后置）工作</a><ul><li><a href=#所有的处理逻辑都需要>所有的处理逻辑都需要</a></li><li><a href=#部分处理逻辑需要>部分处理逻辑需要</a></li></ul></li><li><a href=#路由树>路由树</a><ul><li><a href=#路由树的高级玩法>路由树的高级玩法</a></li></ul></li><li><a href=#前置后置工作成对出现>前置（后置）工作成对出现</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=西柊慧音 src=/imgs/img-lazy-loading.gif data-src=/image/pid49256268.jpg><p class=site-author-name itemprop=name>西柊慧音</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>49</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>10</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>43</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/KelipuTe title="Github → https://github.com/KelipuTe" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=xhy_1365@sina.com title="E-Mail → xhy_1365@sina.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>E-Mail</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/computer-science/programming-language/framework/web/golang/router_v2/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=name content="西柊慧音"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="西柊慧音"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="Golang 实现简单的 Web 框架 -- router(路由)"><meta itemprop=description content="路由是什么；如何处理路由；"></span><header class=post-header><h1 class=post-title itemprop="name headline">Golang 实现简单的 Web 框架 -- router(路由)</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2023-02-09 08:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-02-09 08:00:00 +0800 CST">2023-02-09</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar-check"></i></span>
<span class=post-meta-item-text>更新于：</span>
<time title=修改时间：2023-02-11T08:00:00+08:00 itemprop=dateModified datetime=2023-02-11T08:00:00+08:00>2023-02-11</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/framework%E6%A1%86%E6%9E%B6 itemprop=url rel=index><span itemprop=name>framework(框架)</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>4194</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>9分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/post/computer-science/programming-language/framework/web/golang/router_v2/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><blockquote><p>CPU AMD64(x86_64)<br>Windows 11 家庭版<br>go version go1.19 windows/amd64</p></blockquote><h3 id=资料>资料</h3><ul><li><a href=https://github.com/KelipuTe/demo-golang title={demo-golang} rel="noopener external nofollow noreferrer" target=_blank class=exturl>{demo-golang}
<i class="fa fa-external-link-alt"></i>
</a>/demo/web/router/</li><li><a href=/drawio/computer-science/programming-language/framework/web/web.drawio.html>web.drawio.html</a></li></ul><h3 id=什么是-web-框架>什么是 WEB 框架</h3><p>简单的理解，WEB 框架就是工程师们在反复开发 WEB 系统的后台服务时，对于"如何处理重复的代码"这个问题，想出的一种解决方案。核心目标就是为了减少重复的代码，提高代码可读性和可维护性，提高编程的效率。</p><p>如果用比喻的话。WEB 框架就相当一个毛坯房，只有房屋的结构，但是里面没有装修。对于不同的业务系统来说，他们的内部处理的具体业务虽然是不同的（烘焙店和奶茶店会根据各自的需要进行相应的装修），但是具体业务依赖的代码工具（比如：参数校验、日志等）有可能是一样的（烘焙店和奶茶店都需要地基、房屋框架、墙面、屋顶）。</p><p>如果通过这些概念还是不怎么好理解什么是 WEB 框架，那么有一个更简单的理解。<strong>工程师们想偷懒</strong>（提高编程的效率），所以他们创造了一套工具（WEB 框架），<strong>减少复制粘贴代码的次数</strong>，<strong>减轻"一处要变，到处要改"带来的工作量</strong>。</p><p>那么问题来了，现在是知道有 WEB 框架这么个工具了，但是这个工具是怎么被创造出来的呢？想要理解这个问题，那就必须回到 WEB 框架这个概念还没有出现的"蛮荒时代"去。下面将结合代码来说明这个问题，代码将会使用 Golang 处理 HTTP 1.1 的请求。</p><h3 id=从-tcp-开始>从 TCP 开始</h3><p>别看见 TCP 就紧张，这里不要求深入了解 TCP 的细节，只需要知道 TCP 是一个字节流协议就可以了。字节流协议，它的意思就是说，传输数据的时候，它是以字节为单位的，传输的过程像流水一样，一个字节接着一个字节的。见图：<strong>web.drawio.html 2-2</strong>。</p><p>HTTP 1.1 是基于 TCP 协议实现的，所以 HTTP 1.1 也可以说是一种字节流协议。这里为什么要说这个呢？主要是想强调一下，在计算机的"眼里"，HTTP 报文它不是一个整体，而是一个一个字符。HTTP 1.1 报文大概的格式见图：<strong>web.drawio.html 2-4-2、2-4-4</strong>。</p><p>既然发出去的 HTTP 报文就是一串字符，那么如果不说明这串字符怎么解读，那这串字符就毫无意义。所以客户端和服务端会通过约定请求行的 method 和 url 来区分不同的报文。可以区分不同的报文之后，后面的 请求头部和请求体才有意义。分析 HTTP 报文是什么类型，然后根据类型提取报文中的数据的过程就是解析 HTTP 报文的过程。</p><h3 id=golang-的-net-包和-nethttp-包>Golang 的 <code>net</code> 包和 <code>net/http</code> 包</h3><p>在 <code>net</code> 包里，提供了对 TCP 的支持。而 <code>net/http</code> 包就是基于 <code>net</code> 包，实现了对 HTTP 协议的解析。这里就不费劲的从 TCP 开始搞了，怎么使用 TCP 和解析 HTTP 报文对理解 WEB 框架其实没啥帮助。所以直接从 <code>net/http</code> 包开始。</p><p>再继续之前，建议先看一下
<a href=/post/computer-science/programming-language/golang/http title="Golang 开启 HTTP 服务">Golang 开启 HTTP 服务
</a>。下面会直接从 Handler 接口的 ServeHTTP 方法切入。在 ServeHTTP 方法的第二个参数 <code>*Request</code> 里面，就可以拿到已经解析好的 HTTP 请求。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>type Handler interface {
</span></span><span style=display:flex><span>	ServeHTTP(ResponseWriter, *Request)
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=从最简单的场景开始>从最简单的场景开始</h3><p>如果啥都不考虑，那大可以直接用 if-else 的结构去判断 method 和 url，然后在 if-else 分支里面写各自的处理逻辑。如果把处理逻辑封装到方法面去，那这样的代码的逻辑其实是非常清晰的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func ServeHTTP(http.ResponseWriter, *http.Request) {
</span></span><span style=display:flex><span>	if Request.Method == &#34;GET&#34; {
</span></span><span style=display:flex><span>		if Request.URL == &#34;/user/id&#34; {
</span></span><span style=display:flex><span>			// /user/id 的处理逻辑
</span></span><span style=display:flex><span>		} else if Request.URL == &#34;/user/name&#34; {
</span></span><span style=display:flex><span>			// /user/name 的处理逻辑
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	} else if Request.Method == &#34;POST&#34; {
</span></span><span style=display:flex><span>		if Request.URL == &#34;/order/create&#34; {
</span></span><span style=display:flex><span>			// /order/create 的处理逻辑
</span></span><span style=display:flex><span>		} else if Request.URL == &#34;/order/delete&#34; {
</span></span><span style=display:flex><span>			// /order/delete 的处理逻辑
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>即使后面报文的类型越来越多，无非也就是 if-else 的分支多了一点。可以再对 url 的处理做一次封装，代码就可以拆开来了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func ServeHTTP(http.ResponseWriter, *http.Request) {
</span></span><span style=display:flex><span>	if Request.Method == &#34;GET&#34; {
</span></span><span style=display:flex><span>		handleGet()
</span></span><span style=display:flex><span>	} else if Request.Method == &#34;POST&#34; {
</span></span><span style=display:flex><span>		handlePost()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>func handleGet(){
</span></span><span style=display:flex><span>	if Request.URL == &#34;/user/id&#34; {
</span></span><span style=display:flex><span>		// /user/id 的处理逻辑
</span></span><span style=display:flex><span>	} else if Request.URL == &#34;/user/name&#34; {
</span></span><span style=display:flex><span>		// /user/name 的处理逻辑
</span></span><span style=display:flex><span>	} else if xxx {
</span></span><span style=display:flex><span>	} else if xxx {
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>func handlePost(){
</span></span><span style=display:flex><span>	if Request.URL == &#34;/order/create&#34; {
</span></span><span style=display:flex><span>		// /order/create 的处理逻辑
</span></span><span style=display:flex><span>	} else if Request.URL == &#34;/order/delete&#34; {
</span></span><span style=display:flex><span>		// /order/delete 的处理逻辑
</span></span><span style=display:flex><span>	} else if xxx {
</span></span><span style=display:flex><span>	} else if xxx {
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>就目前来看这种给 method 和 url 都写一个 if-else 的分支的写法，似乎并没有什么非常明显的弊端。这种结构也可以使用 map 结构代替。可以是一层的：<code>map[method+url]处理方法</code>，或者嵌套的：<code>map[method]{map[url]处理方法}</code>。</p><h3 id=处理逻辑执行前需要一些前置后置工作>处理逻辑执行前需要一些前置（后置）工作</h3><p>这里讨论的是前置（后置）工作相同的情况。如果每个处理逻辑需要执行的前置（后置）工作不同，那就退回到上面那种情况去了。前置（后置）工作相同的情况有几种：所有的处理逻辑都需要，部分处理逻辑需要。</p><h4 id=所有的处理逻辑都需要>所有的处理逻辑都需要</h4><p>这种场景非常好处理，直接在最外面写就好了。哪怕是多个或者有顺序要求的场景。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func ServeHTTP(http.ResponseWriter, *http.Request) {
</span></span><span style=display:flex><span>	// 前置工作 a
</span></span><span style=display:flex><span>	// 前置工作 b
</span></span><span style=display:flex><span>	if Request.Method == &#34;GET&#34; {
</span></span><span style=display:flex><span>		handleGet()
</span></span><span style=display:flex><span>	} else if Request.Method == &#34;POST&#34; {
</span></span><span style=display:flex><span>		handlePost()
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>	// 后置工作 c
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=部分处理逻辑需要>部分处理逻辑需要</h4><p>这种场景乍一看可以沿用"所有的处理逻辑都需要"的方案，把前置（后置）工作下放到每个 if-else 的分支里面去就好了。但是这么做是有问题的。</p><p>假设 <code>/user/id</code> 和 <code>/user/name</code> 都需要"前置工作 user"，<code>/user/id</code> 自己还需要"前置工作 user-id"，<code>/user/name</code> 自己还需要"后置工作 user-name"。如果按照上面的写法，代码会写成下面这样子。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func handleGet(){
</span></span><span style=display:flex><span>	if Request.URL == &#34;/user/id&#34; {
</span></span><span style=display:flex><span>		// 前置工作 user
</span></span><span style=display:flex><span>		// 前置工作 user-id
</span></span><span style=display:flex><span>		// /user/id 的处理逻辑
</span></span><span style=display:flex><span>	} else if Request.URL == &#34;/user/name&#34; {
</span></span><span style=display:flex><span>		// 前置工作 user
</span></span><span style=display:flex><span>		// /user/name 的处理逻辑
</span></span><span style=display:flex><span>		// 后置工作 user-name
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>乍一看问题不大，但是如果后面有 <code>/user/a</code>、<code>/user/b</code> 一直到 <code>/user/z</code> 呢。如果要求每个 <code>/user/</code> 开头的都需要"前置工作 user"。这时候上面这种写法，<code>// 前置工作 user</code> 就要写 n 次，<strong>很麻烦</strong>。如果后面要求变了，要求每个 <code>/user/</code> 开头的都需要"前置工作 user2"，或者这里就需要改 n 个地方，<strong>更麻烦</strong>。</p><p>所以要想办法，把这个公共的模块提取出去。比如变成下面这样，把有这种要求的 url 前缀单独拿到一个 if-else 的分支里去。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func handleGet(){
</span></span><span style=display:flex><span>	if Request.URL like &#34;/user/%&#34; {
</span></span><span style=display:flex><span>		// 前置工作 user
</span></span><span style=display:flex><span>		if Request.URL == &#34;/user/id&#34; {
</span></span><span style=display:flex><span>			// 前置工作 user-id
</span></span><span style=display:flex><span>			// /user/id 的处理逻辑
</span></span><span style=display:flex><span>		} else if Request.URL == &#34;/user/name&#34; {
</span></span><span style=display:flex><span>			// /user/name 的处理逻辑
</span></span><span style=display:flex><span>			// 后置工作 user-name
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		// 后置工作 user
</span></span><span style=display:flex><span>	} else {
</span></span><span style=display:flex><span>		if Request.URL == &#34;/order/id&#34; {
</span></span><span style=display:flex><span>			// /order/id 的处理逻辑
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>乍一看问题不大，如果要求每个 <code>/user/</code> 开头的从都需要"前置工作 user"变成都需要"前置工作 user2"，那么只需要改一处。但是如果前缀的层级很多呢，比如像加一个 <code>/user/info/a</code>，那上面这种写法就要变成。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func handleGet(){
</span></span><span style=display:flex><span>	if Request.URL like &#34;/user/%&#34; {
</span></span><span style=display:flex><span>		// 前置工作 user
</span></span><span style=display:flex><span>		if Request.URL like &#34;/user/info/%&#34; {
</span></span><span style=display:flex><span>			// 前置工作 user-info
</span></span><span style=display:flex><span>			if Request.URL == &#34;/user/info/a&#34; {
</span></span><span style=display:flex><span>				// /user/info/a 的处理逻辑
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		} else {
</span></span><span style=display:flex><span>			if Request.URL == &#34;/user/id&#34; {
</span></span><span style=display:flex><span>				// 前置工作 user-id
</span></span><span style=display:flex><span>				// /user/id 的处理逻辑
</span></span><span style=display:flex><span>			} else if Request.URL == &#34;/user/name&#34; {
</span></span><span style=display:flex><span>				// /user/name 的处理逻辑
</span></span><span style=display:flex><span>				// 后置工作 user-name
</span></span><span style=display:flex><span>			}
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		// 后置工作 user
</span></span><span style=display:flex><span>	} else {
</span></span><span style=display:flex><span>		if Request.URL == &#34;/order/id&#34; {
</span></span><span style=display:flex><span>			// /order/id 的处理逻辑
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>这样下去 if-else 的层级就越来越深了。if-else 的层级太深，不利于代码的可读性和可维护性。更重要的是，这样的代码改的时候找起来非常的麻烦。所以这个问题是需要规避的。那么怎么规避呢？可以使用有层次的结构。</p><p>比如：假设图书馆里有大量的书需要分类。那么可以先按书内容的类别，分到不同的楼层去。然后再按书的作者，分到不同的书架上去。如果想处理某一类的书，可以只在某个楼层内部操作，不会影响到别的楼层。如果想处理某一类的某个作者的书，可以只在某个楼层的某个书架上操作，不会影响到这个楼层的别的书架，更不会影响到别的楼层。</p><p>这里把这种结构画出来就很直观了。见图：<strong>web.drawio.html 4-2</strong>。这种结构在数据结构里对应的就是树形结构。把上面的 method、url、前置（后置）工作对应进去再画一张图。见图：<strong>web.drawio.html 4-4</strong>。</p><h3 id=路由树>路由树</h3><p>到这里所谓的路由树的概念就呼之欲出了。上面的那棵树的结点中记录了全路径，但是这其实是不需要的。当命中 <code>like "/user/%"</code> 分支往下走的时候，后面的 url 最前面的那段就肯定是 <code>/user/</code>。所以这里就可以借助前缀的思路，用 <code>/</code> 作为分隔标志，将上面的那棵树转化成前缀树。见图：<strong>web.drawio.html 4-6-2</strong>。注意有个根结点（<code>/</code> 结点）。</p><p>这样当一个 HTTP 请求过来的时候，先通过 method 判断应该到哪一棵路由树里去找。然后用 <code>/</code> 将 url 分开，依次去路由树里匹配，如果结点上有前置（后置）工作就需要记录下来。最后找到目标结点时，按照前置工作、处理逻辑、后置工作的顺序依次执行。</p><p>比如，在 <strong>web.drawio.html 4-6-2</strong> 这颗树里，访问 <code>/user/id</code> 的时候。依次会访问：<code>/</code> 结点；<code>user</code> 结点，记录下前置工作 user 和后置工作 user；<code>id</code> 结点，记录下"前置工作 user-id" 和 <code>/user/id</code> 的处理逻辑。见图：<strong>web.drawio.html 4-6-4</strong>。</p><p>执行的时候，从逻辑上考虑的话，应该是前面的结点的前置任务应该在前面，前面的结点的后置任务应该在后面。所以上面就应该按照"前置工作 user"、&ldquo;前置工作 user-id&rdquo;、<code>/user/id</code> 的处理逻辑、&ldquo;后置工作 user&rdquo; 的顺序依次执行。见图：<strong>web.drawio.html 4-6-4</strong>。</p><h4 id=路由树的高级玩法>路由树的高级玩法</h4><p>静态的路由匹配可以用上面的 if-else 分支或者路由树解决。但是一些高级玩法，比如：路径参数路由、正则匹配路由、通配符路由，这样的就没办法整。这里以路径参数路由为例。</p><p>比如，有 <code>user/:id</code> 这样一个路由，<code>:id</code> 的位置可以是任意的数字，对应的方法是 <code>GetUserById(id)</code>。最终达到的效果是：如果访问的是 <code>user/1</code>，那调用的时候就是 <code>GetUserById(1)</code>；如果访问的是 <code>user/2</code>，那调用的时候就是 <code>GetUserById(2)</code>；如果访问的是 <code>user/a</code>，那调用的时候就要报错。这样的就是路径参数路由。</p><p>对于这种 <code>:id</code> 的位置可以变的路由。if-else 分支肯定无解。因为，<code>:id</code> 可变，意味着这里会对应无穷多个 if-else 分支。路由树有没有解呢？路由树可以解决，路由树只需要在 user 结点上增加一个特殊的结点 <code>:id</code> ，专门用于处理路径参数路由即可。见图：<strong>web.drawio.html 4-8-2</strong>。</p><p>访问 <code>/user/1</code> 的时候。依次会访问：<code>/</code> 结点；<code>user</code> 结点。到了 <code>user</code> 结点之后，按照默认逻辑下面要找的是 1 结点，但是 <code>user</code> 结点下面只有 <code>info</code> 结点、<code>id</code> 结点，无法匹配。这个时候就可以尝试匹配 <code>:id</code> 结点，看看 1 符不符合 <code>:id</code> 结点的要求。</p><p>这里 <code>:id</code> 的位置可以是任意的数字，所以 1 是符合要求的，所以 <code>/user/1</code> 最终调用的就应该是 <code>:id</code> 结点的处理逻辑。见图：<strong>web.drawio.html 4-8-4</strong>。同理 <code>/user/a</code> 会因为匹配不到路由最终报错。见图：<strong>web.drawio.html 4-8-6</strong>。</p><p>路径参数路由的这种设计思路也可以用到正则匹配路由和通配符路由上去，都是设置特殊的结点。但是需要注意的是，这三个玩意匹配的时候可能都能匹配上，所以需要人为的定义这三个特殊的路由，哪个优先匹配，哪个最后匹配。</p><h3 id=前置后置工作成对出现>前置（后置）工作成对出现</h3><p>上面讨论前置（后置）工作的时候，都是以"前置（后置）工作是可以独立执行的整体"为前提讨论的。如果它们之间有合作关系，也就是需要相互传递数据，那么怎么办呢？这个放到下一篇里说：
<a href=/post/computer-science/programming-language/framework/web/golang/middleware_v2 title="Golang 实现简单的 Web 框架 &amp;ndash; middleware(中间件)">Golang 实现简单的 Web 框架 &ndash; middleware(中间件)</a></p></div><footer class=post-footer><div class=post-tags><a href=/tags/computer-science%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6>computer-science(计算机科学)</a>
<a href=/tags/programming-language%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80>programming-language(编程语言)</a>
<a href=/tags/framework%e6%a1%86%e6%9e%b6>framework(框架)</a>
<a href=/tags/web>web</a>
<a href=/tags/http>http</a>
<a href=/tags/router%e8%b7%af%e7%94%b1>router(路由)</a>
<a href=/tags/golang>golang</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
Golang 实现简单的 Web 框架 -- router(路由)</li><li class=post-copyright-author><strong>本文作者：</strong>
西柊慧音</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/computer-science/programming-language/framework/web/golang/router_v2/ title="Golang 实现简单的 Web 框架 -- router(路由)">/post/computer-science/programming-language/framework/web/golang/router_v2/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/computer-science/programming-language/framework/web/golang/middleware_v2/ rel=next title="Golang 实现简单的 Web 框架 -- middleware(中间件)"><i class="fa fa-chevron-left"></i> Golang 实现简单的 Web 框架 -- middleware(中间件)</a></div><div class="post-nav-prev post-nav-item"><a href=/post/computer-science/concurrency_issues/ rel=prev title=并发问题>并发问题
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>西柊慧音</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.103.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.1 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":false,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.1","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.c997eeae723f2fcee19ae5066fcc64a49cefb92ddb75904efdb69a223e5a6740.js defer></script></body></html>