<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.103.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="队列（Golang 实现）"><meta itemprop=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=keywords content="computer-science(计算机科学),programming-language(编程语言),golang,queue(队列),concurrent(并发)"><meta property="og:type" content="article"><meta property="og:title" content="队列（Golang 实现）"><meta property="og:description" content><meta property="og:image" content="/image/pid49256268.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/computer-science/programming-language/golang/queue/"><meta property="og:site_name" content="帕里特档案馆"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="西柊慧音"><meta property="article:published_time" content="2023-01-29 08:00:00 +0800 CST"><meta property="article:modified_time" content="2023-01-29 08:00:00 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.4da9279b6033ade10d67092d7bfb660265f9fa46c40974f17b13bfe235396546.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"queue","permalink":"/post/computer-science/programming-language/golang/queue/","title":"队列（Golang 实现）","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>队列（Golang 实现） - 帕里特档案馆</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>帕里特档案馆</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>重建中</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>36</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><ul><li><a href=#资料>资料</a></li><li><a href=#并发安全队列>并发安全队列</a></li><li><a href=#阻塞队列和非阻塞队列>阻塞队列和非阻塞队列</a></li><li><a href=#并发安全的有最大容量的队列>并发安全的有最大容量的队列</a></li><li><a href=#并发安全的没有最大容量的队列>并发安全的没有最大容量的队列</a></li><li><a href=#延迟队列>延迟队列</a></li><li><a href=#reference参考>reference（参考）</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=西柊慧音 src=/imgs/img-lazy-loading.gif data-src=/image/pid49256268.jpg><p class=site-author-name itemprop=name>西柊慧音</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>36</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>10</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>38</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/KelipuTe title="Github → https://github.com/KelipuTe" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=xhy_1365@sina.com title="E-Mail → xhy_1365@sina.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>E-Mail</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=goto-gtranslate class=button title=多语言翻译><i class="fas fa-globe"></i></div><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/computer-science/programming-language/golang/queue/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=name content="西柊慧音"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="西柊慧音"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="队列（Golang 实现）"><meta itemprop=description content="并发安全队列；优先队列；延迟队列；"></span><header class=post-header><h1 class=post-title itemprop="name headline">队列（Golang 实现）</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2023-01-29 08:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-01-29 08:00:00 +0800 CST">2023-01-29</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/golang itemprop=url rel=index><span itemprop=name>golang</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>4211</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>9分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/post/computer-science/programming-language/golang/queue/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><blockquote><p>CPU AMD64(x86_64)<br>Windows 11 家庭版<br>go version go1.19 windows/amd64</p></blockquote><h3 id=资料>资料</h3><ul><li><a href=https://github.com/KelipuTe/demo-golang title={demo-golang} rel="noopener external nofollow noreferrer" target=_blank class=exturl>{demo-golang}
<i class="fa fa-external-link-alt"></i>
</a>/demo/queue/</li><li><a href=/drawio/computer-science/programming-language/golang/queue.drawio.html>queue.drawio.html</a></li></ul><h3 id=并发安全队列>并发安全队列</h3><p>并发安全队列就是不会出现并发问题的队列。</p><p>关于并发问题的一些东西在这篇里：
<a href=/post/computer-science/concurrency_issues title=并发问题>并发问题</a></p><h3 id=阻塞队列和非阻塞队列>阻塞队列和非阻塞队列</h3><p>个人认为，一个队列是阻塞队列还是非阻塞队列，应该根据队列本身的设计判断。队列需不需要阻塞，是设计上决定的，和用锁还是用 CAS 是没关系的，这两个结构是为了解决并发问题的。</p><p>如果设计队列的时候，队列有最大容量。而且队列本身的设计中有阻塞的逻辑。这样的队列就是阻塞队列。比如，在入队阶段，判断队列容量已满的时候，不是直接返回入队失败，而是等待队列空出位置后在入队，那么这里就需要设计阻塞的逻辑。</p><p>反之，如果设计队列的时候，队列有最大容量，但是队列本身的设计中没有阻塞的逻辑，或者队列没有最大容量，那就是非阻塞队列。比如，在入队阶段，判断队列容量已满的时候，直接返回入队失败，那么这里就不需要设计阻塞的逻辑。</p><h3 id=并发安全的有最大容量的队列>并发安全的有最大容量的队列</h3><p>代码详见：</p><ul><li>{demo-golang}/demo/queue/concurrent_blocking_queue.go。</li><li>{demo-golang}/demo/queue/wait_cond.go。</li></ul><p>这里沿用上面的定义。想要一个并发安全的有最大容量的队列的两个要求：1、并发安全；2、有最大容量。这里用锁+环形数组实现。因为有最大容量的限制，所以肯定是需要阻塞的逻辑的。</p><p>从最简单的入队出队逻辑开始。入队：检查容量->(等待有空位：比如循环检查容量)->入队。出队：检查容量->(等待有数据：比如循环检查容量)->出队。这种结构可以满足有最大容量的要求，但是因为对临界资源（队列数据）的访问是没有限制的，所以这肯定不是并发安全的。</p><p>既然要保护临界资源，那么首先想到的肯定是加锁。Golang 里面就是 sync.Mutex 了。直接加锁行不行呢？入队：加锁->检查容量->(等待有空位：比如循环检查容量)->入队->解锁。出队：加锁->检查容量->(等待有数据：比如循环检查容量)->出队->解锁。这样的逻辑显然会在"等待有空位"和"等待有数据"这两个步骤产生死锁。</p><p>如果队列满了，&ldquo;等待有空位"这里就无法入队，导致锁放不掉。这里锁放不掉，出队那里就加不了锁，无法出队。如果队列为空，&ldquo;等待有数据"这里就无法出队，导致锁放不掉。这里锁放不掉，入队那里就加不了锁，无法入队。</p><p>所以加锁之后，&ldquo;等待有空位"和"等待有数据"这个两步骤需要修改。&ldquo;等待有空位"需要先解锁，这样出队那里就可以加锁。然后等待有空位。等到有空位之后，再加锁，然后入队。&ldquo;等待有数据"需要先解锁，这样入队那里就可以加锁。然后等待有数据。等到有数据之后，再加锁，然后出队。</p><p>大概的过程见图：<strong>queue.drawio.html 2-2、2-4</strong></p><p>Golang 里面提供了这种工具 sync.Cond。可以先看一眼官方提供的 sync.Cond.Wait() 里面的逻辑。执行逻辑很简单，大概是：获取一个用于等通知的结构；把拿着的锁放掉；阻塞，等通知；等到通知了，把锁加回来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func (c *Cond) Wait() {
</span></span><span style=display:flex><span>	c.checker.check()
</span></span><span style=display:flex><span>	t := runtime_notifyListAdd(&amp;c.notify)
</span></span><span style=display:flex><span>	c.L.Unlock()
</span></span><span style=display:flex><span>	runtime_notifyListWait(&amp;c.notify, t)
</span></span><span style=display:flex><span>	c.L.Lock()
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>有了这个结构。出队的那个地方出队的时候，发一个信号给"等待有空位"就行。入队的那个地方入队的时候，发一个信号给"等待有数据"就行。这样并发问题也就解决了。加锁可以在并发场景中保护队列数据的正确性，但是用 sync.Mutex 和 sync.Cond 有一个缺点，这玩意无法控制超时。</p><p>用 sync.Mutex 执行 sync.Mutex.Lock() 之后，gorouting 就陷进去了，直到它拿到锁，否则是不会出来的。用 sync.Cond 也一样。执行 sync.Cond.Wait() 之后，gorouting 一样会陷进去，直到它被 sync.Cond.Signal() 或者 sync.Cond.Broadcast() 发出的信号唤醒，否则也是不会出来的。</p><p>所以这里需要的是一个可以被控制的等待加锁的结构。也就是说要一个 sync.Mutex.Luck(time) 或者 sync.Cond.Wait(time) 这样的东西。如果一定时间拿不到锁，或者等不到信号，要能从阻塞状态退出来。</p><p>仔细观察一下 Wait() 的代码。里面加锁和解锁的步骤是必须的，所以核心问题其实就找到了。需要修改原有的等通知的逻辑，让这里变成既可以等待信号，同时也可以被 context 超时控制的结构。在 Golang 里面，等待信号可以使用 channel（管道）。这玩意可以变相的做到，既可以被阻塞，也可以在需要的时候被唤醒。</p><p>可以把读一个空的管道理解成阻塞，把从管道里读到东西理解成唤醒。如果需要模拟阻塞，那么就读一个空的管道就可以了。唤醒这里需要一点技巧，这里不能用往管道里写数据的方式去唤醒阻塞中的 gorouting。因为不知道到底有多少个 gorouting 在等着读数据，也就是不知道要写多少次数据。写少了，会有等着的 gorouting 读不到数据，会泄露。写多了自己会阻塞，也会泄露。</p><p>这里可以用直接关闭管道的思路，读取已经关闭的管道会读到零值。那么关闭一个有很多 gorouting 都在读取的管道，就相当于完成了一次 Broadcast()。但是这种操作无法实现 Signal()。新的方法里面的逻辑大概就是下面这样（伪代码）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func (p7this *Cond) WaitWithTimeout(ctx context.Context) error {
</span></span><span style=display:flex><span>	// 获取一个用于等通知的 channel
</span></span><span style=display:flex><span>	// 把拿着的锁放掉
</span></span><span style=display:flex><span>	select {
</span></span><span style=display:flex><span>	case &lt;-ctx.Done():
</span></span><span style=display:flex><span>		// 超时，这里就不用把锁加回来了。外层应该拿到这里的异常，然后执行异常处理逻辑。
</span></span><span style=display:flex><span>		return ctx.Err()
</span></span><span style=display:flex><span>	case &lt;-通知信号:
</span></span><span style=display:flex><span>		// 等到通知了，说明有 gorouting 调用了 Broadcast() 关闭了 channel，把锁加回来。
</span></span><span style=display:flex><span>		// 这个地方并没有完全解决超时的问题，因为这里加锁的逻辑还是有可能被阻塞的。
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=并发安全的没有最大容量的队列>并发安全的没有最大容量的队列</h3><p>代码详见：</p><ul><li>{demo-golang}/demo/queue/concurrent_nonblocking_queue.go。</li></ul><p>这里沿用上面的定义。想要一个并发安全的没有最大容量的队列的两个要求：1、并发安全；2、没有最大容量。这里用链表+CAS+自旋实现。因为没有最大容量，所以是不需要设计阻塞逻辑的。</p><p>还是从最简单的入队出队逻辑开始。因为没有最大容量，所以入队时是没有限制的。出队这里，和入队哪里保持一致，不设计阻塞逻辑。所以队列为空的时候，就直接返回一个异常就行。当然，出队如果想设计成一直等到有数据再出队的逻辑也不是不行。</p><p>所以基本的逻辑就可以定下来了。入队：入队。出队：检查队头->出队。和前面一样，因为对临界资源（队列数据）的访问是没有限制的，所以这肯定不是并发安全的。</p><p>如果选择用加锁的方式保护临界资源，那么基本思路就和前面的那个"并发安全的有最大容量的队列"是一样的。这里就不重复了，这里换另一个处理思路，用 CAS+自旋达到和锁一样的效果。改造后的步骤也不是很复杂。入队：准备好数据->使用 CAS 入队。出队：检查队头->使用 CAS 出队。</p><p>CAS 入队怎么入呢？入队的时候，最关心的是队尾，因为新结点会连接到原来的队尾结点上去，变成新的队尾结点。所以只要保护住"替换队尾结点"这个步骤，就能避免出现并发问题。所以 CAS 操作的目标就可以确定了，原来的队尾结点和新结点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func (p7this *Queue) Enqueue(ctx context.Context, data) error {
</span></span><span style=display:flex><span>	// 先把新的结点准备好
</span></span><span style=display:flex><span>	// 然后通过 CAS 操作挂到链表的尾部
</span></span><span style=display:flex><span>	for {
</span></span><span style=display:flex><span>		// 通过原子操作把队尾拿出来
</span></span><span style=display:flex><span>		// CAS 操作，如果当前的队尾指针就是上面取到的指针，那么把队尾换成新的结点
</span></span><span style=display:flex><span>		if atomic.CompareAndSwapPointer(队尾, 取到的队尾, 新结点) {
</span></span><span style=display:flex><span>			// CAS 返回成功，说明队尾没变，可以直接修改
</span></span><span style=display:flex><span>			// 把新结点接到原来的队尾结点上去
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		// CAS 返回失败，说明队尾变了，其他想要入队的，已经抢先入队而且完成了，那就要重头再来
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>CAS 出队怎么出呢？出队的时候，最关心的是队头，因为队头结点出队之后，队头结点的下一个结点会接替原来的队头结点成为新的队头结点。所以只要保护住"接替原来的队头结点"这个步骤，就能避免出现并发问题。所以 CAS 操作的目标就可以确定了，原来的队头结点和队头结点的下一个结点。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>func (p7this *Queue) Dequeue(ctx context.Context) (data, error) {
</span></span><span style=display:flex><span>	for {
</span></span><span style=display:flex><span>		// 检查队列是否为空
</span></span><span style=display:flex><span>		// 通过原子操作把队头拿出来
</span></span><span style=display:flex><span>		if atomic.CompareAndSwapPointer(队头, 取到的队头, 队头结点的下一个结点) {
</span></span><span style=display:flex><span>			// CAS 返回成功，说明队尾没变，可以直接修改
</span></span><span style=display:flex><span>			// 直接把结点上的数据取出来，然后出队就行了
</span></span><span style=display:flex><span>		}
</span></span><span style=display:flex><span>		// CAS 返回失败，说明队头变了，其他想要出队的，已经抢先出队而且完成了，那就要重头再来
</span></span><span style=display:flex><span>	}
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>思路比较简单，就是理解起来很不直观，这里需要借助调度时候的时序图来理解。详细的入队出队的调度过程见图。入队：<strong>queue.drawio.html 4-6、4-6-2、4-6-4、4-6-4-2、4-6-4-4</strong>。出队：<strong>queue.drawio.html 4-8、4-8-2、4-8-4、4-8-4-2、4-8-4-4</strong>。注意里面红色标记的结点，因为协程会在任意时刻被剥夺 CPU 资源，所以会出现部分步骤没完成的场景。</p><h3 id=延迟队列>延迟队列</h3><p>延迟队列就是进入队列的元素有时间属性，在时间到之前不能出队。入队的时候没有什么限制，问题在出队这里。简单的搞法，直接整一个轮询不停地全量扫描，这是可以达到目的的，就是会占用 CPU 资源。</p><p>但是如果队列里面的元素很多，那全量扫描的时间，说不定队列里面已经有元素到时间了。所以最好对队列元素进行排序，搞成有优先级的，这样每次只需要检查第一个元素就行了。</p><p>这里借助时间属性给元素确定优先级，那么时间小的就应该排在前面。加上需要不停地进行插入和删除操作，普通的数组就不太合适了，比较合适的数据结构是小根堆。</p><p>优先队列可以解决全量扫描的问题，但是暴力轮询的问题还没有解决。如果不暴力轮询，那么中间就需要加入阻塞等待的机制，这个就稍微麻烦一点了。</p><p>首先，阻塞固定的时间是肯定不行的，在这段时间里面，队头元素说不定已经到时间了。所以阻塞的时间肯定要根据队头元素来，队头元素还有多久到时间，那就阻塞多久。这种思路可以解决队列元素不变的情况。但是如果等待过程中，入队了一个优先级更高的元素。那么这个思路也是有问题的，阻塞之后来不及出来了。</p><p>所以这里需要监听两种信号，一种是队头元素到时间的信号，另一种是入队信号。监听到入队信号之后，检查一下入队的元素的优先级，如果优先级更高就需要调整阻塞的时间。</p><p>整体思路和前面的那个"并发安全的有最大容量的队列"是一样的，就是队列数据的存储结构不一样，然后就是增加了针对延时的逻辑。大概的过程见图：<strong>queue.drawio.html 6-2、6-4</strong></p><h3 id=reference参考>reference（参考）</h3><ul><li><a href=https://time.geekbang.org/ title=极客时间 rel="noopener external nofollow noreferrer" target=_blank class=exturl>极客时间
<i class="fa fa-external-link-alt"></i></a><ul><li>Go实战训练营<ul><li>并发等待队列实现</li></ul></li></ul></li></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/computer-science%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6>computer-science(计算机科学)</a>
<a href=/tags/programming-language%e7%bc%96%e7%a8%8b%e8%af%ad%e8%a8%80>programming-language(编程语言)</a>
<a href=/tags/golang>golang</a>
<a href=/tags/queue%e9%98%9f%e5%88%97>queue(队列)</a>
<a href=/tags/concurrent%e5%b9%b6%e5%8f%91>concurrent(并发)</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
队列（Golang 实现）</li><li class=post-copyright-author><strong>本文作者：</strong>
西柊慧音</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/computer-science/programming-language/golang/queue/ title="队列（Golang 实现）">/post/computer-science/programming-language/golang/queue/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/computer-science/concurrency_issues/ rel=next title=并发问题><i class="fa fa-chevron-left"></i> 并发问题</a></div><div class="post-nav-prev post-nav-item"><a href=/post/computer-science/programming-language/golang/context/ rel=prev title="Golang 的 context 包的使用">Golang 的 context 包的使用
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div id=gtranslate class=google-translate><i class="fa fa-language"></i><div id=google_translate_element></div></div><div class=copyright>&copy;
<span itemprop=copyrightYear>2010 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>西柊慧音</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.103.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.1 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":false,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.1","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.63938bd3b8224b34d4923b164da6be3911bfe7496b8d8106e8dc9afbd8676049.js defer></script></body></html>