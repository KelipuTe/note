<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.103.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="网络间进程间通信"><meta itemprop=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=keywords content="computer-science(计算机科学),operating-system(操作系统),network(网络),linux,linux-c,socket"><meta property="og:type" content="article"><meta property="og:title" content="网络间进程间通信"><meta property="og:description" content><meta property="og:image" content="/image/pid49256268.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/computer-science/network/socket/"><meta property="og:site_name" content="帕里特档案馆"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="西柊慧音"><meta property="article:published_time" content="2023-05-15 08:00:00 +0800 CST"><meta property="article:modified_time" content="2023-05-15 08:00:00 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.4da9279b6033ade10d67092d7bfb660265f9fa46c40974f17b13bfe235396546.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"socket","permalink":"/post/computer-science/network/socket/","title":"网络间进程间通信","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>网络间进程间通信 - 帕里特档案馆</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>帕里特档案馆</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>重建中</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>85</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#资料>资料</a></li><li><a href=#正文>正文</a><ul><li><a href=#socket>socket</a></li><li><a href=#sk_buff>sk_buff</a></li><li><a href=#socket-编程的大概流程>socket 编程的大概流程</a></li><li><a href=#创建-socket>创建 socket</a></li><li><a href=#tcp>TCP</a><ul><li><a href=#bind>bind()</a></li><li><a href=#主机字节序和点分十进制>主机字节序和点分十进制</a></li><li><a href=#端口占用>端口占用</a></li><li><a href=#listen>listen()</a></li><li><a href=#accept>accept()</a></li><li><a href=#readwrite>read()、write()</a></li><li><a href=#close>close()</a></li></ul></li><li><a href=#进程的-tcp-socket-网络表>进程的 TCP socket 网络表</a></li><li><a href=#http>HTTP</a></li><li><a href=#udp>UDP</a></li><li><a href=#进程的-udp-socket-网络表>进程的 UDP socket 网络表</a></li><li><a href=#tcp-和-udp-的区别>TCP 和 UDP 的区别</a></li><li><a href=#unix-socket>UNIX socket</a></li></ul></li><li><a href=#参考reference>参考（reference）</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=西柊慧音 src=/imgs/img-lazy-loading.gif data-src=/image/pid49256268.jpg><p class=site-author-name itemprop=name>西柊慧音</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>85</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>16</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>60</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/KelipuTe title="Github → https://github.com/KelipuTe" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=xhy_1365@sina.com title="E-Mail → xhy_1365@sina.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>E-Mail</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/computer-science/network/socket/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=name content="西柊慧音"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="西柊慧音"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="网络间进程间通信"><meta itemprop=description content="网络间进程间通信"></span><header class=post-header><h1 class=post-title itemprop="name headline">网络间进程间通信</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2023-05-15 08:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-05-15 08:00:00 +0800 CST">2023-05-15</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/operating-system%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F itemprop=url rel=index><span itemprop=name>operating-system(操作系统)</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>4861</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>10分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/post/computer-science/network/socket/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h2 id=前言>前言</h2><p>实践的环境：</p><ul><li>CPU AMD64(x86_64)</li><li>Windows 11 家庭版</li><li>VMware Workstation Pro 16</li><li>Ubuntu 22.04</li><li>Linux 5.19.0-32-generic x86_64</li><li>gcc (Ubuntu 11.3.0-1ubuntu1~22.04) 11.3.0</li></ul><h2 id=资料>资料</h2><ul><li><a href=https://github.com/KelipuTe/demo-c title={demo-c} rel="noopener external nofollow noreferrer" target=_blank class=exturl>{demo-c}
<i class="fa fa-external-link-alt"></i>
</a>/demo-in-linux/socket/</li><li><a href=/drawio/computer-science/network/socket.drawio.html>socket.drawio.html</a></li></ul><h2 id=正文>正文</h2><h3 id=socket>socket</h3><p>socket（套接字），就是对 &ldquo;网络中不同主机上的应用进程之间进行双向通信的端点&rdquo; 的抽象。</p><p>套接字（在一些资料里还称为套接口、数据接口）其实就是一个文件，这个文件是套接字文件描述符。</p><p>详细的内容在 Linux 文档 socket(7) 里面。</p><blockquote><p>socket(7)</br></br>socket(2) creates a socket,
connect(2) connects a socket to a remote socket address,
the bind(2) function binds a socket to a local socket address,
listen(2) tells the socket that new connections shall be accepted,
and accept(2) is used to get a new socket with a new incoming connection.</br></br>send(2), sendto(2), and sendmsg(2) send data over a socket,
and recv(2), recvfrom(2), recvmsg(2) receive data from a socket.
poll(2) and select(2) wait for arriving data or a readiness to send data.
In addition, the standard I/O operations like write(2), writev(2), sendfile(2),
read(2), and readv(2) can be used to read and write data.</br></br>getsockopt(2) and setsockopt(2) are used to set or get socket layer or protocol options.</br></br>close(2) is used to close a socket.</p></blockquote><p>基于 Linux 一切皆文件的理念，在内核中 socket 也是以文件的形式存在的。进程打开的 socket 是可以在进程的 fd 目录下看到的。</p><p>每个进程都有一个 task_struct 数据结构，该结构体里有一个指向文件描述符数组的成员指针。该数组里列出这个进程打开的所有文件的文件描述符。</p><p>数组的下标是文件描述符，是一个整数，而数组的内容是一个指针，指向内核中所有打开的文件的列表，也就是说内核可以通过文件描述符找到对应打开的文件。</p><p>每个文件都有一个 inode。socket 文件的 inode 指向了内核中的 socket 结构，在这个结构体里有两个队列，分别是发送队列和接收队列。</p><p>这个两个队列里面保存的是一个个 struct sk_buff，这些 sk_buff 用双向链表的组织形式串起来。</p><h3 id=sk_buff>sk_buff</h3><p>sk_buff 可以表示各个层的数据包，在应用层数据包叫 data，在 TCP 层我们称为 segment，在 IP 层叫 packet，在数据链路层称为 frame。</p><p>这样设计的原因是：协议栈采用的是分层结构，上层向下层传递数据时需要增加包头，下层向上层数据时又需要去掉包头。</p><p>如果每一层都用一个结构体，那在层之间传递数据的时候，就要发生多次拷贝，这将大大降低 CPU 效率。</p><p>调整 sk_buff 中 data 的指针，可以实现在层级之间传递数据时，不发生拷贝，只用 sk_buff 一个结构体来描述所有的网络包。</p><p>比如：当接收报文时，从网卡驱动开始，通过协议栈层层往上传送数据报，通过增加 skb->data 的值，来逐步剥离协议首部。</p><p>当要发送报文时，创建 sk_buff 结构体，数据缓存区的头部预留足够的空间，用来填充各层首部，在经过各下层协议时，通过减少 skb->data 的值来增加协议首部。</p><p>见图：<strong>socket.drawio.html 4-2</strong>。</p><h3 id=socket-编程的大概流程>socket 编程的大概流程</h3><p>见图：<strong>socket.drawio.html 2-2</strong>。</p><h3 id=创建-socket>创建 socket</h3><blockquote><p>socket(2)</br></br>AF_INET IPv4 Internet protocols ip(7)</br>AF_INET6 IPv6 Internet protocols ipv6(7)</br></br>SOCK_STREAM</br>Provides sequenced, reliable, two-way, connection-based byte streams.
An out-of-band data transmission mechanism may be supported.</br></br>SOCK_DGRAM</br>Supports datagrams (connectionless, unreliable messages of a fixed maximum length).</br></br>SOCK_NONBLOCK</br>Set the O_NONBLOCK file status flag on the open file description
(see open(2)) referred to by the new file descriptor.
Using this flag saves extra calls to fcntl(2) to achieve the same result.</p></blockquote><p>创建 socket 的时候，可以选择创建 ipv4 还是 ipv6 的（还有 UNIX 等），TCP 还是 UDP 的（还有 RAW 等）。</p><p>SOCK_STREAM 就是 TCP，提供有顺序、可靠、双向、基于连接的字节流。</p><p>SOCK_DGRAM 就是 UDP，支持数据包（最大长度固定的无连接、不可靠的消息）</p><p>OCK_NONBLOCK 表示非阻塞模式，调用 recv() 等的时候，不会阻塞。</p><p>下面的代码示例用的是，网络协议为 IPv4，传输协议为 TCP 的 socket。</p><h3 id=tcp>TCP</h3><p>TCP（Transmission Control Protocol，传输控制协议），可靠。</p><p>详细的内容在 Linux 文档 tcp(7) 里面。</p><h4 id=bind>bind()</h4><p>socket 创建好之后，调用 bind 函数，给 socket 绑定一个 IP 地址和端口。</p><p>绑定 IP 地址的目的，一台机器是可以有多个网卡的，每个网卡都有对应的 IP 地址，当绑定一个网卡时，内核在收到该网卡上的包，才会发给应用程序。</p><p>绑定端口的目的，当内核收到 TCP 报文，通过 TCP 头里面的端口号，来找到应用程序，然后把数据传递过来。</p><p>注意 bind() 系统调用的参数 &ldquo;const struct sockaddr *addr&rdquo;。这玩意在 socket 的 family 参数不一样的时候，是有区别的。</p><blockquote><p>bind(2)</br>The rules used in name binding vary between address families.
Consult the manual entries in Section 7 for detailed information.
For AF_INET, see ip(7); for AF_INET6, see ipv6(7); for AF_UNIX, see unix(7);</p></blockquote><p>ipv4 用的数据结构长这样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> sockaddr_in {
</span></span><span style=display:flex><span>    sa_family_t    sin_family; <span style=color:#75715e>/* address family: AF_INET */</span>
</span></span><span style=display:flex><span>    in_port_t      sin_port;   <span style=color:#75715e>/* port in network byte order */</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> in_addr sin_addr;   <span style=color:#75715e>/* internet address */</span>
</span></span><span style=display:flex><span>};
</span></span></code></pre></div><p>用的时候这样用。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>struct</span> sockaddr_in serverAddr;
</span></span><span style=display:flex><span>serverAddr.sin_family <span style=color:#f92672>=</span> AF_INET;
</span></span><span style=display:flex><span>serverAddr.sin_port <span style=color:#f92672>=</span> <span style=color:#ae81ff>0x1d25</span>;
</span></span><span style=display:flex><span>serverAddr.sin_addr.s_addr <span style=color:#f92672>=</span> INADDR_ANY;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>bind(sockfd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>serverAddr, <span style=color:#66d9ef>sizeof</span>(serverAddr));
</span></span></code></pre></div><h4 id=主机字节序和点分十进制>主机字节序和点分十进制</h4><p>上面在设置 socket 的时候，地址是 INADDR_ANY，端口是 0x1d25。这里用的是系统提供的常量和十六进制。</p><p>sin_port 参数，它是网络字节序的，这里的 0x1d25 设置的是 9501 端口。INADDR_ANY 就是点分十进制的 0.0.0.0。</p><p>9501（十进制）、00100101 00011101（二进制）、0x251d（十六进制）、0x1d25（网络字节序）</p><p>如果想直观的直接用 0.0.0.0 和 9501 进行设置。需要用到 htons() 和 inet_addr()。</p><p>htons() 把 16 位的主机字节序转换为网络字节序的。inet_addr() 把点分十进制的 ipv4 地址转换为二进制网络字节顺序的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span>serverAddr.sin_port <span style=color:#f92672>=</span> htons(<span style=color:#ae81ff>9501</span>);
</span></span><span style=display:flex><span>serverAddr.sin_addr.s_addr <span style=color:#f92672>=</span> inet_addr(<span style=color:#e6db74>&#34;0.0.0.0&#34;</span>);
</span></span></code></pre></div><h4 id=端口占用>端口占用</h4><p>再重复测试的时候，可能会遇到端口占用的报错，&ldquo;errno=98, error=Address already in use&rdquo;。</p><p>这个时候可以通过 setsockopt()，设置 socket 选项为 SO_REUSEPORT，来复用端口。另外，SO_REUSEADDR，可以用于重用地址。</p><blockquote><p>socket(7)</br>The socket options listed below can be set by using setsockopt(2)
and read with getsockopt(2) with the socket level set to SOL_SOCKET for all sockets.</br></br>SO_REUSEPORT</br>Permits multiple AF_INET or AF_INET6 sockets to be bound to an identical socket address.
This option must be set on each socket (including the first socket) prior to calling bind(2) on the socket.</br></br>SO_REUSEADDR</br>Indicates that the rules used in validating addresses supplied in a bind(2) call should allow reuse of local addresses.</p></blockquote><p>在调用 bind() 之前先调用 setsockopt() 对 socket 进行设置。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#66d9ef>int</span> sockfd <span style=color:#f92672>=</span> socket(AF_INET, SOCK_STREAM, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>setsockopt(sockfd, SOL_SOCKET, SO_REUSEPORT, <span style=color:#f92672>&amp;</span>report, <span style=color:#66d9ef>sizeof</span>(report));
</span></span><span style=display:flex><span>bind(sockfd, (<span style=color:#66d9ef>struct</span> sockaddr <span style=color:#f92672>*</span>)<span style=color:#f92672>&amp;</span>serverAddr, <span style=color:#66d9ef>sizeof</span>(serverAddr));
</span></span></code></pre></div><h4 id=listen>listen()</h4><p>绑定完 IP 地址和端口后，就可以调用 listen() 进行监听。如果要判定服务器中一个网络程序有没有启动，可以通过 netstat 命令查看对应的端口号是否有被监听。</p><blockquote><p>listen(2)</br>The backlog argument defines the maximum length to which the queue of pending connections for sockfd may grow.</p></blockquote><p>listen() 的 backlog 参数定义 sockfd 的挂起连接队列的最大长度。现在一般认为 backlog 参数是 Accept 队列的大小。</p><p>早期的 backlog 参数是指 SYN 队列的大小。Accept 队列的长度 = min(backlog, somaxconn)。somaxconn 是一个内核参数。</p><h4 id=accept>accept()</h4><p>服务端进入了监听状态后，通过调用 accept()，来从内核获取客户端的连接，如果没有客户端连接，则会阻塞等待客户端连接的到来。</p><p>客户端在创建好 socket 后，调用 connect() 发起连接，该函数的参数要指明服务端的 IP 地址和端口号，然后 TCP 三次握手就开始了。</p><p>客户端调用 connect() 成功返回，说明第二次握手完成。服务端调用 accept() 成功返回，说明第三次握手完成。</p><p>在 TCP 连接的过程中，服务器的内核实际上为每个 Socket 维护了两个队列：</p><ul><li>一个是还没完全建立连接的队列，称为 TCP 半连接队列，这个队列都是没有完成三次握手的连接，此时服务端处于 syn_rcvd 的状态；</li><li>一个是已经建立连接的队列，称为 TCP 全连接队列，这个队列都是完成了三次握手的连接，此时服务端处于 established 状态；</li></ul><p>当 TCP 全连接队列不为空后，服务端调用 accept() 时，就会从内核中的 TCP 全连接队列里拿出一个已经完成连接的 socket 返回应用程序，后续数据传输都用这个 socket。</p><p>监听的 socket 和真正用来传数据的 socket 是两个：一个叫作监听 socket；一个叫作已连接 socket。</p><h4 id=readwrite>read()、write()</h4><p>连接建立后，客户端和服务端就开始相互传输数据了，双方都可以通过调用 read() 和 write() 来读写数据。</p><h4 id=close>close()</h4><p>服务端接收到 FIN 报文后，会在接收缓冲区中插入一个 EOF。read() 可以从缓冲区中读到 EOF 标志。</p><p>代码示例：</p><ul><li>一次性的 TCP 服务端：<strong>{demo-c}/demo-in-linux/socket/tcp/server_once.c</strong></li><li>一次性的 TCP 客户端：<strong>{demo-c}/demo-in-linux/socket/tcp/client_once.c</strong></li></ul><h3 id=进程的-tcp-socket-网络表>进程的 TCP socket 网络表</h3><p>启动 server_multiple.c 服务端，得到进程号。然后，查看进程的内存目录里的 &ldquo;/proc/{pid}/fd/"。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>total 0
</span></span><span style=display:flex><span>lrwx------ 1 root root 64 Dec 18 05:53 0 -&gt; /dev/pts/1
</span></span><span style=display:flex><span>lrwx------ 1 root root 64 Dec 18 05:53 1 -&gt; /dev/pts/1
</span></span><span style=display:flex><span>lrwx------ 1 root root 64 Dec 18 05:53 2 -&gt; /dev/pts/1
</span></span><span style=display:flex><span>lrwx------ 1 root root 64 Dec 18 05:53 3 -&gt; socket:[20443]
</span></span></code></pre></div><p>这个 &ldquo;3 -> socket:[20443]"，就是 socket() 创建的。</p><p>然后，再查看 &ldquo;/proc/{pid}/net/tcp&rdquo; 文件。这个就是 TCP 的 socket 网络表。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>0: 00000000:251D 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 20443 1 0000000000000000 100 0 0 10 0
</span></span></code></pre></div><ul><li>local_address，前面是本地 ip，网络字节序，后面是本地端口，主机字节序。</li><li>rem_address，前面是远端 ip，网络字节序，后面是远端端口，主机字节序。</li><li>st（connection state），套接字状态，16 进制，具体解释看下面。</li></ul><p>st 字段的状态（10 进制）：</p><ul><li>TCP_ESTABLISHED:1</li><li>TCP_SYN_SENT:2</li><li>TCP_SYN_RECV:3</li><li>TCP_FIN_WAIT1:4</li><li>TCP_FIN_WAIT2:5</li><li>TCP_TIME_WAIT:6</li><li>TCP_CLOSE:7</li><li>TCP_CLOSE_WAIT:8</li><li>TCP_LAST_ACL:9</li><li>TCP_LISTEN:10</li><li>TCP_CLOSING:11</li></ul><p>使用 telnet 命令创建一个连接，<code>telnet 127.0.0.1 9501</code>。</p><p>然后，再去查看 &ldquo;/proc/{pid}/fd/&rdquo; 目录。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>total 0
</span></span><span style=display:flex><span>lrwx------ 1 root root 64 Dec 18 05:53 0 -&gt; /dev/pts/1
</span></span><span style=display:flex><span>lrwx------ 1 root root 64 Dec 18 05:53 1 -&gt; /dev/pts/1
</span></span><span style=display:flex><span>lrwx------ 1 root root 64 Dec 18 05:53 2 -&gt; /dev/pts/1
</span></span><span style=display:flex><span>lrwx------ 1 root root 64 Dec 18 05:53 3 -&gt; socket:[20443]
</span></span><span style=display:flex><span>lrwx------ 1 root root 64 Dec 18 05:53 4 -&gt; socket:[20444]
</span></span></code></pre></div><p>和之前比，这里多了一个 &ldquo;4 -> socket:[20444]"，这就是 accept() 创建的，对应连接上来的 TCP。</p><p>再看一眼 &ldquo;/proc/{pid}/net/tcp&rdquo; 文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>sl  local_address rem_address   st tx_queue rx_queue tr tm-&gt;when retrnsmt   uid  timeout inode
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>0: 00000000:251D 00000000:0000 0A 00000000:00000000 00:00000000 00000000     0        0 20443 1 0000000000000000 100 0 0 10 0
</span></span><span style=display:flex><span>2: 0100007F:251D 0100007F:DA50 01 00000000:00000000 00:00000000 00000000     0        0 20444 1 0000000000000000 20 0 0 10 -1
</span></span></code></pre></div><p>和之前比，这里多了 telnet 命令连接上来之后的一些数据，通过 local_address 和 rem_address 字段可以判断服务端和客户端。</p><p>用 uid 也可以对上，上面的 &ldquo;socket:[20443]&rdquo; 和 &ldquo;socket:[20444]&rdquo; 就是这里的 20443 和 20444。</p><h3 id=http>HTTP</h3><p>HTTP（Hyper Text Transfer Protocol，超文本传输协议），是一个简单的 &ldquo;请求-响应&rdquo; 协议，它通常运行在 TCP 之上。</p><p>在 TCP 的基础之上，对连接上来的客户端响应符合 HTTP 协议格式的数据，就可以实现简单的 HTTP 响应。</p><p>代码示例：</p><ul><li>一次性的 HTTP 服务端：<strong>{demo-c}/demo-in-linux/socket/http/server_once.c</strong></li><li>可重用的 HTTP 服务端：<strong>{demo-c}/demo-in-linux/socket/http/server_multiple.c</strong></li></ul><h3 id=udp>UDP</h3><p>UDP（User Datagram Protocol，用户数据包协议），不可靠，而且数据报会被重新排序。</p><p>详细的内容在 Linux 文档 udp(7) 里面。</p><p>注意，UDP 服务端不需要调用 listen()、connect()、accept()，因为 UDP 是不建立连接的。</p><p>代码示例：</p><ul><li>一次性的 UDP 服务端：<strong>{demo-c}/demo-in-linux/socket/udp/server_once.c</strong></li><li>一次性的 UDP 客户端：<strong>{demo-c}/demo-in-linux/socket/udp/client_once.c</strong></li><li>可重用的 UDP 服务端：<strong>{demo-c}/demo-in-linux/socket/udp/server_multiple.c</strong></li></ul><h3 id=进程的-udp-socket-网络表>进程的 UDP socket 网络表</h3><p>基本和 TCP 那里差不多，区别是 UDP 的文件是 &ldquo;/proc/{pid}/net/udp&rdquo;。</p><h3 id=tcp-和-udp-的区别>TCP 和 UDP 的区别</h3><p>TCP 调用 recv() 时，如果对端发送了多次，缓冲区有多少数据就读多少，不会丢失数据。</p><p>UDP 调用 recvfrom() 时，如果对端发送了多次，后面的数据会被丢弃。当发送端调用 sendto() 的次数和接收端调用 recvfrom() 的次数一样时才有可能获取完整的数据。</p><h3 id=unix-socket>UNIX socket</h3><p>UNIX socket 只能用于同一台机器上的进程间通信。ipv4 的 TCP 和 UDP 需要走网卡，UNIX socket 不需要。</p><p>UNIX socket 的类型也有 TCP 和 UDP 两种，但是 UNIX socket 的 UDP 是可靠的，而且数据报不会重新排序。</p><p>详细的内容在 Linux 文档 unix(7) 里面。</p><p>注意，UNIX socket 还分匿名的和命名的，这两个创建方式不一样。</p><p>匿名的，要用 socketpair() 创建一对 socket。命名的，和 ipv4 的 TCP、UDP 使用起来差不多。</p><p>代码示例：</p><ul><li>匿名 UNIX socket：<strong>{demo-c}/demo-in-linux/unix-socket/unnamed/unnamed.c</strong></li></ul><blockquote><p>socket(2)</br>AF_LOCAL Synonym for AF_UNIX</p></blockquote><p>命名的，创建 socket 的时候，socket() 的 domain 参数和上面 ipv4 的也不一样了，UNIX socket 是 AF_LOCAL。</p><p>绑定的时候也不是绑端口了，而是绑定文件描述符。而且如果想交互的话，服务端和客户端，需要各自创建自己的文件描述符。</p><p>注意，一定是，服务端和客户端各一个。在 ipv4 的 TCP 和 UDP 里面，这两个文件描述符，分别是 socket() 和 accept() 创建的。</p><p>代码示例：</p><ul><li>一次性的 TCP 服务端：<strong>{demo-c}/demo-in-linux/unix-socket/tcp/server_once.c</strong></li><li>一次性的 TCP 客户端：<strong>{demo-c}/demo-in-linux/unix-socket/tcp/client_once.c</strong></li><li>一次性的 UDP 服务端：<strong>{demo-c}/demo-in-linux/unix-socket/udp/server_once.c</strong></li><li>一次性的 UDP 客户端：<strong>{demo-c}/demo-in-linux/unix-socket/udp/client_once.c</strong></li></ul><h2 id=参考reference>参考（reference）</h2><ul><li>{小林coding}/
<a href=https://xiaolincoding.com/os/ title=图解系统 rel="noopener external nofollow noreferrer" target=_blank class=exturl>图解系统
<i class="fa fa-external-link-alt"></i></a><ul><li>9.2 I/O 多路复用：select/poll/epoll</li></ul></li><li>{51CTO学堂}/{可用行师}/
<a href=https://edu.51cto.com/course/28903.html title="Linux C核心技术" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Linux C核心技术
<i class="fa fa-external-link-alt"></i></a><ul><li>网络间进程间通信部分、socket 部分、TCP 部分、UDP 部分</li></ul></li><li><a href=https://blog.csdn.net/whatday/article/details/100693051 title="linux /proc/net/tcp 文件分析" rel="noopener external nofollow noreferrer" target=_blank class=exturl>linux /proc/net/tcp 文件分析
<i class="fa fa-external-link-alt"></i></a></li><li><a href=https://chat.openai.com/ title=ChatGPT rel="noopener external nofollow noreferrer" target=_blank class=exturl>ChatGPT
<i class="fa fa-external-link-alt"></i></a> +
<a href=https://www.deepl.com/translator title=DeepL rel="noopener external nofollow noreferrer" target=_blank class=exturl>DeepL
<i class="fa fa-external-link-alt"></i></a></li></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/computer-science%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6>computer-science(计算机科学)</a>
<a href=/tags/operating-system%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f>operating-system(操作系统)</a>
<a href=/tags/network%e7%bd%91%e7%bb%9c>network(网络)</a>
<a href=/tags/linux>linux</a>
<a href=/tags/linux-c>linux-c</a>
<a href=/tags/socket>socket</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
网络间进程间通信</li><li class=post-copyright-author><strong>本文作者：</strong>
西柊慧音</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/computer-science/network/socket/ title=网络间进程间通信>/post/computer-science/network/socket/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/computer-science/operating-system/linux/notice/ rel=next title="在 Linux 系统中使用 C 语言进行编程的注意点"><i class="fa fa-chevron-left"></i> 在 Linux 系统中使用 C 语言进行编程的注意点</a></div><div class="post-nav-prev post-nav-item"><a href=/post/computer-science/application/docker/windows/ rel=prev title="Windows 10 环境使用 Docker">Windows 10 环境使用 Docker
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>西柊慧音</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.103.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.1 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":false,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.1","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.c997eeae723f2fcee19ae5066fcc64a49cefb92ddb75904efdb69a223e5a6740.js defer></script></body></html>