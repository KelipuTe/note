<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.103.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="内存中的指令和数据"><meta itemprop=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=keywords content="computer-science(计算机科学),operating-system(操作系统),memory(内存)"><meta property="og:type" content="article"><meta property="og:title" content="内存中的指令和数据"><meta property="og:description" content><meta property="og:image" content="/image/pid49256268.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/computer-science/operating-system/memory/instruction_and_data/"><meta property="og:site_name" content="帕里特档案馆"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="西柊慧音"><meta property="article:published_time" content="2023-06-28 08:00:00 +0800 CST"><meta property="article:modified_time" content="2023-06-28 08:00:00 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.4da9279b6033ade10d67092d7bfb660265f9fa46c40974f17b13bfe235396546.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"instruction_and_data","permalink":"/post/computer-science/operating-system/memory/instruction_and_data/","title":"内存中的指令和数据","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>内存中的指令和数据 - 帕里特档案馆</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>帕里特档案馆</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>重建中</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>96</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#资料>资料</a></li><li><a href=#正文>正文</a><ul><li><a href=#内存地址>内存地址</a></li><li><a href=#起始地址>起始地址</a></li><li><a href=#指令>指令</a><ul><li><a href=#gdb-调试>gdb 调试</a></li></ul></li><li><a href=#数据>数据</a><ul><li><a href=#gdb-调试-1>gdb 调试</a></li></ul></li><li><a href=#有意思的来了>有意思的来了</a></li><li><a href=#栈>栈</a></li><li><a href=#堆>堆</a></li><li><a href=#指针>指针</a></li><li><a href=#字符串>字符串</a></li><li><a href=#数组>数组</a></li><li><a href=#结构体>结构体</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=西柊慧音 src=/imgs/img-lazy-loading.gif data-src=/image/pid49256268.jpg><p class=site-author-name itemprop=name>西柊慧音</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>96</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>17</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>64</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/KelipuTe title="Github → https://github.com/KelipuTe" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=xhy_1365@sina.com title="E-Mail → xhy_1365@sina.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>E-Mail</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/computer-science/operating-system/memory/instruction_and_data/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=name content="西柊慧音"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="西柊慧音"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="内存中的指令和数据"><meta itemprop=description content="指令；数据；栈和堆；指针；字符串；数组；结构体；"></span><header class=post-header><h1 class=post-title itemprop="name headline">内存中的指令和数据</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2023-06-28 08:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-06-28 08:00:00 +0800 CST">2023-06-28</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/operating-system%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F itemprop=url rel=index><span itemprop=name>operating-system(操作系统)</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>4134</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>9分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/post/computer-science/operating-system/memory/instruction_and_data/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h2 id=前言>前言</h2><p>这篇笔记需要 elf、linux 进程的内存布局、gdb 调试相关的知识。</p><h2 id=资料>资料</h2><p>笔记里的代码都在
<a href=https://github.com/KelipuTe/demo-c title={demo-c} rel="noopener external nofollow noreferrer" target=_blank class=exturl>{demo-c}
<i class="fa fa-external-link-alt"></i>
</a>/demo-in-linux/memory/ 目录下。</p><p>图在 <a href=/drawio/computer-science/operating-system/memory/memory.drawio.html>memory.drawio.html</a> 里面。</p><h2 id=正文>正文</h2><h3 id=内存地址>内存地址</h3><p>内存的存储单元会根据 CPU 的位宽以 16 进制从 0 开始顺序编号。
每个存储单元只对应一个编号，且只可以存储一个 byte 的数据。</p><p>32 位 CPU 最大的内存地址是 0xffffffff，容量为 2^32 字节
64 位 CPU 最大的内存地址是 0xffffffffffffffff，容量为 2^64 字节。</p><h3 id=起始地址>起始地址</h3><p>起始地址（首地址、基地址、基址），指的是代码块（函数）或者数据（变量）所占内存空间的第一个存储单元的地址。</p><h3 id=指令>指令</h3><p>这里的指令说的是代码块（函数）。函数的起始地址在编译时就已经确定了。</p><p>代码：instruction_in_memory.c</p><p>从 <code>readelf -s</code> 的结果里，找到代码块（methodA）的信息。
这里可以看到，代码块的起始地址是 0x1149，代码块的长度是 15。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Symbol table &#39;.symtab&#39; contains 37 entries:
</span></span><span style=display:flex><span>   Num:    Value          Size Type    Bind   Vis      Ndx Name
</span></span><span style=display:flex><span>    23: 0000000000001149    15 FUNC    GLOBAL DEFAULT   16 methodA
</span></span></code></pre></div><p>然后，在 <code>objdump -s</code> 的结果里，找到起始地址的位置。
从起始地址开始的 15 个字节就是代码块对应的数据了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Contents of section .text:
</span></span><span style=display:flex><span> 1140 ________ ________ __f30f1e fa554889  .....w.......UH.
</span></span><span style=display:flex><span> 1150 e5b80004 00005dc3 ________ ________  ......].....UH..
</span></span></code></pre></div><p>起始地址也占了一个位置，所以计算结束地址的时候不是直接加代码块的大小。
起始地址为 0x1149，结束地址为 0x1157 = 起始地址（16） + (15-1)（10）</p><p>也就是 0x1149,0x114a,0x114b,0x114c,0x114d,0x114e,0x114f,0x1150,0x1151,0x1152,0x1153,0x1154,0x1155,0x1156,0x1157，
这 15 个地址上的数据。</p><p>可以再看一眼汇编代码，在 <code>objdump -d</code> 的结果里，找到起始地址的位置。
这里的数据和上面的 15 个字节的数据是一样的，这里详细的标注了每一个字节对应的汇编代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Disassembly of section .text:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>0000000000001149 &lt;methodA&gt;:
</span></span><span style=display:flex><span>    1149:	f3 0f 1e fa          	endbr64 
</span></span><span style=display:flex><span>    114d:	55                   	push   %rbp
</span></span><span style=display:flex><span>    114e:	48 89 e5             	mov    %rsp,%rbp
</span></span><span style=display:flex><span>    1151:	b8 00 04 00 00       	mov    $0x400,%eax
</span></span><span style=display:flex><span>    1156:	5d                   	pop    %rbp
</span></span><span style=display:flex><span>    1157:	c3                   	ret
</span></span></code></pre></div><h4 id=gdb-调试>gdb 调试</h4><p>先打印一下代码块在程序中的起始地址，然后，打印从起始地址开始的 15 个地址上的数据。和上面一样的对吧。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(gdb) p methodA
</span></span><span style=display:flex><span>$1 = {int ()} 0x555555555149 &lt;methodA&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(gdb) x/15xb 0x555555555149
</span></span><span style=display:flex><span>0x555555555149 &lt;methodA&gt;:	0xf3	0x0f	0x1e	0xfa	0x55	0x48	0x89	0xe5
</span></span><span style=display:flex><span>0x555555555151 &lt;methodA+8&gt;:	0xb8	0x00	0x04	0x00	0x00	0x5d	0xc3
</span></span></code></pre></div><p>通过遍历也可以在程序里一个字节一个字节的打印代码块对应的内存地址上的内容。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>&amp;methodA=0x56025d439149
</span></span><span style=display:flex><span>[0x56025d439149]=fffffff3
</span></span><span style=display:flex><span>[0x56025d43914a]=0f
</span></span><span style=display:flex><span>[0x56025d43914b]=1e
</span></span><span style=display:flex><span>[0x56025d43914c]=fffffffa
</span></span><span style=display:flex><span>[0x56025d43914d]=55
</span></span><span style=display:flex><span>[0x56025d43914e]=48
</span></span><span style=display:flex><span>[0x56025d43914f]=ffffff89
</span></span><span style=display:flex><span>[0x56025d439150]=ffffffe5
</span></span><span style=display:flex><span>[0x56025d439151]=ffffffb8
</span></span><span style=display:flex><span>[0x56025d439152]=00
</span></span><span style=display:flex><span>[0x56025d439153]=04
</span></span><span style=display:flex><span>[0x56025d439154]=00
</span></span><span style=display:flex><span>[0x56025d439155]=00
</span></span><span style=display:flex><span>[0x56025d439156]=5d
</span></span><span style=display:flex><span>[0x56025d439157]=ffffffc3
</span></span></code></pre></div><p>这里打印 f3 出来 fffffff3 是因为符号扩展（sign extension），这里简单解释一下。
当 0xc3 被存储在 1 个字节的 char 变量中，被提升为 4 个字节的 int 或者被以十六进制打印时。
前面不是有三个字节的空位嘛，这个时候会扩展符号位以填充前面的空位，这样，就得到了 0xffffffc3。</p><h3 id=数据>数据</h3><p>全局变量的起始地址在编译时就已经确定了。</p><p>代码：data_in_memory.c</p><p>从 <code>readelf -s</code> 的结果里，找到数据（globalI）的信息。
这里可以看到，数据的起始地址是 0x4010，数据的长度是 4。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Symbol table &#39;.symtab&#39; contains 37 entries:
</span></span><span style=display:flex><span>   Num:    Value          Size Type    Bind   Vis      Ndx Name
</span></span><span style=display:flex><span>    27: 0000000000004010     4 OBJECT  GLOBAL DEFAULT   25 globalI
</span></span></code></pre></div><p>然后，在 <code>objdump -s</code> 的结果里，找到起始地址的位置。
从起始地址开始的 4 个字节就是代码块对应的数据了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Contents of section .data:
</span></span><span style=display:flex><span> 4000 00000000 00000000 08400000 00000000  .........@......
</span></span><span style=display:flex><span> 4010 00040000 
</span></span></code></pre></div><p>起始地址为 0x4010，结束地址为 0x4013 = 起始地址（16） + 3（10）</p><p>也就是 0x4010,0x4011,0x4012,0x4013 这 4 个地址上的数据。</p><h4 id=gdb-调试-1>gdb 调试</h4><p>这里和指令那里一样，先打印数据的起始地址，然后，打印地址上的数据。注意，数据在内存中是小端字节序。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(gdb) p &amp;globalI
</span></span><span style=display:flex><span>$3 = (int *) 0x555555558010 &lt;globalI&gt;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(gdb) x/4xb 0x555555558010
</span></span><span style=display:flex><span>0x555555558010 &lt;globalI&gt;:	0x00	0x04	0x00	0x00
</span></span></code></pre></div><p>和指令那里一样，也通过遍历也可以在程序里一个字节一个字节的打印数据对应的内存地址上的内容。</p><p>但是，要注意。对 int 类型进行取地址操作，拿到的是 int*。对 int* +1 会移动4个字节，这不是我们想要的。
如果想输出 int 类型的每个字节，首先需要将起始地址转换成 chat*，chat* +1 移动的就是 1 个字节了。</p><h3 id=有意思的来了>有意思的来了</h3><p>如果在代码块里直接返回全局变量会怎么样呢。</p><p>代码：return_global.c</p><p>从 <code>readelf -s</code> 的结果里，找到代码块（methodA）和数据（globalI）的信息。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>Symbol table &#39;.symtab&#39; contains 38 entries:
</span></span><span style=display:flex><span>   Num:    Value          Size Type    Bind   Vis      Ndx Name
</span></span><span style=display:flex><span>    23: 0000000000001149    16 FUNC    GLOBAL DEFAULT   16 methodA
</span></span><span style=display:flex><span>    28: 0000000000004010     4 OBJECT  GLOBAL DEFAULT   25 globalI
</span></span></code></pre></div><p>然后，我们看汇编代码，在 <code>objdump -d</code> 的结果里，找到代码块对应的汇编代码。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>0000000000001149 &lt;methodA&gt;:
</span></span><span style=display:flex><span>    1149:	f3 0f 1e fa          	endbr64 
</span></span><span style=display:flex><span>    114d:	55                   	push   %rbp
</span></span><span style=display:flex><span>    114e:	48 89 e5             	mov    %rsp,%rbp
</span></span><span style=display:flex><span>    1151:	8b 05 b9 2e 00 00    	mov    0x2eb9(%rip),%eax        # 4010 &lt;globalI&gt;
</span></span><span style=display:flex><span>    1157:	5d                   	pop    %rbp
</span></span><span style=display:flex><span>    1158:	c3                   	ret
</span></span></code></pre></div><p>globalI 是全局变量，methodA 的代码里直接返回了全局变量，这里的汇编代码，methodA 直接就用了 globalI 的地址。</p><h3 id=栈>栈</h3><p>代码：stack.c</p><p>静态分配的内存在栈区，比如，函数里面的局部变量，每次执行的时候都不一样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(gdb) p &amp;localI
</span></span><span style=display:flex><span>$1 = (int *) 0x7fffffffdeb4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(gdb) x/4xb 0x7fffffffdeb4
</span></span><span style=display:flex><span>0x7fffffffdeb4:	0x00	0x04	0x00	0x00
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]
</span></span></code></pre></div><p>可以和进程的内存信息比对一下。
0x7ffffffde000（栈堆首地址） &lt; 0x7fffffffdeb4（变量首地址） &lt; 0x7ffffffff000（栈堆尾地址）</p><h3 id=堆>堆</h3><p>代码：heap.c</p><p>动态分配的内存在堆区，比如，给指针申请一块内存。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(gdb) p p7LocalJ
</span></span><span style=display:flex><span>$1 = (int *) 0x5555555596b0
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(gdb) x/4xb 0x5555555596b0
</span></span><span style=display:flex><span>0x5555555596b0:	0x00	0x08	0x00	0x00
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>555555559000-55555557a000 rw-p 00000000 00:00 0                          [heap]
</span></span></code></pre></div><p>可以和进程的内存信息比对一下。
0x555555559000（堆首地址） &lt; 0x5555555596b0（变量地址） &lt; 0x55555557a000（堆尾地址）</p><h3 id=指针>指针</h3><p>代码：pointer.c</p><p>首先定义一个变量，比如，定义一个 int 类型的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(gdb) p &amp;localI
</span></span><span style=display:flex><span>$2 = (int *) 0x7fffffffdea4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(gdb) x/4xb 0x7fffffffdea4
</span></span><span style=display:flex><span>0x7fffffffdea4:	0x00	0x04	0x00	0x00
</span></span></code></pre></div><p>二级指针</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(gdb) p p7LocalI
</span></span><span style=display:flex><span>$4 = (int *) 0x7fffffffdea4
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(gdb) p &amp;p7LocalI
</span></span><span style=display:flex><span>$3 = (int **) 0x7fffffffdea8
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>(gdb) x/8xb 0x7fffffffdea8
</span></span><span style=display:flex><span>0x7fffffffdea8:	0xa4	0xde	0xff	0xff	0xff	0x7f	0x00	0x00
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(gdb) p p7LocalII
</span></span><span style=display:flex><span>$5 = (int **) 0x7fffffffdea8
</span></span><span style=display:flex><span>(gdb) p &amp;p7LocalII
</span></span><span style=display:flex><span>$6 = (int ***) 0x7fffffffdeb0
</span></span><span style=display:flex><span>(gdb) x/8xb &amp;p7LocalII
</span></span><span style=display:flex><span>0x7fffffffdeb0:	0xa8	0xde	0xff	0xff	0xff	0x7f	0x00	0x00
</span></span></code></pre></div><p>我画了个图，<strong>memory.drawio.html 2-2、代码的运行结果在内存里的结构，以及得到结果的过程</strong></p><h3 id=字符串>字符串</h3><p>代码：string.c</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>&amp;strA=0x7fffffffdea0,strA=stringA
</span></span><span style=display:flex><span>&amp;strB=0x55555555601e,strB=stringB
</span></span><span style=display:flex><span>&amp;strB=0x555555556038,strB=stringBB
</span></span><span style=display:flex><span>&amp;strC=0x5555555596b0,strC=stringC
</span></span></code></pre></div><p>打印几个指针指向的地址，然后，结合 &ldquo;proc/{pid}/maps&rdquo; 看一下内存。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>555555556000-555555557000 r--p 00002000 00:25 48                         /mnt/hgfs/demo-c/demo-in-linux/memory/string.elf
</span></span><span style=display:flex><span>555555559000-55555557a000 rw-p 00000000 00:00 0                          [heap]
</span></span><span style=display:flex><span>7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]
</span></span></code></pre></div><p>strA 字符数组地址指向了栈，strB 指针两次都指向了 string.elf 文件，strC 字符数组地址指向了堆。</p><p>这里，因为是字符串，所以，可以直接在 <code>objdump -s</code> 命令输出的结果里面查找这几个字符串值。
这里直接说结论了，stringA 和 stringC 在 &ldquo;.text&rdquo; 段里面，stringB 和 stringBB 在 &ldquo;.rodata&rdquo; 段里面。
此外，在 &ldquo;.rodata&rdquo; 段里面，还可以看到很多写死在程序里的字符串。比如, 写在 printf() 里面的字符串。</p><p>stringA 和 stringC 这两个字符串只是初始化的时候长这样，底下真正对应的字符数组是可变的。</p><p>stringA 是一个字符数组的值，这个字符数组，存储在栈里面，编译的时候就知道有多大了。
存储在栈里面的字符数组是可变的，stringA 只用于初始化。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(gdb) p strA
</span></span><span style=display:flex><span>$1 = &#34;stringA\000\000\000\000\000\000\000\000&#34;
</span></span><span style=display:flex><span>(gdb) p &amp;strA
</span></span><span style=display:flex><span>$2 = (char (*)[16]) 0x7fffffffdea0
</span></span><span style=display:flex><span>(gdb) x/16xb 0x7fffffffdea0
</span></span><span style=display:flex><span>0x7fffffffdea0:	0x73	0x74	0x72	0x69	0x6e	0x67	0x41	0x00
</span></span><span style=display:flex><span>0x7fffffffdea8:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
</span></span></code></pre></div><p>同理 stringC 是一个字符数组的值，这个字符数组是程序运行的时候动态申请的内存，动态申请的内存在堆里面。
存储在堆里面的字符数组是可变的，stringC 只用于初始化。</p><p>stringB 和 stringBB
并没有开辟内存去存它们，程序运行起来之后，也没有办法去修改它们的值。所以，在编译的时候，就放到了只读数据段，也就是 &ldquo;.rodata&rdquo;
段。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>Contents of section .rodata:
</span></span><span style=display:flex><span> 2000 01000200 7069643d 25640a00 26737472  ....pid=%d..&amp;str
</span></span><span style=display:flex><span> 2010 413d2570 2c737472 413d2573 0a007374  A=%p,strA=%s..st
</span></span><span style=display:flex><span> 2020 72696e67 42002673 7472423d 25702c73  ringB.&amp;strB=%p,s
</span></span><span style=display:flex><span> 2030 7472423d 25730a00 73747269 6e674242  trB=%s..stringBB
</span></span><span style=display:flex><span> 2040 00267374 72433d25 702c7374 72433d25  .&amp;strC=%p,strC=%
</span></span><span style=display:flex><span> 2050 730a006d 616c6c6f 635f7573 61626c65  s..malloc_usable
</span></span><span style=display:flex><span> 2060 5f73697a 65287374 7243293d 256c640a  _size(strC)=%ld.
</span></span><span style=display:flex><span> 2070 00 
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>malloc_usable_size(strC)=24
</span></span></code></pre></div><p>malloc_usable_size() 返回由 malloc() 或其他内存分配函数分配的内存块的大小。
由于内存对齐或者其他的因素，这个大小可能与传递给 malloc() 或其他内存分配函数的大小不同。</p><p>在示例代码 string.c 中使用 malloc() 分配了 8 个字节的内存来存储字符串 &ldquo;stringC&rdquo;。
但是，这里用 malloc_usable_size() 可以知道，malloc() 分配的内存块的实际大小是 24 字节。</p><p>这是因为，大多数内存分配函数是以内存块或内存页为单位进行分配的，通常比请求的大小大。
编译器也有可能会做一些优化，申请内存的时候多给的部分，在需要扩容的时候就可以直接用了。
不需要再通过系统调用去申请，可以减少系统调用的次数。</p><p>此外，一些内存分配函数可能会给内存块添加额外的元数据，以跟踪内存块的信息。
比如，调用 free() 函数的时候，只传了一个内存地址过去，它是怎么知道应该释放多大的内存的。</p><h3 id=数组>数组</h3><p>代码：array.c</p><p>一维数组或者多维数组的变量都指向数组所占内存单元的起始地址。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>555555559000-55555557a000 rw-p 00000000 00:00 0                          [heap]
</span></span><span style=display:flex><span>7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]
</span></span></code></pre></div><p>栈和堆就没啥好说的，直接声明的数组在栈里面，动态申请内存的数组是指针，指向堆。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(gdb) p &amp;a5I
</span></span><span style=display:flex><span>$2 = (int (*)[4]) 0x7fffffffde90
</span></span><span style=display:flex><span>(gdb) x/16xb 0x7fffffffde90
</span></span><span style=display:flex><span>0x7fffffffde90:	0x02	0x00	0x00	0x00	0x04	0x00	0x00	0x00
</span></span><span style=display:flex><span>0x7fffffffde98:	0x08	0x00	0x00	0x00	0x10	0x00	0x00	0x00
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(gdb) p &amp;a5J
</span></span><span style=display:flex><span>$3 = (int (*)[2][2]) 0x7fffffffdea0
</span></span><span style=display:flex><span>(gdb) x/16xb 0x7fffffffdea0
</span></span><span style=display:flex><span>0x7fffffffdea0:	0x20	0x00	0x00	0x00	0x40	0x00	0x00	0x00
</span></span><span style=display:flex><span>0x7fffffffdea8:	0x80	0x00	0x00	0x00	0x00	0x01	0x00	0x00
</span></span></code></pre></div><p>通过观察内存可以发现，不管是 <code>int[4]</code> 还是 <code>int[2][2]</code>，在内存里都是连续的 16 个字节。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(gdb) p p7a5K
</span></span><span style=display:flex><span>$4 = (int (*)[4]) 0x5555555596b0
</span></span><span style=display:flex><span>(gdb) x/16xb 0x5555555596b0
</span></span><span style=display:flex><span>0x5555555596b0:	0x02	0x00	0x00	0x00	0x04	0x00	0x00	0x00
</span></span><span style=display:flex><span>0x5555555596b8:	0x08	0x00	0x00	0x00	0x10	0x00	0x00	0x00
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(gdb) p p7a5L
</span></span><span style=display:flex><span>$5 = (int (*)[2][2]) 0x5555555596d0
</span></span><span style=display:flex><span>(gdb) x/16xb 0x5555555596d0
</span></span><span style=display:flex><span>0x5555555596d0:	0x20	0x00	0x00	0x00	0x40	0x00	0x00	0x00
</span></span><span style=display:flex><span>0x5555555596d8:	0x80	0x00	0x00	0x00	0x00	0x01	0x00	0x00
</span></span></code></pre></div><p>运行的时候动态分配的内存也是一样的，都是连续的 16 个字节。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(*p7a5L)[0]=0x56247f1946d0,p7l=0x56247f1946d0
</span></span><span style=display:flex><span>(*p7a5L)[0][0]=32,&amp;(*p7a5L)[0][0]=0x56247f1946d0,p7ll+0=32,p7ll+0=0x56247f1946d0
</span></span><span style=display:flex><span>(*p7a5L)[0][0]=64,&amp;(*p7a5L)[0][0]=0x56247f1946d4,p7ll+0=33,p7ll+0=0x56247f1946d4
</span></span><span style=display:flex><span>(*p7a5L)[1]=0x56247f1946d8,p7l+1=0x56247f1946d8
</span></span><span style=display:flex><span>(*p7a5L)[0][0]=128,&amp;(*p7a5L)[0][0]=0x56247f1946d8,p7ll+0=128,p7ll+0=0x56247f1946d8
</span></span><span style=display:flex><span>(*p7a5L)[0][0]=128,&amp;(*p7a5L)[0][0]=0x56247f1946dc,p7ll+0=256,p7ll+0=0x56247f1946dc
</span></span></code></pre></div><p>指向数组的指针这里，需要关注的就不是内存了，而是指针移动的距离。
当指针声明为 <code>(int(*)[2])</code> 的时候，指针 +1，移动的是 8 个字节，也就是一个 <code>int[2]</code> 的长度。
当指针声明为 <code>(int *)</code> 的时候，指针 +1，移动的是 4 个字节，也就是一个 int 的长度。</p><h3 id=结构体>结构体</h3><p>代码：struct.c</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>555555559000-55555557a000 rw-p 00000000 00:00 0                          [heap]
</span></span><span style=display:flex><span>7ffffffde000-7ffffffff000 rw-p 00000000 00:00 0                          [stack]
</span></span></code></pre></div><p>栈和堆就没啥好说的，直接声明的结构体在栈里面，动态申请内存的结构体是指针，指向堆。
两个结构体里的 name 都是动态申请的内存，都指向堆。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>sizeof(s6a)=16
</span></span><span style=display:flex><span>&amp;s6a=0x7fffffffdeb0
</span></span><span style=display:flex><span>&amp;s6a.name=0x7fffffffdeb0
</span></span><span style=display:flex><span>s6a.name=0x5555555596b0
</span></span><span style=display:flex><span>&amp;s6a.age=0x7fffffffdeb8
</span></span><span style=display:flex><span>&amp;s6a.sex=0x7fffffffdebc
</span></span></code></pre></div><p>这里用 sizeof() 得出的结构体的大小是 16 个字节。但是，实际上加起来应该是 13 个字节。
声明的时候，结构体里面有三个字段，一个 &ldquo;char *&rdquo; 8 个字节，一个 int 4 个字节，一个 char 1 个字节。</p><p>这是因为编译器会使用填充和对齐来优化内存的使用和访问。
这会导致同一个 struct 在不同系统上的大小可能不同，这取决于不同系统上的数据类型的大小和对齐的规则。</p><p>在这里的情况是，struct 的大小是其最大字段的大小的倍数。
最大的字段是 &ldquo;char *&rdquo; 8 个字节，结构体一共需要 13 个字节。所以，分配给结构体的内存就是 16 个字节。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(gdb) x/16xb 0x7fffffffdeb0
</span></span><span style=display:flex><span>0x7fffffffdeb0:	0xb0	0x96	0x55	0x55	0x55	0x55	0x00	0x00
</span></span><span style=display:flex><span>0x7fffffffdeb8:	0x12	0x00	0x00	0x00	0x66	0x00	0x00	0x00
</span></span><span style=display:flex><span>(gdb) x/16xb 0x5555555596b0
</span></span><span style=display:flex><span>0x5555555596b0:	0x61	0x61	0x61	0x00	0x00	0x00	0x00	0x00
</span></span><span style=display:flex><span>0x5555555596b8:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
</span></span></code></pre></div><p>直接观察内存里从结构体首地址开始的 16 个字节。</p><p>最前面的 8 个字节，是小端字节序的，正过来就是 00 00 55 55 55 55 96 b0。
这就是 name 字段的地址 0x5555555596b0，前面的 0 被省略了。</p><p>然后是 4 个字节的 int。然后是 1 个字节的 char。最后 3 个字节填充的 0 用于对齐。</p><p>0x5555555596b0 上的 0x61 就是 a 的 ascii 码（10 进制是 97）。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>sizeof(p7b)=8
</span></span><span style=display:flex><span>p7b=0x5555555596d0
</span></span><span style=display:flex><span>&amp;p7b-&gt;name=0x5555555596d0
</span></span><span style=display:flex><span>p7b-&gt;name=0x5555555596f0
</span></span><span style=display:flex><span>&amp;p7b-&gt;age=0x5555555596d8
</span></span><span style=display:flex><span>&amp;p7b-&gt;sex=0x5555555596dc
</span></span></code></pre></div><p>这里因为是指针，所以 sizeof() 得出的大小是 8 个字节。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>(gdb) x/16xb 0x5555555596d0
</span></span><span style=display:flex><span>0x5555555596d0:	0xf0	0x96	0x55	0x55	0x55	0x55	0x00	0x00
</span></span><span style=display:flex><span>0x5555555596d8:	0x12	0x00	0x00	0x00	0x66	0x00	0x00	0x00
</span></span><span style=display:flex><span>(gdb) x/16xb 0x5555555596f0
</span></span><span style=display:flex><span>0x5555555596f0:	0x62	0x62	0x62	0x00	0x00	0x00	0x00	0x00
</span></span><span style=display:flex><span>0x5555555596f8:	0x00	0x00	0x00	0x00	0x00	0x00	0x00	0x00
</span></span></code></pre></div><p>和上面一样，直接观察内存里结构体指针指向的内存地址开始的 16 个字节。</p><p>最前面的 8 个字节，是小端字节序的，正过来就是 00 00 55 55 55 55 96 f0。
这就是 name 字段的地址 0x5555555596f0，前面的 0 被省略了。</p><p>然后是 4 个字节的 int。然后是 1 个字节的 char。最后 3 个字节填充的 0 用于对齐。</p><p>0x5555555596f0 上的 0x62 就是 b 的 ascii 码（10 进制是 98）。</p></div><footer class=post-footer><div class=post-tags><a href=/tags/computer-science%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6>computer-science(计算机科学)</a>
<a href=/tags/operating-system%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f>operating-system(操作系统)</a>
<a href=/tags/memory%e5%86%85%e5%ad%98>memory(内存)</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
内存中的指令和数据</li><li class=post-copyright-author><strong>本文作者：</strong>
西柊慧音</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/computer-science/operating-system/memory/instruction_and_data/ title=内存中的指令和数据>/post/computer-science/operating-system/memory/instruction_and_data/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/computer-science/application/gdb_%E8%B0%83%E8%AF%95%E5%B7%A5%E5%85%B7/ rel=next title="GDB 调试工具"><i class="fa fa-chevron-left"></i> GDB 调试工具</a></div><div class="post-nav-prev post-nav-item"><a href=/post/computer-science/operating-system/linux/elf/ rel=prev title=ELF>ELF
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>西柊慧音</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.103.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.1 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":false,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.1","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.c997eeae723f2fcee19ae5066fcc64a49cefb92ddb75904efdb69a223e5a6740.js defer></script></body></html>