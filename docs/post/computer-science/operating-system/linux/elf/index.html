<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.103.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="ELF"><meta itemprop=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=keywords content="computer-science(计算机科学),operating-system(操作系统),elf"><meta property="og:type" content="article"><meta property="og:title" content="ELF"><meta property="og:description" content><meta property="og:image" content="/image/pid49256268.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/computer-science/operating-system/linux/elf/"><meta property="og:site_name" content="帕里特档案馆"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="西柊慧音"><meta property="article:published_time" content="2023-06-10 08:00:00 +0800 CST"><meta property="article:modified_time" content="2023-06-10 08:00:00 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.4da9279b6033ade10d67092d7bfb660265f9fa46c40974f17b13bfe235396546.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"elf","permalink":"/post/computer-science/operating-system/linux/elf/","title":"ELF","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>ELF - 帕里特档案馆</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>帕里特档案馆</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>重建中</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>96</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#资料>资料</a></li><li><a href=#正文>正文</a><ul><li><a href=#elf-文件是什么文件>elf 文件是什么文件</a></li><li><a href=#elf-文件的内容>elf 文件的内容</a></li><li><a href=#数据存储方式>数据存储方式</a></li><li><a href=#程序的入口地址>程序的入口地址</a></li><li><a href=#符号表>符号表</a></li><li><a href=#使用符号表的地址直接访问数据>使用符号表的地址直接访问数据</a></li><li><a href=#进程虚拟地址空间映射>进程虚拟地址空间映射</a></li><li><a href=#文件的权限>文件的权限</a><ul><li><a href=#读写执行权限>读写执行权限</a></li><li><a href=#特权权限>特权权限</a></li></ul></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=西柊慧音 src=/imgs/img-lazy-loading.gif data-src=/image/pid49256268.jpg><p class=site-author-name itemprop=name>西柊慧音</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>96</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>17</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>64</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/KelipuTe title="Github → https://github.com/KelipuTe" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=xhy_1365@sina.com title="E-Mail → xhy_1365@sina.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>E-Mail</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/computer-science/operating-system/linux/elf/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=name content="西柊慧音"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="西柊慧音"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="ELF"><meta itemprop=description content="elf 文件是什么文件；elf 文件的内容；数据存储方式；程序的入口地址；符号表；文件的权限；"></span><header class=post-header><h1 class=post-title itemprop="name headline">ELF</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2023-06-10 08:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-06-10 08:00:00 +0800 CST">2023-06-10</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/operating-system%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F itemprop=url rel=index><span itemprop=name>operating-system(操作系统)</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>4531</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>10分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/post/computer-science/operating-system/linux/elf/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h2 id=前言>前言</h2><p>前置笔记：
<a href=/post/computer-science/operating-system/program title=程序>程序</a></p><p>实践的环境：同
<a href title=程序>程序</a></p><h2 id=资料>资料</h2><ul><li><a href=https://github.com/KelipuTe/demo-c title={demo-c} rel="noopener external nofollow noreferrer" target=_blank class=exturl>{demo-c}
<i class="fa fa-external-link-alt"></i>
</a>/demo-in-linux/elf/</li></ul><h2 id=正文>正文</h2><h3 id=elf-文件是什么文件>elf 文件是什么文件</h3><p>在
<a href title=程序>程序</a> 中提到过，c 源码文件通过 gcc 编译器编译可以得到可执行文件，这里的可执行文件就是 elf 文件的一种。
关于 elf 具体的细节可以看 &ldquo;elf(5) - format of Executable and Linking Format (ELF) files&rdquo;</p><blockquote><p>elf(5)<br>Amongst these files are normal executable files, relocatable object files, core files, and shared objects.</p></blockquote><p>elf 文件格式有四种：
普通可执行文件（normal executable files）；
可重定位文件（relocatable object files）；
核心文件（core files）；
共享目标文件、共享库、动态库（shared objects）。</p><p>我在 {demo-c}/demo-in-linux/elf/ 目录下，准备了三个程序：
symbol.c、0b_0_10_0x.c、address.c。分别用于讨论不同的问题。</p><h3 id=elf-文件的内容>elf 文件的内容</h3><p>这里主要围绕 symbol.c 编译得到的 symbol.elf 文件。</p><p>先用 objdump 命令观察一下。
命令具体的输出放在 {demo-c}/demo-in-linux/elf/symbol_elf_objdump.md 里面。</p><p>然后，用 readelf 命令观察一下 symbol.elf。
关于 readelf 命令具体怎么用可以看 &ldquo;readelf(1) - display information about ELF files&rdquo;。</p><p>这里会用到 &ldquo;-h&rdquo;、"-l"、"-S"、"-s" 几个参数。
&ldquo;-h&rdquo; 表示输出 elf 文件头（elf header）；"-l" 表示输出 program headers；
&ldquo;-S&rdquo; 表示输出段表（section headers）；"-s" 表示输出符号表。
命令具体的输出放在 {demo-c}/demo-in-linux/elf/symbol_elf_readelf.md 里面。</p><blockquote><p>elf(5)<br>The ELF header is always at offset zero of the file.</p></blockquote><p>elf 文件头总是在文件的最前面，其他的数据都在后面。这很好理解，如果一个文件最前面不告我它是什么，我怎么知道它是什么。</p><p>分别解释一下。</p><p>&ldquo;-h&rdquo; 输出的 elf 文件头，这里截取了一些。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>  Data:                              2&#39;s complement, little endian
</span></span><span style=display:flex><span>  Type:                              DYN (Position-Independent Executable file)
</span></span><span style=display:flex><span>  Machine:                           Advanced Micro Devices X86-64
</span></span><span style=display:flex><span>  Entry point address:               0x1060
</span></span><span style=display:flex><span>  Number of section headers:         31
</span></span></code></pre></div><ul><li>Data：数据存储方式，这里是小端字节序（little endian）。</li><li>Type：elf 文件的类型，这里是可执行文件（Executable）。</li><li>Machine：机器架构，这里是 X86-64。</li><li>Entry point address：程序的入口地址。
操作系统在加载完可执行文件后，会把控制权转移给该程序，然后找到入口地址（这里就是 &ldquo;0x1060&rdquo;）开始运行程序。</li><li>Number of section headers：elf 段表的大小。</li></ul><p>&ldquo;-S&rdquo; 输出 section headers（段表），这里截取了一些。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>  [Nr] Name              Type             Address           Offset
</span></span><span style=display:flex><span>       Size              EntSize          Flags  Link  Info  Align
</span></span><span style=display:flex><span>  [ 1] .interp           PROGBITS         0000000000000318  00000318
</span></span><span style=display:flex><span>       000000000000001c  0000000000000000   A       0     0     1
</span></span><span style=display:flex><span>  [12] .init             PROGBITS         0000000000001000  00001000
</span></span><span style=display:flex><span>       000000000000001b  0000000000000000  AX       0     0     4
</span></span><span style=display:flex><span>  [16] .text             PROGBITS         0000000000001060  00001060
</span></span><span style=display:flex><span>       00000000000001d6  0000000000000000  AX       0     0     16
</span></span><span style=display:flex><span>  [18] .rodata           PROGBITS         0000000000002000  00002000
</span></span><span style=display:flex><span>       0000000000000063  0000000000000000   A       0     0     8
</span></span><span style=display:flex><span>  [25] .data             PROGBITS         0000000000004000  00003000
</span></span><span style=display:flex><span>       0000000000000018  0000000000000000  WA       0     0     8
</span></span><span style=display:flex><span>  [26] .bss              NOBITS           0000000000004018  00003018
</span></span><span style=display:flex><span>       0000000000000010  0000000000000000  WA       0     0     4
</span></span><span style=display:flex><span>  [28] .symtab           SYMTAB           0000000000000000  00003048
</span></span><span style=display:flex><span>       0000000000000408  0000000000000018          29    20     8
</span></span><span style=display:flex><span>  [29] .strtab           STRTAB           0000000000000000  00003450
</span></span><span style=display:flex><span>       000000000000022c  0000000000000000           0     0     1
</span></span></code></pre></div><ul><li>&ldquo;.interp&rdquo;：程序解释器（elf 解释器）的路径。</li><li>&ldquo;.init&rdquo;：进程初始化的代码。</li><li>&ldquo;.text&rdquo;：程序指令&ndash;>指令码&ndash;>机器码&ndash;>二进制指令&ndash;>cpu 指令（芯片层级的指令）。</li><li>&ldquo;.rodata&rdquo;：只读数据（如：数字常量，字符串常量）。</li><li>&ldquo;.data&rdquo;：已经给值的全局变量、静态变量、局部变量。</li><li>&ldquo;.bss&rdquo;：未初始化的全局变量、静态变量、局部变量。</li><li>&ldquo;.symtab&rdquo;：符号表。和 &ldquo;.strtab&rdquo; 段一起用。</li><li>&ldquo;.strtab&rdquo;：字符串符号表（变量名、函数名）。</li><li>&ldquo;.debug&rdquo;：调试信息，编译的时候带 &ldquo;-g&rdquo; 参数的时候就会有这一段。</li><li>其他的段的解释详见 linux 文档 elf(5)。</li></ul><p>&ldquo;-s&rdquo; 输出的符号表，这里截取了 symbol.c 代码里直接出现的几个。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>   Num:    Value          Size Type    Bind   Vis      Ndx Name
</span></span><span style=display:flex><span>    12: 0000000000004014     4 OBJECT  LOCAL  DEFAULT   25 staticIntB.1
</span></span><span style=display:flex><span>    13: 0000000000004020     4 OBJECT  LOCAL  DEFAULT   26 staticIntA.0
</span></span><span style=display:flex><span>    26: 000000000000401c     4 OBJECT  GLOBAL DEFAULT   26 globalIntA
</span></span><span style=display:flex><span>    27: 0000000000001149    54 FUNC    GLOBAL DEFAULT   16 functionA
</span></span><span style=display:flex><span>    28: 00000000000011b5    54 FUNC    GLOBAL DEFAULT   16 functionC
</span></span><span style=display:flex><span>    36: 00000000000011eb    75 FUNC    GLOBAL DEFAULT   16 main
</span></span><span style=display:flex><span>    38: 0000000000004010     4 OBJECT  GLOBAL DEFAULT   25 globalIntB
</span></span><span style=display:flex><span>    40: 000000000000117f    54 FUNC    GLOBAL DEFAULT   16 functionB
</span></span></code></pre></div><h3 id=数据存储方式>数据存储方式</h3><p>数据存储方式有两种：小端字节序（little endian）和大端字节序（big endian）。
小端字节序又叫主机字节序，大端字节序又叫网络字节序。</p><p>上面 <code>readelf -h</code> 命令的结果里面，在 Data 字段里可以看见 &ldquo;little endian&rdquo;。
意思就是在 symbol.elf 里面，数据的存储格式是小端字节序。下面来验证一下这个结论。</p><p>在 symbol.c 的源码里面，全局变量 globalIntB 是一开始就明确的给了值的。
在 <code>readelf -s</code> 命令输出的符号表里，找到 globalIntB 在的那一行。
然后，就可以知道到 globalIntB 对应的内存地址是 0x4010。</p><p>在 <code>objdump -s</code> 命令输出的结果里面，找到内存地址 0x4010，地址上存储的就是全局变量 globalIntB 的数据。
内存地址 0x4010 在 &ldquo;.data&rdquo; 段里面，这里截取一下 &ldquo;.data&rdquo; 段的内容。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>Contents of section .data:
</span></span><span style=display:flex><span> 4000 00000000 00000000 08400000 00000000  .........@......
</span></span><span style=display:flex><span> 4010 2c010000 0a000000                    ,.......        
</span></span></code></pre></div><p>因为源码里面 globalIntB 是 int 类型的，int 类型的长度是 4 个字节。
所以，globalIntB 的数据就对应从 0x4010 地址开始的 4 个字节的数据。也就是 &ldquo;2c010000&rdquo; 这一段。</p><p>源码里面 globalIntB 初始化的时候是 300。
10 进制的 300 用 16 进制表示就是 0x12c，补全 4 个字节就是 &ldquo;00 00 01 2c&rdquo;。
但是，这里可以看到内存上的数据是 &ldquo;2c 01 00 00&rdquo;，是反的。这就是因为这里用的是小端字节序。</p><p>c 语言的 int 变量由 4 个字节组成，每个字节由 8 个 bit 位组成。
把 10 进制的 300 转换成 2 进制就是 &ldquo;00000000 00000000 00000001 00101100&rdquo;，左边定义为高位，右边定义为低位。
小端字节序的存储格式是把数据的低位放在内存低位上，而内存的排布是从低位到高位的。
所以，就变成了 &ldquo;00101100 00000001 00000000 00000000&rdquo;，转换成 16 进制就是 &ldquo;2c 01 00 00&rdquo;。</p><p>关于进制的问题，我放了一个示例代码，0b_0_10_0x.c。</p><p>通过 size 命令可以查看文件中各段及其总和的大小，单位是字节。
关于 size 命令具体怎么用可以看 &ldquo;size(1) - list section sizes and total size of binary files&rdquo;。</p><p>这里观察一下 symbol.elf 文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>&gt; size demo02
</span></span><span style=display:flex><span>   text	   data	    bss	    dec	    hex	filename
</span></span><span style=display:flex><span>   1786	    608	     16	   2410	    96a	symbol.elf
</span></span></code></pre></div><ul><li>text，代码段，通常是指用来存放程序执行代码的一块内存区域。</li><li>data，数据段，通常是指用来存放程序中已初始化的全局变量的一块内存区域。数据段属于静态内存分配。</li><li>bss，通常是指用来存放程序中未初始化的全局变量的一块内存区域。bss 段属于静态内存分配。</li><li>默认情况下，段的大小是以十进制的方式来展示。</li></ul><h3 id=程序的入口地址>程序的入口地址</h3><p>从 <code>objdump -s</code> 命令输出的结果里可以知道 symbol.elf 程序的入口地址是 0x1060。
然后在 <code>objdump -s</code> 命令输出的结果里面。找到 &ldquo;.text&rdquo; 段，然后找到地址 0x1060 对应的数据。
这里截取了 &ldquo;.text&rdquo; 段前三行的内容。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>Contents of section .text:
</span></span><span style=display:flex><span> 1060 f30f1efa 31ed4989 d15e4889 e24883e4  ....1.I..^H..H..
</span></span><span style=display:flex><span> 1070 f0505445 31c031c9 488d3d6c 010000ff  .PTE1.1.H.=l....
</span></span><span style=display:flex><span> 1080 15532f00 00f4662e 0f1f8400 00000000  .S/...f.........
</span></span></code></pre></div><ul><li>左边第 1 列是虚拟地址；中间的 4 列是指令码；最右边 1 列是 ASCII 码。</li><li>&ldquo;0x1060&rdquo; 是起始地址；&ldquo;f30f1efa&rdquo; 是起始指令；指令是 16 进制的：&ldquo;0xf3 0x0f 0x1e 0xfa&rdquo;；大小为 4 个字节。</li></ul><p>在 <code>objdump -d</code> 命令输出的结果中，可以找到对应的汇编代码。
这里截取了程序的入口地址对应的部分。通过虚拟地址的值和指令的值可以对应起来。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>0000000000001060 &lt;_start&gt;:
</span></span><span style=display:flex><span>    1060:	f3 0f 1e fa          	endbr64 
</span></span><span style=display:flex><span>    1064:	31 ed                	xor    %ebp,%ebp
</span></span><span style=display:flex><span>    1066:	49 89 d1             	mov    %rdx,%r9
</span></span><span style=display:flex><span>    1069:	5e                   	pop    %rsi
</span></span><span style=display:flex><span>    106a:	48 89 e2             	mov    %rsp,%rdx
</span></span><span style=display:flex><span>    106d:	48 83 e4 f0          	and    $0xfffffffffffffff0,%rsp
</span></span><span style=display:flex><span>    1071:	50                   	push   %rax
</span></span><span style=display:flex><span>    1072:	54                   	push   %rsp
</span></span><span style=display:flex><span>    1073:	45 31 c0             	xor    %r8d,%r8d
</span></span><span style=display:flex><span>    1076:	31 c9                	xor    %ecx,%ecx
</span></span><span style=display:flex><span>    1078:	48 8d 3d 33 01 00 00 	lea    0x133(%rip),%rdi        # 11b2 &lt;main&gt;
</span></span><span style=display:flex><span>    107f:	ff 15 53 2f 00 00    	call   *0x2f53(%rip)        # 3fd8 &lt;__libc_start_main@GLIBC_2.34&gt;
</span></span><span style=display:flex><span>    1085:	f4                   	hlt    
</span></span><span style=display:flex><span>    1086:	66 2e 0f 1f 84 00 00 	cs nopw 0x0(%rax,%rax,1)
</span></span><span style=display:flex><span>    108d:	00 00 00 
</span></span></code></pre></div><p>&ldquo;_start&rdquo; 是函数名。因为 &ldquo;0x1060&rdquo; 是起始地址，所以 &ldquo;_start&rdquo; 函数，就是这个程序的入口函数。
它在调用 main 函数之前，会做一些前期的准备工作。编程语言的 main 函数一般不是程序的入口函数。
大部分入口函数都是类似 &ldquo;_start&rdquo; 函数这样的，而且不同的语言在初始化阶段会有各自的处理逻辑。</p><p>这里最右边的汇编代码是 ATT 格式的汇编语法，汇编语法有 intel 格式和 ATT 格式，ATT 格式主要用于 unix/linux 系统。
使用命令 <code>objdump -d -M intel symbol.elf</code> 就可以输出 intel 格式的汇编代码。</p><h3 id=符号表>符号表</h3><p>通过命令 <code>readelf -s</code> 可以输出符号表。
这里截取了 &ldquo;_start&rdquo; 对应的数据和 symbol.elf 代码里直接出现的几个。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>   Num:    Value          Size Type    Bind   Vis      Ndx Name
</span></span><span style=display:flex><span>    12: 0000000000004014     4 OBJECT  LOCAL  DEFAULT   25 staticIntB.1
</span></span><span style=display:flex><span>    13: 0000000000004020     4 OBJECT  LOCAL  DEFAULT   26 staticIntA.0
</span></span><span style=display:flex><span>    26: 000000000000401c     4 OBJECT  GLOBAL DEFAULT   26 globalIntA
</span></span><span style=display:flex><span>    27: 0000000000001149    54 FUNC    GLOBAL DEFAULT   16 functionA
</span></span><span style=display:flex><span>    28: 00000000000011b5    54 FUNC    GLOBAL DEFAULT   16 functionC
</span></span><span style=display:flex><span>    34: 0000000000001060    38 FUNC    GLOBAL DEFAULT   16 _start
</span></span><span style=display:flex><span>    36: 00000000000011eb    75 FUNC    GLOBAL DEFAULT   16 main
</span></span><span style=display:flex><span>    38: 0000000000004010     4 OBJECT  GLOBAL DEFAULT   25 globalIntB
</span></span><span style=display:flex><span>    40: 000000000000117f    54 FUNC    GLOBAL DEFAULT   16 functionB
</span></span></code></pre></div><p>这里用 globalIntB 举例，globalIntB 在源码中是个全局 int 变量，初始化为 300。</p><ul><li>Name（符号名）：globalIntB</li><li>Ndx（段 id）：25，表示符号属于第 25 段。结合段表，第 25 段是 &ldquo;.data&rdquo; 段。第 26 段是 &ldquo;.bss&rdquo; 段。</li><li>Type（类型）：OBJECT，表示是个对象。如果是 FUNC，就表示是个函数</li><li>Bind（绑定范围）：GLOBAL，表示全局。</li><li>Value（地址）：0x0000000000004010。</li></ul><p>这里结合 &ldquo;.data&rdquo; 段的数据。
globalIntB 的数据保存在地址从 0x4010 开始往后的 4 个字节上，也就是上面的 &ldquo;2c010000&rdquo;，值就是 300。</p><p>命令 nm 也可以输出符号表。关于 gcc 命令具体怎么用可以看 &ldquo;nm(1) - list symbols from object files&rdquo;。
nm 命令输出的内容在文件 {demo-c}/demo-in-linux/elf/symbol_elf_nm.md 中。</p><h3 id=使用符号表的地址直接访问数据>使用符号表的地址直接访问数据</h3><p>在程序中可以直接使用符号表中的 Value 值去访问对应的内存数据。
同样的源文件，每次编译得到的符号表的地址是一样的。
如果只是修改了某个变量的值，没有大规模的修改代码的话，重新编译的时候，变量的地址一般也是不会变得。
可以通过这种方式验证这个结论。</p><p>示例代码：address.c。不过，在 ubuntu 22.04 中，这种方式无效。</p><h3 id=进程虚拟地址空间映射>进程虚拟地址空间映射</h3><p>需要注意的是，在上面的输出中，与地址有关的数据，都不是程序跑起来的时候，在内存中真正的地址。
程序在进程里跑起来的时候，操作系统会把真正的内存地址和 elf 文件中的虚拟地址做映射。</p><h3 id=文件的权限>文件的权限</h3><h4 id=读写执行权限>读写执行权限</h4><p>在命令行中，使用 <code>ls -l</code> 命令，就可以看到文件的权限。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>&gt; ls -l
</span></span><span style=display:flex><span>-rwxrwxrwx 1 root root   607  6月 10 19:16 symbol.c
</span></span><span style=display:flex><span>-rwxrwxrwx 1 root root 16216  6月 10 19:24 symbol.elf
</span></span></code></pre></div><p>第一列是文件的权限，第三列是文件的所有者，第四列是文件的所有群组。
这里以 &ldquo;-rwxrwxrwx&rdquo; 为例：第一位表示文件的类型；第 2~4 位分别表示 user 的读、写、执行权限；
第 5~7 位分别表示 group 的读、写、执行权限；第 8~10 位分别表示 other 的读、写、执行权限。</p><p>&ldquo;-rwxrwxrwx&rdquo; 表示：所有的用户都拥有这个文件的读、写、执行权限。
如果是 &ldquo;-rwxr-xr-x&rdquo;，则表示：user 有读、写、执行权限，而 group 和 other 只有读、执行权限，没有写权限。</p><h4 id=特权权限>特权权限</h4><p>&ldquo;/etc/shadow&rdquo; 文件用于记录 linux 上所有用户的账号和密码。
只有超级管理员有读写权限，普通用户是没有读写权限的。</p><p>但是，没有写权限的普通用户却可以通过 passwd 命令修改自己的密码。
这是因为 passwd 命令对应的 &ldquo;/bin/passwd&rdquo; 文件的权限是 &ldquo;-rwsr-xr-x&rdquo;。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span># /etc/shadow
</span></span><span style=display:flex><span>-rw-r-----   1 root shadow  1462  2月  6 12:38 shadow
</span></span><span style=display:flex><span># /bin/passwd
</span></span><span style=display:flex><span>-rwsr-xr-x  1 root root       59976 11月 24 20:05 passwd
</span></span></code></pre></div><p>可以注意到 user 的执行权限位上是 s，这称为特权权限（Set User ID，SUID）。
如果 group 的执行权限位上是 s，就是（Set Group ID，SGID）。
文件所有者可以通过 <code>chmod u+s</code> 命令设置特权权限。有特权权限的文件通过 ls 命令看的时候是红色的。</p><p>在程序中，可以通过 getuid() 获取用户 id，通过 geteuid() 获取有效用户 id。
通过 setuid() 设置用户 id，通过 seteuid() 设置有效用户 id。</p><p>如果是文件的所有者，那么 getuid() 和 geteuid() 得到的结果是一样的。
如果不是文件的所有者，那么 geteuid() 就能拿到文件的所有者的 id。</p><p>如果文件所有者设置了特权权限，那么其他用户调用 seteuid() 并传入文件的所有者的 id 的时候，就可以拥有文件所有者的权限。
想要改回来，可以调用 seteuid() 并传入自己的有效用户 id，这样就没有文件所有者的权限了。</p><p>一般来说，程序主要是以普通用户运行的，以较低的权限执行程序，可以保证安全性。
但是，有时需要操作一些比较重要的数据，这个时候就需要提权。</p><p>提权后，可以短暂地拥有该可执行文件所有者的权限，然后就可以修改数据了。
特别需要注意的是，使用完之后一定要降权。</p><p>代码示例：{demo-c}/demo-in-linux/elf/setuid.c</p></div><footer class=post-footer><div class=post-tags><a href=/tags/computer-science%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6>computer-science(计算机科学)</a>
<a href=/tags/operating-system%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f>operating-system(操作系统)</a>
<a href=/tags/elf>elf</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
ELF</li><li class=post-copyright-author><strong>本文作者：</strong>
西柊慧音</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/computer-science/operating-system/linux/elf/ title=ELF>/post/computer-science/operating-system/linux/elf/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/computer-science/operating-system/memory/instruction_and_data/ rel=next title=内存中的指令和数据><i class="fa fa-chevron-left"></i> 内存中的指令和数据</a></div><div class="post-nav-prev post-nav-item"><a href=/post/computer-science/operating-system/program/ rel=prev title=程序>程序
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>西柊慧音</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.103.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.1 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":false,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.1","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.c997eeae723f2fcee19ae5066fcc64a49cefb92ddb75904efdb69a223e5a6740.js defer></script></body></html>