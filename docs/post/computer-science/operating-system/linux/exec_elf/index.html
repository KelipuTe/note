<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.103.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="运行 ELF 文件"><meta itemprop=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=keywords content="computer-science(计算机科学),operating-system(操作系统),elf"><meta property="og:type" content="article"><meta property="og:title" content="运行 ELF 文件"><meta property="og:description" content><meta property="og:image" content="/image/pid49256268.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/computer-science/operating-system/linux/exec_elf/"><meta property="og:site_name" content="帕里特档案馆"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="西柊慧音"><meta property="article:published_time" content="2023-06-10 08:00:00 +0800 CST"><meta property="article:modified_time" content="2023-06-10 08:00:00 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.4da9279b6033ade10d67092d7bfb660265f9fa46c40974f17b13bfe235396546.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"exec_elf","permalink":"/post/computer-science/operating-system/linux/exec_elf/","title":"运行 ELF 文件","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>运行 ELF 文件 - 帕里特档案馆</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>帕里特档案馆</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>重建中</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>87</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#资料>资料</a></li><li><a href=#正文>正文</a><ul><li><a href=#进程是什么>进程是什么</a></li><li><a href=#怎么观察进程>怎么观察进程</a><ul><li><a href=#在-centos-的-docker-容器中使用-strace-命令报错>在 centos 的 docker 容器中使用 strace 命令报错</a></li></ul></li><li><a href=#观察一下-hello-world-程序运行的过程>观察一下 hello world 程序运行的过程</a><ul><li><a href=#最前面的重复出现的-read-和-write>最前面的重复出现的 read 和 write</a></li><li><a href=#clone>clone</a></li><li><a href=#wait4>wait4</a></li><li><a href=#execve>execve</a></li><li><a href=#libcso6>libc.so.6</a></li><li><a href=#write>write</a></li><li><a href=#exit_group>exit_group</a></li><li><a href=#wait4-1>wait4</a></li><li><a href=#至此整个-hello-world-程序执行结束>至此整个 hello world 程序执行结束。</a></li></ul></li><li><a href=#进程>进程</a></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=西柊慧音 src=/imgs/img-lazy-loading.gif data-src=/image/pid49256268.jpg><p class=site-author-name itemprop=name>西柊慧音</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>87</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>16</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>62</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/KelipuTe title="Github → https://github.com/KelipuTe" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=xhy_1365@sina.com title="E-Mail → xhy_1365@sina.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>E-Mail</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/computer-science/operating-system/linux/exec_elf/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=name content="西柊慧音"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="西柊慧音"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="运行 ELF 文件"><meta itemprop=description content="进程是什么；怎么观察进程；hello world 程序运行的过程；"></span><header class=post-header><h1 class=post-title itemprop="name headline">运行 ELF 文件</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2023-06-10 08:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-06-10 08:00:00 +0800 CST">2023-06-10</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/operating-system%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F itemprop=url rel=index><span itemprop=name>operating-system(操作系统)</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>3428</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>7分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/post/computer-science/operating-system/linux/exec_elf/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h2 id=前言>前言</h2><p>前置笔记：
<a href=/post/computer-science/operating-system/linux/elf title="ELF 文件">ELF 文件</a></p><p>实践的环境：同
<a href title=程序>程序</a></p><h2 id=资料>资料</h2><ul><li><a href=https://github.com/KelipuTe/demo-c title={demo-c} rel="noopener external nofollow noreferrer" target=_blank class=exturl>{demo-c}
<i class="fa fa-external-link-alt"></i>
</a>/demo-in-linux/program/</li></ul><h2 id=正文>正文</h2><h3 id=进程是什么>进程是什么</h3><p>可执行文件只是程序而已，程序自己是跑不起来的，需要把程序交给操作系统去执行。</p><p>当一个程序被交给操作系统执行时，操作系统首先会创建一个进程。
与此同时，一个线程也会被立刻启动起来去执行程序中的 main 函数。
这个线程就叫主线程，后续创建的线程都是这个主线程的子线程。</p><p>线程被称作轻量级进程，它是操作系统调度的最小单元，通常一个进程可以拥有多个线程。</p><p>进程不仅局限于程序（那段可执行代码），还包含其他资源。例如，文件、内存、线程、信号等。
进程拥有独立的资源空间，进程中的线程共享进程的资源空间。</p><p>简单的理解，程序是静态的，进程是动态的，程序需要变成进程，才能够真正的运行起来，程序启动起来就变成进程，直到程序运行结束。</p><h3 id=怎么观察进程>怎么观察进程</h3><p>可以通过 strace 命令可以跟踪进程执行时的系统调用和进程接收的信号。
关于 strace 命令具体怎么用，可以看 &ldquo;strace(1) - trace system calls and signals&rdquo;。</p><p>这里会用到 &ldquo;-f&rdquo;、"-i"、"-t"、"-T"、"-p"、"-s"、"-o" 这几个参数。
&ldquo;-f&rdquo; 跟踪子进程；"-i" 打印系统调用的地址；"-t" 每一行打印时间；
&ldquo;-T&rdquo; 显示系统调用花费的时间；"-p {pid}&ldquo;指定跟踪的进程号；
&ldquo;-s {length}&rdquo; 每一行的长度，默认 32，一般设置 65535；"-o {file name}&rdquo; 输出到文件。</p><p>关于系统调用的详细的内容。我放到这篇里面去了。
<a href=/post/computer-science/operating-system/system_call title=系统调用>系统调用</a></p><p>这里观察一下 hello_world.elf 可执行文件运行的过程。
命令的输出我放在 {demo-c}/demo-in-linux/program/ 目录的 hello_world_objdump.md 文件内。</p><h4 id=在-centos-的-docker-容器中使用-strace-命令报错>在 centos 的 docker 容器中使用 strace 命令报错</h4><p>使用 <code>strace -p</code> 命令跟踪进程时报错：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-text data-lang=text><span style=display:flex><span>attach: ptrace(PTRACE_SEIZE): Operation not permitted
</span></span></code></pre></div><p>参考官方文档：
<a href=https://bitworks.software/en/2017-07-24-docker-ptrace-attach.html title="The solution for enabling of ptrace and PTRACE_ATTACH in Docker Containers" rel="noopener external nofollow noreferrer" target=_blank class=exturl>The solution for enabling of ptrace and PTRACE_ATTACH in Docker Containers
<i class="fa fa-external-link-alt"></i>
</a>。</p><p>启动容器的时候使用 &ldquo;–-privileged&rdquo; 参数，让容器内的 root 用户拥有真正的 root 权限。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-shell data-lang=shell><span style=display:flex><span>docker run -it -p 127.0.0.1:9501:9501 -v <span style=color:#f92672>{</span>local path<span style=color:#f92672>}</span>:<span style=color:#f92672>{</span>docker path<span style=color:#f92672>}</span> --name<span style=color:#f92672>={</span>container name<span style=color:#f92672>}</span> --privileged centos:centos7
</span></span></code></pre></div><p>进入容器，然后使用命令：<code>echo 0 > /proc/sys/kernel/yama/ptrace_scope</code>。
将 &ldquo;/proc/sys/kernel/yama/ptrace_scope&rdquo; 文件中的值修改成 0。然后就可以使用 <code>strace -p</code> 命令跟踪进程了。</p><h3 id=观察一下-hello-world-程序运行的过程>观察一下 hello world 程序运行的过程</h3><p>可以直接用 <code>strace -f -i -T -s 65535 ./hello_world.elf</code> 命令直接跟踪 <code>./hello_world.elf</code> 命令运行的过程。
但是，这样观察不到全部的细节。这里用另外一种观察方式，观察输入 <code>./hello_world.elf</code> 并运行程序的那个终端对应的进程。</p><p>其实用户的输入，也是有一个进程来处理的，这个进程会接收并分析用户输入的容，然后做出相应的动作。
这里这个进程，会先接收到用户输入的 <code>./hello_world.elf</code> 还有回车符。
通过分析，得到这条命令的意思是这是要执行 hello_world.elf 这个可执行文件。然后，就去执行相应的操作。</p><p>假设有两个终端黑窗口（进程），进程 a 负责进行上面的操作。进程 b 负责观察进程 a。
在进程 b 进行跟踪之前，需要现在进程 a 里面，使用 <code>echo $$</code> 命令获取当前进程的 pid。
然后进程 b 使用 <code>strace -f -i -T -s 65535 -p {pid} -o hello_world_elf_strace.log</code> 命令观察进程 a。</p><p>strace 命令输出的结果：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>strace: Process 5148 attached
</span></span><span style=display:flex><span>strace: Process 5333 attached
</span></span><span style=display:flex><span>^Cstrace: Process 5148 detached
</span></span></code></pre></div><p>终端 a 运行输入 <code>./hello_world.elf</code> 执行程序，终端 b 在输出前两行之后，按 ctrl+c 终止监视，会输出第三行。
追踪到的内容会输出到 hello_world_elf_strace.log 里面，下面看一下 log 里面的内容。</p><h4 id=最前面的重复出现的-read-和-write>最前面的重复出现的 read 和 write</h4><p>这里截取了 strace.log 里面，最前面的一段。<code>...</code> 表示这里省略了代码，全部贴过来太长了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>2222  [00007f060c91b8f4] pselect6(1, [0], NULL, NULL, NULL, {sigmask=[], sigsetsize=8}) = 1 (in [0]) &lt;4.219516&gt;
</span></span><span style=display:flex><span>2222  [00007f060c914992] read(0, &#34;.&#34;, 1) = 1 &lt;0.000107&gt;
</span></span><span style=display:flex><span>2222  [00007f060c91b74d] pselect6(1, [0], NULL, [0], {tv_sec=0, tv_nsec=0}, NULL) = 0 (Timeout) &lt;0.000100&gt;
</span></span><span style=display:flex><span>2222  [00007f060c914a37] write(2, &#34;.&#34;, 1) = 1 &lt;0.000098&gt;
</span></span><span style=display:flex><span>2222  [00007f060c91b8f4] pselect6(1, [0], NULL, NULL, NULL, {sigmask=[], sigsetsize=8}) = 1 (in [0]) &lt;0.269215&gt;
</span></span><span style=display:flex><span>2222  [00007f060c914992] read(0, &#34;/&#34;, 1) = 1 &lt;0.000736&gt;
</span></span><span style=display:flex><span>2222  [00007f060c91b74d] pselect6(1, [0], NULL, [0], {tv_sec=0, tv_nsec=0}, NULL) = 0 (Timeout) &lt;0.000152&gt;
</span></span><span style=display:flex><span>2222  [00007f060c914a37] write(2, &#34;/&#34;, 1) = 1 &lt;0.000115&gt;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>这里用上面的第二行 &ldquo;2222 [00007f060c914992] read(0, &ldquo;.&rdquo;, 1) = 1 &lt;0.000107>&rdquo; 做一个说明：
&ldquo;2222&rdquo; 是进程号；&rsquo;[00007f060c914992]&rsquo; 是地址；&lsquo;read(0, &ldquo;.&rdquo;, 1)&rsquo; 是系统调用和调用的时候传入的参数；
&ldquo;= 1&rdquo; 这里的 1 是前面那个系统调用的返回值；"&lt;0.000107>" 是系统调用消耗的时间。</p><p>终端 a（进程 2222），是由 &ldquo;/bin/bash&rdquo; 程序启动来的（"/bin/bash" 程序就是输入命令的那个终端黑窗口）。
这一大段 read 函数和 write 函数，跟踪到的就是用户在终端 a 里用键盘输入 <code>./helloworld</code> 的过程。
read 是读取用户的输入，write 是将用户的输入显示到屏幕上。</p><p>关于 read 函数和 write 函数具体怎么用可以看 &ldquo;read(2) - read from a file descriptor&rdquo;
和 &ldquo;write(2) - write to a file descriptor&rdquo;</p><h4 id=clone>clone</h4><p>下一个关键的步骤是，调用 clone()。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>...
</span></span><span style=display:flex><span>2222  [00007f060c8eabc7] clone(child_stack=NULL, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD &lt;unfinished ...&gt;
</span></span><span style=display:flex><span>3579  [00007f060c8eac02] set_robust_list(0x7f060cb82a20, 24 &lt;unfinished ...&gt;
</span></span><span style=display:flex><span>2222  [00007f060c8eabc7] &lt;... clone resumed&gt;, child_tidptr=0x7f060cb82a10) = 3579 &lt;0.000430&gt;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>clone() 的作用是创建子进程，这里父进程 2222 创建了子进程 3579。
关于 clone() 具体怎么用可以看 &ldquo;clone(2) - create a child process&rdquo;。
另外，fock() 也可以创建子进程，这个后面再说。</p><h4 id=wait4>wait4</h4><p>下一个关键的步骤是，是父进程调用 wait4()。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>...
</span></span><span style=display:flex><span>2222  [00007f060c8ea45a] wait4(-1,  &lt;unfinished ...&gt;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>父进程调用 wait4() 会进入阻塞状态，直到有子进程退出。
关于 wait4() 具体怎么用可以看 &ldquo;wait4(2) - wait for process to change state, BSD style&rdquo;。</p><p>在这里就是，父进程调用 wait4() 进入阻塞状态，然后操作系统切换到子进程继续运行。
出现 &ldquo;&lt;unfinished &mldr;>&rdquo; 这个就表示产生了进程切换。</p><h4 id=execve>execve</h4><p>下一个关键的步骤是，是子进程调用 execve()。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>...
</span></span><span style=display:flex><span>3579  [00007f060c8eb0fb] execve(&#34;./hello_world.elf&#34;, [&#34;./hello_world.elf&#34;], 0x5595c15c1ed0 /* 55 vars */) = 0 &lt;0.009663&gt;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>子进程调用 execve() 执行可执行文件 hello_world.elf。
关于 execve() 具体怎么用可以看 &ldquo;execve(2) - execute program&rdquo;。</p><p>execve() 会加载可执行文件的 &ldquo;.text&rdquo; （程序指令）和 &ldquo;.data&rdquo; （程序数据）到当前进程，并覆盖当前进程。
&lsquo;["./helloworld"]&rsquo; 是命令行参数。&ldquo;0x564eeda28ec0 /* 55 vars */&rdquo; 是环境参数。环境参数是供所有应用程序使用的公共数据。</p><p>关于命令行参数和环境参数的详细的内容。我放到这篇里面去了。
<a href=/post/computer-science/operating-system/cmd_env_param title=命令行参数和环境参数>命令行参数和环境参数</a></p><h4 id=libcso6>libc.so.6</h4><p>下一个关键的步骤是，加载 libc.so.6 文件。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>...
</span></span><span style=display:flex><span>3579  [00007f02afc17b38] openat(AT_FDCWD, &#34;/lib/x86_64-linux-gnu/libc.so.6&#34;, O_RDONLY|O_CLOEXEC) = 3 &lt;0.000014&gt;
</span></span><span style=display:flex><span>3579  [00007f02afc17b88] read(3, &#34;\177ELF\2\1\1\3\0\0\0\0\0\0\0\0\3\0&gt;\0\1\0\0\0P\237\2\0\0\0\0\0@\0\0\0\0\0\0\0\360\300!\0\0\0\0\0\0\0\0\0@\08\0\16\0@\0B\0A\0\6\0\0\0\4\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0@\0\0\0\0\0\0\0\20\3\0\0\0\0\0\0\20\3\0\0\0\0\0\0\10\0\0\0\0\0\0\0\3\0\0\0\4\0\0\0000&gt;\36\0\0\0\0\0000&gt;\36\0\0\0\0\0000&gt;\36\0\0\0\0\0\34\0\0\0\0\0\0\0\34\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0\1\0\0\0\4\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\340\177\2\0\0\0\0\0\340\177\2\0\0\0\0\0\0\20\0\0\0\0\0\0\1\0\0\0\5\0\0\0\0\200\2\0\0\0\0\0\0\200\2\0\0\0\0\0\0\200\2\0\0\0\0\0\301D\31\0\0\0\0\0\301D\31\0\0\0\0\0\0\20\0\0\0\0\0\0\1\0\0\0\4\0\0\0\0\320\33\0\0\0\0\0\0\320\33\0\0\0\0\0\0\320\33\0\0\0\0\0\314x\5\0\0\0\0\0\314x\5\0\0\0\0\0\0\20\0\0\0\0\0\0\1\0\0\0\6\0\0\0\360H!\0\0\0\0\0\360X!\0\0\0\0\0\360X!\0\0\0\0\0\230O\0\0\0\0\0\0`%\1\0\0\0\0\0\0\20\0\0\0\0\0\0\2\0\0\0\6\0\0\0\300{!\0\0\0\0\0\300\213!\0\0\0\0\0\300\213!\0\0\0\0\0\320\1\0\0\0\0\0\0\320\1\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0P\3\0\0\0\0\0\0P\3\0\0\0\0\0\0P\3\0\0\0\0\0\0000\0\0\0\0\0\0\0000\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0\4\0\0\0\4\0\0\0\200\3\0\0\0\0\0\0\200\3\0\0\0\0\0\0\200\3\0\0\0\0\0\0D\0\0\0\0\0\0\0D\0\0\0\0\0\0\0\4\0\0\0\0\0\0\0\7\0\0\0\4\0\0\0\360H!\0\0\0\0\0\360X!\0\0\0\0\0\360X!\0\0\0\0\0\20\0\0\0\0\0\0\0\220\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0S\345td\4\0\0\0P\3\0\0\0\0\0\0P\3\0\0\0\0\0\0P\3\0\0\0\0\0\0000\0\0\0\0\0\0\0000\0\0\0\0\0\0\0\10\0\0\0\0\0\0\0P\345td\4\0\0\0L&gt;\36\0\0\0\0\0L&gt;\36\0\0\0\0\0L&gt;\36\0\0\0\0\0\314p\0\0\0\0\0\0\314p\0\0\0\0\0\0\4\0\0\0\0\0\0\0Q\345td\6\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\0\20\0\0\0\0\0\0\0R\345td\4\0\0\0\360H!\0\0\0\0\0\360X!\0\0\0\0\0\360X!\0\0\0\0\0\0207\0\0\0\0\0\0&#34;, 832) = 832 &lt;0.000015&gt;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>子进程调用 openat() 和 read() 加载 hello_world.elf 程序所依赖的库文件 libc.so.6。</p><p>其中 openat() 会打开 libc.so.6 文件。
关于 openat() 具体怎么用可以看 &ldquo;openat(2) - open and possibly create a file&rdquo;。</p><p>openat() 的返回值 3 是个文件描述符。文件描述符是指当前进程在访问的文件，这个值一般大于等于 0。
linux 进程默认情况下会有 3 个缺省打开的文件描述符，分别是：标准输入 0、标准输出 1、标准错误 2。
然后，后面的 read 函数的第一个参数就是这个 3，表示从文件里读数据。</p><p>libc.so.6 是共享目标文件，也叫共享库、运行库、动态库。用户程序会调用运行库（C Runtime Library、CRT）。
运行库封装了操作系统更底层的系统调用函数。Linux、Windows、Mac，不同的操作系统，底层接口都是不一样的。
并且这些底层接口都比较 &ldquo;原始&rdquo;，如果想直接使用，那是比较复杂的，所以，要封装这些比较底层的系统调用。</p><p>关于静态链接和动态链接的详细的内容。我放到这篇里面去了。
<a href=/post/computer-science/operating-system/dynamically_statically_linked title=动态链接和静态链接>动态链接和静态链接</a></p><h4 id=write>write</h4><p>下一个关键的步骤是，是调用 write()。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>...
</span></span><span style=display:flex><span>3579  [00007f02af914a37] write(1, &#34;hello, world\n&#34;, 13) = 13 &lt;0.000117&gt;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>调用 write() 输出 &ldquo;hello, world\n&rdquo; 到屏幕上。返回值 13 表示 &ldquo;hello, world\n&rdquo; 有 13 个字节。</p><p>在源码里面，用的是 printf()。这个函数声明在 stdio.h 头文件里面。
它的底层实现最终调用的就是 write()，而 write() 的具体实现就在 libc.so.6 库里。
write() 就是操作系统暴露出来的最底层的函数了，再往下就要和驱动、硬件等相关了。</p><p>另外，程序是可以直接调用系统调用函数的。
也就是说，直接在程序里写 <code>write(1, "hello, world\n", 13)</code> 也是可以的。
但是，这个时候，头文件就不是 stdio.h 了，而是 unistd.h。就像下面这样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>#include</span> <span style=color:#75715e>&lt;unistd.h&gt;</span><span style=color:#75715e>
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> <span style=color:#a6e22e>main</span>() {
</span></span><span style=display:flex><span>  write(<span style=color:#ae81ff>1</span>, <span style=color:#e6db74>&#34;hello, world</span><span style=color:#ae81ff>\n</span><span style=color:#e6db74>&#34;</span>, <span style=color:#ae81ff>13</span>);
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>return</span> <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h4 id=exit_group>exit_group</h4><p>下一个关键的步骤是，是调用 exit_group()。
关于 exit_group() 具体怎么用可以看 &ldquo;exit_group(2) - exit all threads in a process&rdquo;。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>...
</span></span><span style=display:flex><span>3579  [00007f02af8eaca1] exit_group(0)  = ?
</span></span><span style=display:flex><span>3579  [????????????????] +++ exited with 0 +++
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>子进程调用 exit_group(0) 退出进程，参数值 0 是进程退出状态码，也就是程序里 return 的 0。</p><h4 id=wait4-1>wait4</h4><p>下一个关键的步骤是，是父进程从 wait4() 的阻塞状态中被唤醒。但是，父进程怎么被唤醒的呢。</p><blockquote><p>Topic 2 Multiprocessing (4)<br>A SIGCHLD is sent automatically by the kernel to a process, telling the process that one of its child process terminates or stops.</p></blockquote><p>子进程退出的时候，操作系统先知道。然后，操作系统会给父进程发一个 SIGCHLD 信号。
然后，父进程知道子进程退出了，前面调用的 wait4() 会回收退出的子进程，并回收子进程的内存资源。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>...
</span></span><span style=display:flex><span>2222  [00007f060c8ea45a] &lt;... wait4 resumed&gt;[{WIFEXITED(s) &amp;&amp; WEXITSTATUS(s) == 0}], WSTOPPED|WCONTINUED, NULL) = 3579 &lt;0.035522&gt;
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span>2222  [00007f060c89bc9b] --- SIGCHLD {si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=3579, si_uid=1000, si_status=0, si_utime=0, si_stime=0} ---
</span></span><span style=display:flex><span>2222  [00007f060c8ea45a] wait4(-1, 0x7ffdb295ab90, WNOHANG|WSTOPPED|WCONTINUED, NULL) = -1 ECHILD (No child processes) &lt;0.000005&gt;
</span></span><span style=display:flex><span>...
</span></span></code></pre></div><p>&ldquo;WIFEXITED(s)&rdquo; 和 &ldquo;WEXITSTATUS(s)&rdquo; 是宏函数，&ldquo;WEXITSTATUS(s)&rdquo; 可以拿到退出状态码。</p><h4 id=至此整个-hello-world-程序执行结束>至此整个 hello world 程序执行结束。</h4><h3 id=进程>进程</h3><p>上面 hello world 程序执行的过程，就是一个非常典型的进程的生命周期。
主要包括进程的创建、进程的运行、进程的内存资源、进程的退出、进程的回收。</p><p>关于这块的详细的内容。我放到这篇里面去了。
<a href=/post/computer-science/operating-system/linux/process title=进程的创建、进程的运行、进程的内存资源、进程的退出、进程的回收>进程的创建、进程的运行、进程的内存资源、进程的退出、进程的回收</a></p><h2 id=参考>参考</h2><ul><li><a href="https://baike.baidu.com/item/%E4%B8%BB%E7%BA%BF%E7%A8%8B/9600138?fr=aladdin" title=百度百科-主线程 rel="noopener external nofollow noreferrer" target=_blank class=exturl>百度百科-主线程
<i class="fa fa-external-link-alt"></i></a></li><li><a href=http://web.stanford.edu/~hhli/CS110Notes/CS110NotesCollection/Topic%202%20Multiprocessing%20%284%29.html title="Topic 2 Multiprocessing (4)" rel="noopener external nofollow noreferrer" target=_blank class=exturl>Topic 2 Multiprocessing (4)
<i class="fa fa-external-link-alt"></i></a></li></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/computer-science%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6>computer-science(计算机科学)</a>
<a href=/tags/operating-system%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f>operating-system(操作系统)</a>
<a href=/tags/elf>elf</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
运行 ELF 文件</li><li class=post-copyright-author><strong>本文作者：</strong>
西柊慧音</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/computer-science/operating-system/linux/exec_elf/ title="运行 ELF 文件">/post/computer-science/operating-system/linux/exec_elf/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/computer-science/operating-system/dynamically_statically_linked/ rel=next title=动态链接和静态链接><i class="fa fa-chevron-left"></i> 动态链接和静态链接</a></div><div class="post-nav-prev post-nav-item"><a href=/post/computer-science/programming-language/golang/reflect/ rel=prev title="Golang 反射的基本使用方式">Golang 反射的基本使用方式
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>西柊慧音</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.103.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.1 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":false,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.1","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.c997eeae723f2fcee19ae5066fcc64a49cefb92ddb75904efdb69a223e5a6740.js defer></script></body></html>