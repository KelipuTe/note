<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.103.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="进程的创建、进程的运行、进程的内存资源、进程的退出、进程的回收"><meta itemprop=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=keywords content="computer-science(计算机科学),operating-system(操作系统),process(进程)"><meta property="og:type" content="article"><meta property="og:title" content="进程的创建、进程的运行、进程的内存资源、进程的退出、进程的回收"><meta property="og:description" content><meta property="og:image" content="/image/pid49256268.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/computer-science/operating-system/linux/process/"><meta property="og:site_name" content="帕里特档案馆"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="西柊慧音"><meta property="article:published_time" content="2023-02-15 08:00:00 +0800 CST"><meta property="article:modified_time" content="2023-02-15 08:00:00 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.4da9279b6033ade10d67092d7bfb660265f9fa46c40974f17b13bfe235396546.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"process","permalink":"/post/computer-science/operating-system/linux/process/","title":"进程的创建、进程的运行、进程的内存资源、进程的退出、进程的回收","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>进程的创建、进程的运行、进程的内存资源、进程的退出、进程的回收 - 帕里特档案馆</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>帕里特档案馆</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>重建中</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>87</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#资料>资料</a></li><li><a href=#正文>正文</a><ul><li><a href=#进程的创建>进程的创建</a><ul><li><a href=#fock>fock()</a></li><li><a href=#pid-和-ppid>pid 和 ppid</a></li><li><a href=#子进程和父进程的内存空间>子进程和父进程的内存空间</a></li><li><a href=#copy-on-write写时复制>copy on write（写时复制）</a></li><li><a href=#子进程和父进程的区别>子进程和父进程的区别</a></li><li><a href=#vfork>vfork()</a></li></ul></li><li><a href=#进程的运行>进程的运行</a><ul><li><a href=#execve>execve()</a></li><li><a href=#exec>exec</a></li></ul></li><li><a href=#进程的运行顺序>进程的运行顺序</a></li><li><a href=#进程的内存数据>进程的内存数据</a><ul><li><a href=#proc-目录>/proc 目录</a></li><li><a href=#procpid-目录>/proc/[pid] 目录</a></li><li><a href=#进程内存布局>进程内存布局</a></li></ul></li><li><a href=#进程的资源限制>进程的资源限制</a></li><li><a href=#进程的退出>进程的退出</a><ul><li><a href=#进程退出的方式>进程退出的方式</a></li><li><a href=#exit>exit()</a></li><li><a href=#_exit_exit>_exit()、_Exit()</a></li><li><a href=#exit_group>exit_group()</a></li><li><a href=#退出状态码>退出状态码</a></li><li><a href=#不同退出方式下-printf-的区别>不同退出方式下 printf() 的区别</a></li></ul></li><li><a href=#进程的回收>进程的回收</a><ul><li><a href=#waitwaitpid>wait()、waitpid()</a></li><li><a href=#宏函数>宏函数</a></li><li><a href=#僵尸进程>僵尸进程</a></li></ul></li></ul></li><li><a href=#参考>参考</a></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=西柊慧音 src=/imgs/img-lazy-loading.gif data-src=/image/pid49256268.jpg><p class=site-author-name itemprop=name>西柊慧音</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>87</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>16</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>62</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/KelipuTe title="Github → https://github.com/KelipuTe" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=xhy_1365@sina.com title="E-Mail → xhy_1365@sina.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>E-Mail</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/computer-science/operating-system/linux/process/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=name content="西柊慧音"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="西柊慧音"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="进程的创建、进程的运行、进程的内存资源、进程的退出、进程的回收"><meta itemprop=description content="进程的创建、进程的运行、进程的运行顺序、进程的内存资源、进程的资源限制、进程的退出、进程的回收"></span><header class=post-header><h1 class=post-title itemprop="name headline">进程的创建、进程的运行、进程的内存资源、进程的退出、进程的回收</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2023-02-15 08:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2023-02-15 08:00:00 +0800 CST">2023-02-15</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/operating-system%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F itemprop=url rel=index><span itemprop=name>operating-system(操作系统)</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>6246</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>13分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/post/computer-science/operating-system/linux/process/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h2 id=前言>前言</h2><p>前置笔记：
<a href=/post/computer-science/operating-system/linux/exec_elf title="运行 ELF 文件">运行 ELF 文件</a></p><p>实践的环境：同
<a href title=程序>程序</a></p><h2 id=资料>资料</h2><ul><li><a href=https://github.com/KelipuTe/demo-c title={demo-c} rel="noopener external nofollow noreferrer" target=_blank class=exturl>{demo-c}
<i class="fa fa-external-link-alt"></i>
</a>/demo-in-linux/process/</li></ul><h2 id=正文>正文</h2><h3 id=进程的创建>进程的创建</h3><p>笔记主要涉及 fock()、vfock()。</p><h4 id=fock>fock()</h4><blockquote><p>fork() creates a new process by duplicating the calling process.</br>The new process is referred to as the child process.</br>The calling process is referred to as the parent process.</br>&mldr;</br></p></blockquote><p>fork() 通过复制调用进程创建一个新进程，新进程为子进程，调用进程为父进程。</p><blockquote><p>RETURN VALUE</br>On success, the PID of the child process is returned in the parent, and 0 is returned in the child.</br>On failure, -1 is returned in the parent, no child process is created, and errno is set to indicate the error.</p></blockquote><ul><li>成功时，父进程拿到子进程的 pid，子进程拿到 0。可以根据这个判断哪个是父进程，哪个是子进程。</li><li>失败时，父进程拿到-1，子进程不会被创建，errno 会被设置用于表示错误。</li></ul><p>代码示例：{demo-c}/demo-in-linux/process/fork.c</p><h4 id=pid-和-ppid>pid 和 ppid</h4><p>在终端里使用 <code>echo $$</code> 命令，可以打印当前进程的 pid。</p><p>getpid() 返回调用进程的 pid，getppid() 返回调用进程的父进程的 pid。
在使用时需要注意，必须让子进程先执行，父进程后执行，打印出来的 ppid 才是正确的。</p><p>代码示例：{demo-c}/demo-in-linux/process/pid_and_ppid.c</p><p>如果父进程在子进程执行前先跑完了，那么子进程打印出来的 ppid 就会变成 1。
因为父进程已经没了，子进程变成了孤儿进程。孤儿进程会被 1 号进程接管，有可能会变成后台进程。</p><p>1 号进程就是 init 进程。init 进程是所有其他进程的祖先进程，
它是 linux 系统启动过程中的第一个进程，也是系统在运行时的第一个用户级进程。
init 进程的 pid（进程标识符）是就是 1。</p><h4 id=子进程和父进程的内存空间>子进程和父进程的内存空间</h4><blockquote><p>DESCRIPTION</br>&mldr;</br>The child process and the parent process run in separate memory spaces.</br>At the time of fork() both memory spaces have the same content.</br>Memory writes, file mappings (mmap(2)), and unmappings (munmap(2)) performed by
one of the processes do not affect the other.</br>&mldr;</p></blockquote><p>两个进程运行在不同的内存空间，进程间是隔离的。在 fork() 时，两个进程的内存空间的内容是一样的（程序数据和程序指令）。
两个进程进行写内存操作（定义新的变量并赋值，修改已定义的变量的值，定义新的函数）或者文件映射（进程间通信）时互不影响。</p><p>代码示例：{demo-c}/demo-in-linux/process/fork_separate_memory.c</p><p>在 fork() 时，子进程和父进程代码是一样的，子进程会从 fork() 的下一行代码开始继续执行。
一般是父进程先被调度，除非父进程被阻塞了。</p><h4 id=copy-on-write写时复制>copy on write（写时复制）</h4><p>在 fork() 执行之后 exec() 执行之前，两个进程用的是相同的物理空间，子进程的代码段、数据段、堆栈都是指向父进程的物理空间。
两者的虚拟空间不同，但其对应的物理空间是同一个。当父子进程中有更改相应段的行为发生时，再为子进程相应的段分配物理空间。</p><p>如果没有执行 exec()，内核会给子进程的数据段、堆栈段分配相应的物理空间（两者有各自的进程空间，互不影响）。
而代码段继续共享父进程的物理空间（两者的代码完全相同）。
而如果执行了 exec()，由于两者执行的代码不同，子进程的代码段也会被分配单独的物理空间。</p><h4 id=子进程和父进程的区别>子进程和父进程的区别</h4><blockquote><p>DESCRIPTION</br>&mldr;</br>* The child has its own unique process ID, and this PID does not match
the ID of any existing process group (setpgid(2)) or session.</br>* The child&rsquo;s parent process ID is the same as the parent&rsquo;s process ID.</br>* The child does not inherit its parent&rsquo;s memory locks (mlock(2), mlockall(2)).</br>&mldr;</p></blockquote><ul><li>子进程有自己独立的唯一的进程标识（pid）。</li><li>子进程的父进程的 pid（ppid）和父进程的 pid 是一样的。</li><li>子进程不会继承父进程的内存锁。</li></ul><h4 id=vfork>vfork()</h4><blockquote><p>Linux description</br>vfork(), just like fork(2), creates a child process of the calling process.</br>For details and return value and errors, see fork(2).</br>&mldr;</br>vfork() differs from fork(2) in that the calling thread is suspended
until the child terminates (either normally, by calling_exit(2), or abnormally,
after delivery of a fatal signal), or it makes a call to execve(2).</br>Until that point, the child shares all memory with its parent, including the stack.</br>&mldr;</p></blockquote><p>vfork() 和 fork() 用法一样。区别在于，vfork() 创建子进程后，父进程会被阻塞，直到子进程退出。</p><p>代码示例：{demo-c}/demo-in-linux/process/vfork.c</p><p>而且 vfork() 创建出来的子进程和父进程共享内存，包括栈。</p><p>代码示例：{demo-c}/demo-in-linux/process/vfork_share_memory.c</p><p>vfork() 有 bug。当使用 <code>return 0</code> 结束或者执行到最后一行代码结束时，
有可能会报 &ldquo;Segmentation fault (core dumped)&rdquo; 错误。但是使用 <code>exit(0)</code>或者 <code>_exit(0)</code> 结束的时候不会。</p><p>通过 strace 命令追踪可以发现：报错时，子进程调用 <code>exit_group(0)</code> 退出，但是，父进程没有调用 <code>exit_group(0)</code>；
不报错时，两个进程都调用 <code>exit_group(0)</code> 退出。</p><p>这里猜测应该是共享内存的问题，如果子进程退出的时候把栈干碎了，那父进程被拉起来的时候，就没有栈，肯定会报错。</p><h3 id=进程的运行>进程的运行</h3><p>笔记主要涉及 execve()、exec 家族的六个函数。</p><p>程序被 execve() 加载到内存中时，需要操作系统分配内存资源。
准备工作做完后，下一步就是找到程序入口并开始执行。主进程默认会启动一个主线程去执行 main() 入口函数。</p><h4 id=execve>execve()</h4><blockquote><p>DESCRIPTION</br>execve() executes the program referred to by pathname.</br>&mldr;</br>pathname must be either a binary executable, or a script starting
with a line of the form: <code>#!interpreter [optional-arg]</code></br>&mldr;</p></blockquote><p>在当前正在运行的程序里，可以调用 execve() 通过另外一个新的程序的路径名执行它。
这个新的程序必须是一个二进制的可执行文件。或者是一个以 <code>#!interpreter [optional-arg]</code> 形式开始的脚本。
比如，shell 脚本文件开头的 <code>#!/bin/bash</code>。</p><blockquote><p>DESCRIPTION</br>&mldr;</br>This causes the program that is currently being run by the calling process to be replaced
with a new program, with newly initialized stack, heap, and (initialized and uninitialized) data segments.</br>&mldr;</br>execve() does not return on success, and the text, initialized data, uninitialized data (bss),
and stack of the calling process are overwritten according to the contents of the newly loaded program.</p></blockquote><p>execve() 在成功时不会返回。而是会导致当前正在运行的程序被另外一个新的程序所取代。
当前程序的 .test 段、.data 段、.bss 段、栈、堆等，都会被新的程序的数据覆盖。</p><h4 id=exec>exec</h4><blockquote><p>DESCRIPTION</br>The exec() family of functions replaces the current process image with a new process image.</br>The functions described in this manual page are layered on top of execve(2).</p></blockquote><p>简单理解，exec 家族的六个函数底层都是基于 execve() 实现的。</p><p>用 execl() 举例，代码示例：</p><ul><li>{demo-c}/demo-in-linux/process/execl.c</li><li>{demo-c}/demo-in-linux/process/call_by_exec.c</li></ul><p>用 execv() 举例，代码示例：</p><ul><li>{demo-c}/demo-in-linux/process/execv.c</li><li>{demo-c}/demo-in-linux/process/call_by_exec.c</li></ul><p>这个例子在 Ubuntu 22.04 环境中执行，会返回 Bad Address，不知道为什么。</p><h3 id=进程的运行顺序>进程的运行顺序</h3><blockquote><p>DESCRIPTION</br>The scheduling priority of the process, process group, or user, as indicated by which and who
is obtained with the getpriority() call and set with the setpriority() call.</br>The process attribute dealt with by these system calls is the same attribute
(also known as the &ldquo;nice&rdquo; value) that is dealt with by nice(2).</br>&mldr;</br>The prio argument is a value in the range -20 to 19 (but see NOTES below),
with -20 being the highest priority and 19 being the lowest priority.</br>Attempts to set a priority outside this range are silently clamped to the range.</br>The default priority is 0; lower values give a process a higher scheduling priority.</br>&mldr;</p></blockquote><p>进程的运行（执行、调度）顺序受到 PRI（priority）值和 NI（nice）值控制，这两个值对应进程的同一个属性。
值的范围是 -20~19，值越小，进程优先级越高。这两个值可以通过 ps 命令（<code>ps -ely</code>）查看（PRI 和 NI 参数），
也可以通过 top 命令查看（PR 和 NI 参数）。</p><p>在系统中，可以使用 nice 命令和 renice 命令调整进程的优先级。
nice 命令用于进程启动之前，renice 命令用于进程启动之后。</p><p>在代码中，getpriority() 可以查看进程优先级，setpriority()、nice() 可以调整进程优先级。
getpriority() 和 setpriority() 使用的时候需要注意的是，who 参数要和 which 参数对应。</p><p>代码示例：{demo-c}/demo-in-linux/process/nice.c</p><h3 id=进程的内存数据>进程的内存数据</h3><p>进程通过 execve() 将程序加载到内存中去执行，此时操作系统会它们分配相应的内存资源。分配的内存资源主要用于存储程序指令和程序数据。
还有额外的进程内存数据、进程标识、进程状态、哪个用户启动的、打开的文件等。这些数据主要存储在 /proc 目录中。</p><h4 id=proc-目录>/proc 目录</h4><blockquote><p>DESCRIPTION</br>The proc filesystem is a pseudo-filesystem which provides an interface to kernel data structures.
It is commonly mounted at /proc.</br>Typically, it is mounted automatically by the system, but it can also be mounted manually
using a command such as: <code>mount -t proc proc /proc</code></br>Most of the files in the proc filesystem are read-only, but some files are writable,
allowing kernel variables to be changed.</br>&mldr;</p></blockquote><p>proc 文件系统是一个伪文件系统，它提供了一个观察内核数据结构的接口。
一般来说，它会被操作系统自动挂载到 /proc 目录。proc 文件系统中的大多数文件都是只读的。
但是，有些文件是可写的，允许通过这些可写的文件改变内核变量。</p><blockquote><p>DESCRIPTION</br>&mldr;</br>/proc/[pid] subdirectories</br>Each one of these subdirectories contains files and subdirectories exposing information
about the process with the corresponding process ID.</br>&mldr;</p></blockquote><p>/proc 目录存储了操作系统上所有进程的内存数据。进程对应的目录用进程标识（pid）命名。
比如，进程标识（pid）为 42 的进程，对应的目录就是 /proc/42。</p><h4 id=procpid-目录>/proc/[pid] 目录</h4><blockquote><p>cmdline</br>This read-only file holds the complete command line for the process, unless the process is a zombie.</p></blockquote><p>cmdline，记录进程是用什么命令启动的。如果进程已经变成僵尸进程了，那么这个文件就是空的。</p><blockquote><p>environ</br>This file contains the initial environment that was set when
the currently executing program was started via execve(2).</p></blockquote><p>environ，记录进程启动的时候的环境参数。就是调用 execve() 启动程序的时候，传给 execve() 的环境参数。</p><blockquote><p>exe</br>Under Linux 2.2 and later, this file is a symbolic link
containing the actual pathname of the executed command.</br>This symbolic link can be dereferenced normally;
attempting to open it will open the executable.</br>You can even type /proc/[pid]/exe to run another copy of
the same executable that is being run by process [pid].</p></blockquote><p>exe，包含被执行命令的实际路径名的软连接。可以直接通过它启动程序。</p><blockquote><p>fd/</br>This is a subdirectory containing one entry for each file which the process has open,
named by its file descriptor, and which is a symbolic link to the actual file.</br>Thus, 0 is standard input, 1 standard output, 2 standard error, and so on.</p></blockquote><p>fd 目录，记录进程打开的文件。这里面的内容就是常说的文件标识符。
程序启动的时候一般都会打开 0（标准输入）、1（标准输出）、2（标准错误）这三个。
也就是说，程序里通过代码打开的文件的文件标识符一般都是从 3 开始的。</p><blockquote><p>limits</br>This file displays the soft limit, hard limit, and units of measurement for
each of the process&rsquo;s resource limits (see getrlimit(2)).</p></blockquote><p>limits，记录进程的资源限制。</p><blockquote><p>maps</br>A file containing the currently mapped memory regions and their access permissions.</br>See mmap(2) for some further information about memory mappings.</p></blockquote><p>maps，记录进程的内存映射和对内存的访问权限。在里面可以找到，进程的堆栈对应的内存地址到底在哪。</p><blockquote><p>net/</br>This directory contains various files and subdirectories
containing information about the networking layer.</br>The files contain ASCII structures and are, therefore, readable with cat(1).</br>However, the standard netstat(8) suite provides much cleaner access to these files.</p></blockquote><p>net 目录，记录进程和网络有关的数据。比如，和 socket 有关的东西。</p><blockquote><p>stat</br>Status information about the process. This is used by ps(1).</p></blockquote><p>stat，记录进程状态信息。比如，进程状态、线程、信号等。这个文件是给 ps 命令用的。</p><blockquote><p>statm</br>Provides information about memory usage, measured in pages.</p></blockquote><p>statm，以页为单位提供关于内存使用的信息。</p><blockquote><p>status</br>Provides much of the information in /proc/[pid]/stat and
/proc/[pid]/statm in a format that&rsquo;s easier for humans to parse.</p></blockquote><p>status，整合了 stat 和 statm 的内容。不过这个文件是给人看的，可读性更强。</p><h4 id=进程内存布局>进程内存布局</h4><blockquote><p>todo hkn linux 内存相关的会单独开一篇</p></blockquote><p>进程的内存空间被分为内核空间（kernel space）和用户空间。
用户空间里面主要关注：栈（stack）、文件映射（里面有动态库的映射）、堆（heap）、
读写数据区（主要是程序数据，.bss 段、.data 段等）、
只读数据区（主要是程序指令，.text 段；也有程序数据 .rodata 段等。</p><h3 id=进程的资源限制>进程的资源限制</h3><blockquote><p>DESCRIPTION</br>The getrlimit() and setrlimit() system calls get and set resource limits.</br>Each resource has an associated soft and hard limit,
&mldr;
The soft limit is the value that the kernel enforces for the corresponding resource.
The hard limit acts as a ceiling for the soft limit: an unprivileged process may set only its soft limit
to a value in the range from 0 up to the hard limit, and (irreversibly) lower its hard limit.
A privileged process (under Linux: one with the CAP_SYS_RESOURCE capability in the initial user namespace)
may make arbitrary changes to either limit value.
&mldr;</br></p></blockquote><p>getrlimit() 可以查看资源限制， setrlimit() 可以调整资源限制。
进程的资源限制包括软限制、硬限制等。其中软限制必须小于等于硬限制。</p><blockquote><p>The resource argument must be one of:</br>&mldr;</br>RLIMIT_NOFILE</br>This specifies a value one greater than the maximum file descriptor number
that can be opened by this process.</br>Attempts (open(2), pipe(2), dup(2), etc.) to exceed this limit yield the error EMFILE.
(Historically, this limit was named RLIMIT_OFILE on BSD.)</br>&mldr;</br></p></blockquote><p>可以通过资源参数指定需要操作的资源。比如 RLIMIT_NOFILE 对应进程可以打开的文件个数。
这个参数很重要，因为 linux 上一切皆文件。</p><p>代码示例：{demo-c}/demo-in-linux/process/rlimit.c</p><p>另外，在生产环境中，应该优先在程序中动态修改资源限制，不要轻易修改操作系统的资源限制。</p><h3 id=进程的退出>进程的退出</h3><p>笔记主要涉及：exit()、_exit()、_Exit()、exit_group()、abort()。</p><p>代码示例：{demo-c}/demo-in-linux/process/exit.c</p><h4 id=进程退出的方式>进程退出的方式</h4><ul><li>程序运行到最后一行代码。</li><li>主动调用 exit()、_exit()、_Exit()、exit_group()</li><li>主动 <code>return 0</code>。</li><li>主动调用 abort()，会导致进程异常终止，报 &ldquo;Aborted (core dumped)&rdquo; 错误。</li><li>进程收到了中断信号。</li></ul><h4 id=exit>exit()</h4><blockquote><p>DESCRIPTION</br>The exit() function causes normal process termination and the least significant byte of
status (i.e., status & 0xFF) is returned to the parent (see wait(2)).</br>All functions registered with atexit(3) and on_exit(3) are called,
in the reverse order of their registration.</br>&mldr;</br>If one of these functions does not return (e.g., it calls _exit(2), or kills itself with a signal),
then none of the remaining functions is called, and further exit processing
(in particular, flushing of stdio(3) streams) is abandoned.</br>All open stdio(3) streams are flushed and closed.</br>Files created by tmpfile(3) are removed.</br>&mldr;</p></blockquote><p>exit() 会让进程正常终止，退出状态码会先和 0xFF 做与运算，然后返回给父进程。所有打开的 stdio(3) 流会被刷新然后关闭</p><h4 id=_exit_exit>_exit()、_Exit()</h4><blockquote><p>DESCRIPTION</br>_exit() terminates the calling process &ldquo;immediately&rdquo;.</br>Any open file descriptors belonging to the process are closed.</br>Any children of the process are inherited by init(1)
(or by the nearest &ldquo;subreaper&rdquo; process as defined through the use of
the prctl(2) PR_SET_CHILD_SUBREAPER operation).</br>The process&rsquo;s parent is sent a SIGCHLD signal.</br>The value status & 0xFF is returned to the parent process as the process&rsquo;s exit status,
and can be collected by the parent using one of the wait(2) family of calls.</br>The function _Exit() is equivalent to _exit().</p></blockquote><blockquote><p>NOTES</br>&mldr;</br>The function _exit() is like exit(3), but does not call any
functions registered with atexit(3) or on_exit(3).</br>Open stdio(3) streams are not flushed.</br>&mldr;</p></blockquote><p>_exit() （_Exit()和 _exit() 是等价的）会让进程立即终止，
子进程退出时会向父进程发送 SIGCHLD 中断信号，退出状态码会先和 0xFF 做与运算，然后返回给父进程。
打开的 stdio(3) 流不会被刷新。</p><h4 id=exit_group>exit_group()</h4><blockquote><p>SYNOPSIS<br>Note: glibc provides no wrapper for exit_group(), necessitating the use of syscall(2).</p></blockquote><blockquote><p>DESCRIPTION
This system call is equivalent to _exit(2) except that it terminates
not only the calling thread, but all threads in the calling process&rsquo;s thread group.</p></blockquote><h4 id=退出状态码>退出状态码</h4><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[00007fdf9e51ea3d] exit_group(0)        = ?
</span></span><span style=display:flex><span>[????????????????] +++ exited with 0 +++
</span></span></code></pre></div><p>退出状态码会先和 0xFF 做与运算。这个的意思是说，加入退出状态码设置的是 300，那实际返回的是 300 & 255 的结果，也就是 44。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[00007fb290aeaca1] exit_group(300)      = ?
</span></span><span style=display:flex><span>[????????????????] +++ exited with 44 +++
</span></span></code></pre></div><p>在终端里使用 <code>echo $?</code> 命令，可以打印上一个程序的退出状态码。</p><h4 id=不同退出方式下-printf-的区别>不同退出方式下 printf() 的区别</h4><p>上面提到，过不同的退出方式，对打开的 stdio(3) 流的处理方式不一样。</p><p>程序运行到最后一行代码、主动 <code>return 0</code>、主动调用 exit() 时，会检查文件的打开情况，处理 I/O 缓冲区内的内容。
而主动调用 _exit()、_Exit()、exit_group 时不会。</p><p>也就是对于 <code>printf("hello, world")</code> （注意，没有 \n）来说，前面三个方式会输出 hello, world，而前面三个方式不会输出。</p><h3 id=进程的回收>进程的回收</h3><p>笔记主要涉及：wait()、waitpid()</p><h4 id=waitwaitpid>wait()、waitpid()</h4><p>这两个系统调用的声明如下。</p><blockquote><p>pid_t wait(int *wstatus);</br>pid_t waitpid(pid_t pid, int *wstatus, int options);</p></blockquote><blockquote><p>DESCRIPTION</br>All of these system calls are used to wait for state changes in a child of the calling process,
and obtain information about the child whose state has changed.</br>A state change is considered to be: the child terminated; the child was stopped by a signal;
or the child was resumed by a signal.</br></br>If a child has already changed state, then these calls return immediately.</br>Otherwise, they block until either a child changes state or a signal handler interrupts the call
(assuming that system calls are not automatically restarted using the SA_RESTART flag of sigaction(2)).</br>&mldr;</p></blockquote><blockquote><p>RETURN VALUE</br>wait(): on success, returns the process ID of the terminated child; on failure, -1 is returned.</br>waitpid(): on success, returns the process ID of the child whose state has changed;
if WNOHANG was specified and one or more child(ren) specified by pid exist,
but have not yet changed state, then 0 is returned. On failure, -1 is returned.</p></blockquote><p>wait() 用于等待调用进程的一个子进程的状态变化，并获取状态发生变化的子进程的信息。
比如，子进程终止；子进程被信号停止；子进程被信号恢复。如果一个子进程已经改变了状态，那么调用进程调用 wait() 会立即返回。
否则，调用进程就会阻塞，直到子进程改变状态或信号处理程序中断调用。</p><blockquote><p>DESCRIPTION</br>The wait() system call suspends execution of the calling thread until one of its children terminates.</br>The call <code>wait(&wstatus)</code> is equivalent to: <code>waitpid(-1, &wstatus, 0)</code></br>&mldr;</br></p></blockquote><p><code>wait(&status)</code> 和 <code>waitpid(-1, &status, 0)</code> 是等效的。</p><blockquote><p>DESCRIPTION</br>If wstatus is not NULL, wait() and waitpid() store status information in the int to which it points.</br>This integer can be inspected with the following macros
(which take the integer itself as an argument, not a pointer to it, as is done in wait() and waitpid()!):</br>&mldr;</p></blockquote><p>wait()、waitpid() 调用成功的时候，返回值是子进程的 pid，传进去的参数 wstatus 会记录子进程的退出信息。
退出信息可以用提供的宏函数确定是哪一种。</p><p>代码示例：{demo-c}/demo-in-linux/process/wait.c</p><h4 id=宏函数>宏函数</h4><blockquote><p>WIFEXITED(wstatus)</br>returns true if the child terminated normally, that is, by calling exit(3) or _exit(2),
or by returning from main().</br></p></blockquote><p>如果子进程是正常退出的 <code>WIFEXITED(wstatus)</code> 会返回一个非零值。</p><blockquote><p>WEXITSTATUS(wstatus)</br>returns the exit status of the child.</br>This consists of the least significant 8 bits of the status argument
that the child specified in a call to exit(3) or _exit(2)
or as the argument for a return statement in main().</br>This macro should be employed only if WIFEXITED returned true.</p></blockquote><p>当 WIFEXITED() 返回非零值时，可以用 WEXITSTATUS() 来提取子进程的返回值。
如果子进程调用 <code>exit(5)</code> 退出，<code>WEXITSTATUS(status)</code> 就会返回 5。</p><p>代码示例：{demo-c}/demo-in-linux/process/waitpid_macros.c</p><h4 id=僵尸进程>僵尸进程</h4><blockquote><p>DESCRIPTION</br>In the case of a terminated child, performing a wait allows the system to release
the resources associated with the child; if a wait is not performed,
then the terminated child remains in a &ldquo;zombie&rdquo; state (see NOTES below).</br></p></blockquote><p>在子进程终止的情况下，调用进程执行等待可以让操作系统释放与子进程相关的资源。
如果调用进程不执行等待，那么被终止的子进程就会处于"僵尸"状态，也就是僵尸进程。
当父进程也结束的时候，操作系统会把父进程和回收僵尸进程一起回收。</p><p>代码示例：{demo-c}/demo-in-linux/process/for_zombie.c</p><p>这里运行一下，下面的是输出到终端上的内容。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>&gt; ./for_zombie.elf
</span></span><span style=display:flex><span>[debug]:parent, getpid()=3592
</span></span><span style=display:flex><span>[debug]:parent, getpid()=3592, forkResult=3593
</span></span><span style=display:flex><span>[debug]:child, getpid()=3593, forkResult=0
</span></span></code></pre></div><p>然后通过 ps 命令看一下 for_zombie 的运行情况。进程 3593 后面那个 &ldquo;Z+&rdquo; 就表示，它已经是一个僵尸进程了。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>qqq         3592  0.0  0.0   2772   944 pts/0    S+   20:14   0:00 ./for_zombie.elf
</span></span><span style=display:flex><span>qqq         3593  0.0  0.0      0     0 pts/0    Z+   20:14   0:00 [for_zombie.elf] &lt;defunct&gt;
</span></span></code></pre></div><p>当进程变成僵尸进程时，它的内存数据还驻留在内存中，/proc 目录下的相关文件也不会移除，这些东西依然在占用系统资源。
如果僵尸进程过多，会导致系统资源紧张，会影响操作系统的运行。所以必须要回收退出的子进程。</p><h2 id=参考>参考</h2><ul><li><a href=https://www.cnblogs.com/cpsmile/p/4382106.html title=Linux进程控制 rel="noopener external nofollow noreferrer" target=_blank class=exturl>Linux进程控制
<i class="fa fa-external-link-alt"></i></a></li></ul></div><footer class=post-footer><div class=post-tags><a href=/tags/computer-science%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6>computer-science(计算机科学)</a>
<a href=/tags/operating-system%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f>operating-system(操作系统)</a>
<a href=/tags/process%e8%bf%9b%e7%a8%8b>process(进程)</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
进程的创建、进程的运行、进程的内存资源、进程的退出、进程的回收</li><li class=post-copyright-author><strong>本文作者：</strong>
西柊慧音</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/computer-science/operating-system/linux/process/ title=进程的创建、进程的运行、进程的内存资源、进程的退出、进程的回收>/post/computer-science/operating-system/linux/process/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/computer-science/hardware/alu/ rel=next title="算术逻辑单元（Arithmetic and Logic Unit、ALU）"><i class="fa fa-chevron-left"></i> 算术逻辑单元（Arithmetic and Logic Unit、ALU）</a></div><div class="post-nav-prev post-nav-item"><a href=/post/computer-science/programming-language/framework/web/golang/middleware_v2/ rel=prev title="Golang 实现简单的 Web 框架 -- middleware(中间件)">Golang 实现简单的 Web 框架 -- middleware(中间件)
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>西柊慧音</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.103.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.1 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":false,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.1","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.c997eeae723f2fcee19ae5066fcc64a49cefb92ddb75904efdb69a223e5a6740.js defer></script></body></html>