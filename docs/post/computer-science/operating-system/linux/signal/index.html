<!doctype html><html lang=zh-cn data-theme=light><head><meta charset=utf-8><meta name=viewport content="width=device-width"><meta name=theme-color content="#222" media="(prefers-color-scheme: light)"><meta name=generator content="Hugo 0.103.1"><link rel="shortcut icon" type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/x-icon href=/imgs/icons/favicon.ico><link rel=icon type=image/png sizes=16x16 href=/imgs/icons/favicon_16x16_next.png><link rel=icon type=image/png sizes=32x32 href=/imgs/icons/favicon_32_32_next.png><link rel=apple-touch-icon sizes=180x180 href=/imgs/icons/apple_touch_icon_next.png><meta itemprop=name content="信号"><meta itemprop=description content><meta itemprop=datePublished zgotmplz><meta itemprop=dateModified zgotmplz><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=keywords content="computer-science(计算机科学),operating-system(操作系统),signal(信号)"><meta property="og:type" content="article"><meta property="og:title" content="信号"><meta property="og:description" content><meta property="og:image" content="/image/pid49256268.jpg"><meta property="og:image:width" content="312"><meta property="og:image:height" content="312"><meta property="og:image:type" content="image/jpeg/png/svg/jpg"><meta property="og:url" content="/post/computer-science/operating-system/linux/signal/"><meta property="og:site_name" content="帕里特档案馆"><meta property="og:locale" content="zh-CN"><meta property="article:author" content="西柊慧音"><meta property="article:published_time" content="2022-04-16 08:00:00 +0800 CST"><meta property="article:modified_time" content="2022-04-16 08:00:00 +0800 CST"><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/font-awesome/6.1.2/css/all.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/animate.css/3.1.1/animate.min.css><link type=text/css rel=stylesheet href=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.css><link rel=stylesheet href=/css/main.min.4da9279b6033ade10d67092d7bfb660265f9fa46c40974f17b13bfe235396546.css><style type=text/css>.post-footer,.flinks-list-footer hr:after{content:"~ 我可是有底线的哟 ~"}</style><script type=text/javascript>(function(){localDB={set:function(e,t,n){if(n===0)return;const s=new Date,o=n*864e5,i={value:t,expiry:s.getTime()+o};localStorage.setItem(e,JSON.stringify(i))},get:function(e){const t=localStorage.getItem(e);if(!t)return void 0;const n=JSON.parse(t),s=new Date;return s.getTime()>n.expiry?(localStorage.removeItem(e),void 0):n.value}},theme={active:function(){const e=localDB.get("theme");if(e==null)return;theme.toggle(e),window.matchMedia("(prefers-color-scheme: dark)").addListener(function(e){theme.toggle(e.matches?"dark":"light")})},toggle:function(e){document.documentElement.setAttribute("data-theme",e),localDB.set("theme",e,2);const t=document.querySelector("iframe.giscus-frame");if(t){const n={setConfig:{theme:e}};t.contentWindow.postMessage({giscus:n},"https://giscus.app")}}},theme.active()})(window)</script><script class=next-config data-name=page type=application/json>{"comments":false,"isHome":false,"isPage":true,"path":"signal","permalink":"/post/computer-science/operating-system/linux/signal/","title":"信号","waline":{"js":[{"alias":"waline","alias_name":"@waline/client","file":"dist/pageview.js","name":"pageview","version":"2.13.0"},{"alias":"waline","alias_name":"@waline/client","file":"dist/comment.js","name":"comment","version":"2.13.0"}]}}</script><script type=text/javascript>document.addEventListener("DOMContentLoaded",()=>{var e=document.createElement("script");e.charset="UTF-8",e.src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js",e.async=!1,e.defer=!0,document.head.appendChild(e),e.onload=function(){NexT.utils.fmtBusuanzi()}})</script><title>信号 - 帕里特档案馆</title><noscript><link rel=stylesheet href=/css/noscript.css></noscript></head><body itemscope itemtype=http://schema.org/WebPage class=use-motion><div class=headband></div><main class=main><header class=header itemscope itemtype=http://schema.org/WPHeader><div class=header-inner><div class=site-brand-container><div class=site-nav-toggle><div class=toggle aria-label=切换导航栏 role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div></div><div class=site-meta><a href=/ class=brand rel=start><i class=logo-line></i><h1 class=site-title>帕里特档案馆</h1><i class=logo-line></i></a><p class=site-subtitle itemprop=description>重建中</p></div><div class=site-nav-right><div class="toggle popup-trigger"><i class="fa fa-search fa-fw fa-lg"></i></div></div></div><nav class=site-nav><ul class="main-menu menu"><li class="menu-item menu-item-home"><a href=/ class=hvr-icon-pulse rel=section><i class="fa fa-home hvr-icon"></i>首页</a></li><li class="menu-item menu-item-about"><a href=/about/ class=hvr-icon-pulse rel=section><i class="fa fa-user hvr-icon"></i>关于</a></li><li class="menu-item menu-item-archives"><a href=/archives/ class=hvr-icon-pulse rel=section><i class="fa fa-archive hvr-icon"></i>归档
<span class=badge>96</span></a></li><li class="menu-item menu-item-commonweal"><a href=/404.html class=hvr-icon-pulse rel=section><i class="fa fa-heartbeat hvr-icon"></i>公益 404</a></li><li class="menu-item menu-item-search"><a role=button class="popup-trigger hvr-icon-pulse"><i class="fa fa-search fa-fw hvr-icon"></i>搜索</a></li></ul></nav><div class=search-pop-overlay><div class="popup search-popup"><div class=search-header><span class=search-icon><i class="fa fa-search"></i></span><div class=search-input-container><input autocomplete=off autocapitalize=off maxlength=80 placeholder=搜索... spellcheck=false type=search class=search-input></div><span class=popup-btn-close role=button><i class="fa fa-times-circle"></i></span></div><div class="search-result-container no-result"><div class=search-result-icon><i class="fa fa-spinner fa-pulse fa-5x"></i></div></div></div></div></div><div class="toggle sidebar-toggle" role=button><span class=toggle-line></span>
<span class=toggle-line></span>
<span class=toggle-line></span></div><aside class=sidebar><div class="sidebar-inner sidebar-nav-active sidebar-toc-active"><ul class=sidebar-nav><li class=sidebar-nav-toc>文章目录</li><li class=sidebar-nav-overview>站点概览</li></ul><div class=sidebar-panel-container><div class="post-toc-wrap sidebar-panel"><div class="post-toc animated"><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#资料>资料</a></li><li><a href=#正文>正文</a><ul><li><a href=#硬件中断>硬件中断</a></li><li><a href=#软件中断>软件中断</a></li><li><a href=#中断处理例程和中断处理程序的区别>中断处理例程和中断处理程序的区别</a></li><li><a href=#信号对进程的影响>信号对进程的影响</a></li><li><a href=#信号的产生>信号的产生</a></li><li><a href=#linux-中的信号>Linux 中的信号</a></li><li><a href=#信号的使用>信号的使用</a></li><li><a href=#信号和-waitpid>信号和 waitpid()</a></li><li><a href=#信号和系统调用>信号和系统调用</a><ul><li><a href=#系统调用返回错误>系统调用返回错误</a></li><li><a href=#系统调用重新开始>系统调用重新开始</a></li></ul></li><li><a href=#信号屏蔽和未决信号>信号屏蔽和未决信号</a></li><li><a href=#小的知识点>小的知识点</a><ul><li><a href=#sigkillsigstop>SIGKILL、SIGSTOP</a></li><li><a href=#sigalrm>SIGALRM</a></li></ul></li><li><a href=#观察进程数据>观察进程数据</a></li></ul></li></ul></nav></div></div><div class="site-overview-wrap sidebar-panel"><div class="site-author site-overview-item animated" itemprop=author itemscope itemtype=http://schema.org/Person><img class=site-author-image itemprop=image alt=西柊慧音 src=/imgs/img-lazy-loading.gif data-src=/image/pid49256268.jpg><p class=site-author-name itemprop=name>西柊慧音</p><div class=site-description itemprop=description></div></div><div class="site-state-wrap site-overview-item animated"><nav class=site-state><div class="site-state-item site-state-posts"><a href=/archives/><span class=site-state-item-count>96</span>
<span class=site-state-item-name>日志</span></a></div><div class="site-state-item site-state-categories"><a href=/categories/><span class=site-state-item-count>17</span>
<span class=site-state-item-name>分类</span></a></div><div class="site-state-item site-state-tags"><a href=/tags/><span class=site-state-item-count>64</span>
<span class=site-state-item-name>标签</span></a></div></nav></div><div class="links-of-social site-overview-item animated"><span class=links-of-social-item><a href=https://github.com/KelipuTe title="Github → https://github.com/KelipuTe" rel=noopener class=hvr-icon-pulse target=_blank><i class="fab fa-github fa-fw hvr-icon"></i>Github</a></span>
<span class=links-of-social-item><a href=xhy_1365@sina.com title="E-Mail → xhy_1365@sina.com" rel=noopener class=hvr-icon-pulse target=_blank><i class="fa fa-envelope fa-fw hvr-icon"></i>E-Mail</a></span></div><div class="cc-license animated" itemprop=license><a href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh class=cc-opacity rel=noopener target=_blank title=共享知识><img src=/imgs/img-lazy-loading.gif data-src=/imgs/cc/big/by_nc_sa.svg alt=共享知识></a></div><div class="links-of-blogroll site-overview-item animated"><div class=links-of-blogroll-title><i class="fa fa-globe fa-fw"></i>友情链接</div><ul class=links-of-blogroll-list><li class=links-of-blogroll-item><a href=https://gitee.com/hugo-next/hugo-theme-next title=https://gitee.com/hugo-next/hugo-theme-next target=_blank>Hugo-NexT</a></li><li class=links-of-blogroll-item><a href=https://lisenhui.cn title=https://lisenhui.cn target=_blank>凡梦星尘空间站</a></li></ul></div></div></div></div></aside><div class=sidebar-dimmer></div></header><div class=tool-buttons><div id=toggle-theme class=button title=深浅模式切换><i class="fas fa-adjust"></i></div><div class=back-to-top role=button title=返回顶部><i class="fa fa-arrow-up"></i>
<span>0%</span></div></div><div class=reading-progress-bar></div><a role=button class="book-mark-link book-mark-link-fixed"></a>
<a href=https://github.com/hugo-next rel="noopener external nofollow noreferrer" target=_blank title="Follow me on GitHub" class="exturl github-corner"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0 0 115 115h15l12 27L250 250V0z"/><path d="M128.3 109C113.8 99.7 119 89.6 119 89.6 122 82.7 120.5 78.6 120.5 78.6 119.2 72 123.4 76.3 123.4 76.3 127.3 80.9 125.5 87.3 125.5 87.3 122.9 97.6 130.6 101.9 134.4 103.2" fill="currentcolor" style="transform-origin:130px 106px" class="octo-arm"/><path d="M115 115C114.9 115.1 118.7 116.5 119.8 115.4l13.9-13.8C136.9 99.2 139.9 98.4 142.2 98.6 133.8 88 127.5 74.4 143.8 58 148.5 53.4 154 51.2 159.7 51 160.3 49.4 163.2 43.6 171.4 40.1 171.4 40.1 176.1 42.5 178.8 56.2 183.1 58.6 187.2 61.8 190.9 65.4 194.5 69 197.7 73.2 200.1 77.6 213.8 80.2 216.3 84.9 216.3 84.9 212.7 93.1 206.9 96 205.4 96.6 205.1 102.4 203 107.8 198.3 112.5 181.9 128.9 168.3 122.5 157.7 114.1 157.9 116.9 156.7 120.9 152.7 124.9L141 136.5C139.8 137.7 141.6 141.9 141.8 141.8z" fill="currentcolor" class="octo-body"/></svg></a><noscript><div class=noscript-warning>Theme NexT works best with JavaScript enabled</div></noscript><div class="main-inner post posts-expand"><div class=post-block><article itemscope itemtype=http://schema.org/Article class=post-content lang><link itemprop=mainEntityOfPage href=/post/computer-science/operating-system/linux/signal/><span hidden itemprop=author itemscope itemtype=http://schema.org/Person><meta itemprop=image content="/image/pid49256268.jpg"><meta itemprop=name content="西柊慧音"></span><span hidden itemprop=publisher itemscope itemtype=http://schema.org/Organization><meta itemprop=name content="西柊慧音"><meta itemprop=description content></span><span hidden itemprop=post itemscope itemtype=http://schema.org/CreativeWork><meta itemprop=name content="信号"><meta itemprop=description content="硬件中断；软件中断；中断处理例程和中断处理程序；信号对进程的影响；信号的产生；信号的使用；信号屏蔽和未决信号；"></span><header class=post-header><h1 class=post-title itemprop="name headline">信号</h1><div class=post-meta-container><div class=post-meta-items><span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-calendar"></i></span>
<span class=post-meta-item-text>发表于：</span>
<time title="发表于：2022-04-16 08:00:00 +0800 CST" itemprop="dateCreated datePublished" datetime="2022-04-16 08:00:00 +0800 CST">2022-04-16</time></span>
<span class=post-meta-item><span class=post-meta-item-icon><i class="far fa-folder-open"></i></span>
<span class=post-meta-item-text>分类于：</span>
<span itemprop=about itemscope itemtype=http://schema.org/Thing><a href=/categories/operating-system%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F itemprop=url rel=index><span itemprop=name>operating-system(操作系统)</span></a></span></span></div><div class=post-meta-items><span class=post-meta-item title=字数><span class=post-meta-item-icon><i class="far fa-file-word"></i></span>
<span class=post-meta-item-text>字数：</span><span>4222</span></span>
<span class=post-meta-item title=阅读><span class=post-meta-item-icon><i class="far fa-clock"></i></span>
<span class=post-meta-item-text>阅读：&ap;</span>
<span>9分钟</span></span>
<span class=post-meta-item title=浏览><span class=post-meta-item-icon><i class="far fa-eye"></i></span>
<span class=post-meta-item-text>浏览：</span>
<span id=busuanzi_value_page_pv data-path=/post/computer-science/operating-system/linux/signal/><i class="fa fa-sync fa-spin"></i></span></span></div></div></header><div class="post-body autonumber" itemprop=articleBody><h2 id=前言>前言</h2><p>前置笔记：
<a href=/post/computer-science/operating-system/linux/process title=进程的创建、进程的运行、进程的内存资源、进程的退出、进程的回收>进程的创建、进程的运行、进程的内存资源、进程的退出、进程的回收</a></p><p>实践的环境：同
<a href title=程序>程序</a></p><h2 id=资料>资料</h2><ul><li><a href=https://github.com/KelipuTe/demo-c title={demo-c} rel="noopener external nofollow noreferrer" target=_blank class=exturl>{demo-c}
<i class="fa fa-external-link-alt"></i>
</a>/demo-in-linux/signal/</li></ul><h2 id=正文>正文</h2><h3 id=硬件中断>硬件中断</h3><p>硬件中断（hardware interrupt）是一个由硬件设备产生的信号，它需要 CPU 关注。
硬件中断用于允许硬件设备与 CPU 进行通信，而不需要一直轮询或者等待 CPU 关注。</p><p>当一个硬件设备产生一个中断时，它向中断控制器发送一个信号。
然后，中断控制器（interrupt controller）向 CPU 发送一个信号，中断其当前任务并处理该设备的请求。
然后，CPU 将停止执行其当前任务并处理中断，这包括暂时保存 CPU 的状态和执行中断处理例程（interrupt handler routine）。</p><p>中断处理例程是一段由 CPU 响应中断而执行的代码。
它负责确定是哪个设备产生了中断，处理来自该设备的请求，并恢复 CPU 的状态，以便它能够恢复其先前的任务。</p><p>硬件中断对于计算机系统的正常运行至关重要，因为它们允许硬件设备与 CPU 进行交互，而不会垄断 CPU 的资源。
产生中断的硬件设备的常见例子包括键盘、鼠标、网卡和硬盘。</p><p>硬件中断可以大概分为下面几部分：中断请求，中断响应，保护现场，中断处理，恢复现场，中断返回。</p><p>比如，CPU 正在跑一个程序。这时，按一下键盘（产生中断请求）。这个中断请求被发给 CPU 之后，CPU 会做出反应（中断响应）。</p><p>这时，CPU 会先停下正在跑的程序，把程序现在的状态记下来（保护现场）。
然后，过来处理这个中断请求（中断处理）。这个时候 CPU 里跑的是另外一个程序（中断处理例程）。</p><p>中断处理例程执行结束之后，需要把状态恢复到刚才停下的那个时候（恢复现场）。
这次中断就完事了，从中断处理例程中退出来（中断返回）。然后，就可以继续执行程序了。</p><h3 id=软件中断>软件中断</h3><p>软件中断（software interrupt）也被称为陷阱（trap）或异常（exception），是一个由程序产生的信号。
它使 CPU 中断其当前任务并执行一个特定的例程（routine）来处理中断。
与由外部硬件设备产生的硬件中断不同，软件中断是由 CPU 上运行的程序产生的。</p><p>有两种主要的软件中断类型：同步（synchronous）和异步（asynchronous）。
同步中断是由 CPU 响应程序中的指令而产生的，比如，除以 0 或无效的内存访问。
异步中断是由外部事件产生的，比如，一个定时器或来自另一个进程的信号。</p><p>当一个软件中断产生时，CPU 会保存程序的当前状态，包括指令指针和寄存器值，并跳转到一个特定的例程，称为中断处理程序或异常处理程序。
中断处理程序负责处理中断，其中可能涉及错误处理、内存管理或 I/O 操作等任务。</p><p>中断处理完毕后，CPU 恢复程序的保存状态，并在被中断的地方恢复执行。
软件中断是程序与操作系统进行通信和执行需要特权访问的任务的重要机制，比如，系统调用或中断另一个进程。</p><h3 id=中断处理例程和中断处理程序的区别>中断处理例程和中断处理程序的区别</h3><p>中断处理例程（interrupt handler routine）和中断处理程序（interrupt handler）的关键区别在于，
中断处理例程是响应硬件设备的中断信号而执行的代码，而中断处理程序是管理中断信号并调用适当的中断处理例程的代码。</p><h3 id=信号对进程的影响>信号对进程的影响</h3><blockquote><p>signal(7)</br>Linux supports both POSIX reliable signals (hereinafter &ldquo;standard signals&rdquo;)
and POSIX real-time signals.</br>Signal dispositions</br>Each signal has a current disposition, which determines how the process behaves
when it is delivered the signal.</br>The entries in the &ldquo;Action&rdquo; column of the table below specify
the default disposition for each signal, as follows:</br>&ndash; Term:Default action is to terminate the process.</br>&ndash; Ign:Default action is to ignore the signal.</br>&ndash; Core:Default action is to terminate the process and dump core (see core(5)).</br>&ndash; Stop:Default action is to stop the process.</br>&ndash; Cont:Default action is to continue the process if it is currently stopped.</br>A process can change the disposition of a signal using sigaction(2) or signal(2).
(The latter is less portable when establishing a signal handler; see signal(2) for details.)<br>Using these system calls, a process can elect one of the following behaviors
to occur on delivery of the signal: perform the default action; ignore the signal;
or catch the signal with a signal handler, a programmer-defined function
that is automatically invoked when the signal is delivered.</p></blockquote><p>每个信号都有一个当前处置，它决定了进程在收到信号时如何进程在收到信号时的行为。
下面是每种信号的默认处理方式：Term：进程终止；Ign：进程忽略；
Core：进程终止并产生 &ldquo;core dump&rdquo; 文件；Stop：进程停止；Cont：进程继续执行</p><p>进程可以更改信号的设置，信号发生时可以选择下面三种行为。
执行默认动作（default action，SIG_DFL）；忽略信号（ignore，SIG_IGN）；使用信号处理程序捕捉信号（signal hanlder）</p><h3 id=信号的产生>信号的产生</h3><ul><li>终端按下 Ctrl+C，产生 SIGINT 信号；终端按下 Ctrl+\ 产生 SIGQUIT 信号；终端按下 Ctrl+Z 产生 SIGSTOP 信号。</li><li>进程访问一些不存在的内存或是非法内存，会产生 SIGSEGV 中断信号</li><li>在终端中，使用 kill 命令发送</li><li>在进程中，使用 raise()、kill()、alarm() 等发送中断信号</li><li>子进程退出时会产生中断信号</li></ul><h3 id=linux-中的信号>Linux 中的信号</h3><p>在 Linux 中，中断信号有64个，分位标准信号和实时信号。
可以通过 &ldquo;kill -l&rdquo; 命令可以查看 Linux 中的 64 个中断信号。其中，带 RT（real time）的就是实时信号。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span> 1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
</span></span><span style=display:flex><span> 6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
</span></span><span style=display:flex><span>11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
</span></span><span style=display:flex><span>16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
</span></span><span style=display:flex><span>21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
</span></span><span style=display:flex><span>26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
</span></span><span style=display:flex><span>31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
</span></span><span style=display:flex><span>38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
</span></span><span style=display:flex><span>43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
</span></span><span style=display:flex><span>48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
</span></span><span style=display:flex><span>53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
</span></span><span style=display:flex><span>58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
</span></span><span style=display:flex><span>63) SIGRTMAX-1  64) SIGRTMAX
</span></span></code></pre></div><h3 id=信号的使用>信号的使用</h3><p>进程可以更改信号的设置。进程在收到信号后，如果编写了信号处理函数就执行信号处理函数，如果没有编写信号处理函数就会执行默认动作。</p><p>代码示例：{demo-c}/demo-in-linux/signal/signal_handler.c</p><p>程序运行起来之后，我们通过 &ldquo;kill -s&rdquo; 命令向进程发送信号。</p><ul><li>如果向程序发送 SIGUSR1，进程会执行默认动作，输出 &ldquo;User defined signal 1&rdquo;，然后停止。</li><li>如果向程序发送 SIGUSR2，进程会忽略信号，什么反应都没有。</li><li>如果向程序发送 SIGINT，进程会执行处理函数，输出 &ldquo;[info]:signal_no=2&rdquo;，然后继续执行。</li></ul><p>测试信号处理函数时，当测试的是信号是 SIGSTOP 时，并不会像预期的那样输出 SIGSTOP 信号的值。
因为进程收到 SIGSTOP 后已经停止作业（并没有退出）。
如果这时再向进程发送 SIGCONT 信号。这时进程会恢复作业，并输出<code>signal no=18</code>，也就是收到的 SIGCONT 信号的值。</p><p>通过 strace 命令追踪，可以得到下面的内容。进程确实收到了 SIGSTOP 信号和 SIGCONT 信号。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>--- SIGSTOP {si_signo=SIGSTOP, si_code=SI_USER, si_pid=84, si_uid=0} ---
</span></span><span style=display:flex><span>--- stopped by SIGSTOP ---
</span></span><span style=display:flex><span>--- SIGCONT {si_signo=SIGCONT, si_code=SI_USER, si_pid=84, si_uid=0} ---
</span></span><span style=display:flex><span>write(1, &#34;signal no=18\r\n&#34;, 14)        = 14
</span></span></code></pre></div><h3 id=信号和-waitpid>信号和 waitpid()</h3><p>父进程调用 waitpid() 的时候可以获得子进程推出的状态码。</p><p>把状态码传给宏函数 WIFSIGNALED()，可以判断子进程是不是被信号终止的。
如果子进程是被信号终止的，WIFSIGNALED() 会返回一个非零值。</p><p>当 WIFSIGNALED() 返回非零值时，可以用宏函数 WTERMSIG() 宏来提取信号的编号。</p><p>代码示例：{demo-c}/demo-in-linux/signal/signal_and_waitpid.c</p><h3 id=信号和系统调用>信号和系统调用</h3><blockquote><p>signal(7)</br>Interruption of system calls and library functions by signal handlers If a signal
handler is invoked while a system call or library function call is blocked, then either:</br>&ndash; the call is automatically restarted after the signal handler returns; or</br>&ndash; the call fails with the error EINTR.</br>&mldr;</br>If a blocked call to one of the following interfaces is interrupted by a signal handler,
then the call is automatically restarted after the signal handler returns
if the SA_RESTART flag was used; otherwise the call fails with the error EINTR:</br></p></blockquote><p>如果进程正在执行一些系统调用，此时进程收到了一个信号，则该系统调用将会停止并返回错误，
错误码（errno）一般是 -1，错误（error）一般是 EINTR。</p><p>如果进程正在执行系统调用，而且这个系统调用被阻塞。这时来了一个信号，结果会有两种。
第一种，进程的信号处理函数已经执行返回，但是系统调用返回错误，错误码为 EINTR。
第二种，进程的信号处理函数已经执行返回，这时系统调用会重新开始。</p><h4 id=系统调用返回错误>系统调用返回错误</h4><p>代码示例：{demo-c}/demo-in-linux/signal/sigaction_default.c</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[debug]:getpid()=4475
</span></span><span style=display:flex><span>[info]:signal_no=2
</span></span><span style=display:flex><span>[debug]:byte=-1,errno=4,error=Interrupted system call
</span></span></code></pre></div><p>这是终端的输出，我们可以看到，先执行了处理函数，然后 read() 系统调用输出了错误，然后进程就终止了。
我们用 strace 再观察一下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[00007febcad14992] read(0, 
</span></span></code></pre></div><p>这是没有发送信号的时候。进程阻塞在 read() 系统调用这里。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[00007febcad14992] read(0, 0x7ffd2b0b9ed0, 128) = ? ERESTARTSYS (To be restarted if SA_RESTART is set) &lt;5.907470&gt;
</span></span><span style=display:flex><span>[00007febcad14992] --- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=2304, si_uid=1000} ---
</span></span><span style=display:flex><span>[00007febcad14a37] write(1, &#34;[info]:signal_no=2\n&#34;, 19) = 19 &lt;0.000019&gt;
</span></span><span style=display:flex><span>[00007febcac42529] rt_sigreturn({mask=[]}) = -1 EINTR (Interrupted system call) &lt;0.000005&gt;
</span></span><span style=display:flex><span>[00007febcad14a37] write(1, &#34;[debug]:byte=-1,errno=4,error=Interrupted system call\n&#34;, 54) = 54 &lt;0.000006&gt;
</span></span><span style=display:flex><span>[00007febcaceaca1] exit_group(0)        = ?
</span></span><span style=display:flex><span>[????????????????] +++ exited with 0 +++
</span></span></code></pre></div><p>这是发送信号之后。进程收到信号之后，先执行了处理函数。
处理函数返回时，是 EINTR 错误。然后 read() 系统调用拿到了这个 EINTR 错误。</p><h4 id=系统调用重新开始>系统调用重新开始</h4><p>代码示例：{demo-c}/demo-in-linux/signal/sigaction_restart.c</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[debug]:getpid()=4491
</span></span><span style=display:flex><span>[info]:signal_no=2
</span></span></code></pre></div><p>这是终端的输出，可以看到，先执行了处理函数，然后 read() 系统调用并没有和上面一样输出错误，而是继续执行。
我们用 strace 再观察一下。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[00007f08c8714992] read(0, 
</span></span></code></pre></div><p>这是没有发送信号的时候。进程阻塞在 read() 系统调用这里。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[00007f08c8714992] read(0, 0x7ffcdcb49bd0, 128) = ? ERESTARTSYS (To be restarted if SA_RESTART is set) &lt;4.457116&gt;
</span></span><span style=display:flex><span>[00007f08c8714992] --- SIGINT {si_signo=SIGINT, si_code=SI_USER, si_pid=2304, si_uid=1000} ---
</span></span><span style=display:flex><span>[00007f08c8714a37] write(1, &#34;[info]:signal_no=2\n&#34;, 19) = 19 &lt;0.000077&gt;
</span></span><span style=display:flex><span>[00007f08c8642529] rt_sigreturn({mask=[]}) = 0 &lt;0.000074&gt;
</span></span><span style=display:flex><span>[00007f08c8714992] read(0,
</span></span></code></pre></div><p>这是发送信号之后。进程收到信号之后，先执行了处理函数。处理函数返回时，没有错误。然后 read() 系统调用重新执行了。</p><h3 id=信号屏蔽和未决信号>信号屏蔽和未决信号</h3><blockquote><p>signal(7)</br>A signal may be blocked, which means that it will not be delivered until it is later unblocked.
Between the time when it is generated and when it is delivered a signal is said to be pending.</br></p></blockquote><p>信号可以被阻塞，这时信号不会交付（执行默认动作或者被交给信号处理函数），直到它不被阻塞。
信号处于生成和交付之间的状态，被称为未决。</p><p>代码示例：{demo-c}/demo-in-linux/signal/signal_block.c</p><p>程序大体的逻辑是，在 10 秒之内阻塞 SIGINT 信号，第 10 秒的时候解开 SIGINT 信号的阻塞。
然后，分别在 10 秒之内和 10 秒以后向进程发送 SIGINT 信号。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>[debug]:getpid()=4774
</span></span><span style=display:flex><span>[info]:pendingSet:0000000000000000000000000000000
</span></span><span style=display:flex><span>[info]:pendingSet:0000000000000000000000000000000
</span></span><span style=display:flex><span>[info]:pendingSet:0000000000000000000000000000000
</span></span><span style=display:flex><span>[info]:pendingSet:0000000000000000000000000000000
</span></span><span style=display:flex><span>[info]:pendingSet:0100000000000000000000000000000
</span></span><span style=display:flex><span>[info]:pendingSet:0100000000000000000000000000000
</span></span><span style=display:flex><span>[info]:pendingSet:0100000000000000000000000000000
</span></span><span style=display:flex><span>[info]:pendingSet:0100000000000000000000000000000
</span></span><span style=display:flex><span>[info]:pendingSet:0100000000000000000000000000000
</span></span><span style=display:flex><span>[info]:pendingSet:0100000000000000000000000000000
</span></span><span style=display:flex><span>[info]:signal_no=2
</span></span><span style=display:flex><span>[info]:pendingSet:0000000000000000000000000000000
</span></span><span style=display:flex><span>[info]:pendingSet:0000000000000000000000000000000
</span></span><span style=display:flex><span>[info]:signal_no=2
</span></span><span style=display:flex><span>[info]:pendingSet:0000000000000000000000000000000
</span></span><span style=display:flex><span>[info]:pendingSet:0000000000000000000000000000000
</span></span></code></pre></div><p>可以看到，在 10 秒之内和向进程发送 SIGINT 信号的时候，信号处理函数并没有输出。
未决信号里面从没有数据变成有数据，说明 SIGINT 信号被阻塞了。</p><p>第 10 秒的时候，因为 SIGINT 信号的阻塞被解开，所以，信号处理函数开始工作了。处理完之后，未决信号里面就变成空的了。</p><p>10 秒以后向进程发送 SIGINT 信号的时候，信号不会被阻塞，信号处理函数直接开始工作，未决信号里面不会有数据。</p><h3 id=小的知识点>小的知识点</h3><h4 id=sigkillsigstop>SIGKILL、SIGSTOP</h4><blockquote><p>signal(7)</br>The signals SIGKILL and SIGSTOP cannot be caught, blocked, or ignored.</br></p></blockquote><p>SIGKILL 和 SIGSTOP 这两个信号不能被捕捉、阻止、忽略。</p><h4 id=sigalrm>SIGALRM</h4><p>用 alarm() 定时触发 SIGALRM 信号，可以实现类似定时任务的结构。</p><h3 id=观察进程数据>观察进程数据</h3><blockquote><p>signal(7)</br>The /proc/[pid]/task/[tid]/status file contains various fields that show the signals
that a thread is blocking (SigBlk), catching (SigCgt), or ignoring (SigIgn).
(The set of signals that are caught or ignored will be the same across all threads in a process.)
Other fields show the set of pending signals that are directed to the thread (SigPnd)
as well as the set of pending signals that are directed to the process as a whole (ShdPnd).
The corresponding fields in /proc/[pid]/status show the information for the main thread.</p></blockquote><p>和信号有关系的进程数据，可以通过 &ldquo;/proc/{pid}/status&rdquo; 文件观察。
SigQ：当前进程待处理信号数。SigPnd；线程的未决信号。ShnPnd；线程组的未决信号。
SigBlk；阻塞的信号。SigIgn；忽略的信号。SigCgt；捕捉的信号。</p><p>这里观察一下上面的 {demo-c}/demo-in-linux/signal/signal_block.c 的运行情况。
为了观察方便可以拉长 signal_block.c 中的等待时间，方便进行操作。</p><p>刚开始运行的时候是这样的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>SigQ:	0/15243
</span></span><span style=display:flex><span>SigPnd:	0000000000000000
</span></span><span style=display:flex><span>ShdPnd:	0000000000000000
</span></span><span style=display:flex><span>SigBlk:	0000000000000002
</span></span><span style=display:flex><span>SigIgn:	0000000000000000
</span></span><span style=display:flex><span>SigCgt:	0000000000000002
</span></span></code></pre></div><p>向进程发送 SIGINT 信号之后，变成了这样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>SigQ:	1/15243
</span></span><span style=display:flex><span>SigPnd:	0000000000000000
</span></span><span style=display:flex><span>ShdPnd:	0000000000000002
</span></span><span style=display:flex><span>SigBlk:	0000000000000002
</span></span><span style=display:flex><span>SigIgn:	0000000000000000
</span></span><span style=display:flex><span>SigCgt:	0000000000000002
</span></span></code></pre></div><p>解开 SIGINT 信号的阻塞之后，变成了这样。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:2;-o-tab-size:2;tab-size:2><code class=language-fallback data-lang=fallback><span style=display:flex><span>SigQ:	0/15243
</span></span><span style=display:flex><span>SigPnd:	0000000000000000
</span></span><span style=display:flex><span>ShdPnd:	0000000000000000
</span></span><span style=display:flex><span>SigBlk:	0000000000000000
</span></span><span style=display:flex><span>SigIgn:	0000000000000000
</span></span><span style=display:flex><span>SigCgt:	0000000000000002
</span></span></code></pre></div></div><footer class=post-footer><div class=post-tags><a href=/tags/computer-science%e8%ae%a1%e7%ae%97%e6%9c%ba%e7%a7%91%e5%ad%a6>computer-science(计算机科学)</a>
<a href=/tags/operating-system%e6%93%8d%e4%bd%9c%e7%b3%bb%e7%bb%9f>operating-system(操作系统)</a>
<a href=/tags/signal%e4%bf%a1%e5%8f%b7>signal(信号)</a></div><div class=addthis_inline_share_toolbox style=text-align:center></div><hr><div class=post-copyright><img src=/imgs/cc/cc.svg width=75 height=75 align=right><ul><li class=post-copyright-title><strong>文章标题：</strong>
信号</li><li class=post-copyright-author><strong>本文作者：</strong>
西柊慧音</li><li class=post-copyright-link><strong>本文链接：</strong>
<a id=post-cr-link href=/post/computer-science/operating-system/linux/signal/ title=信号>/post/computer-science/operating-system/linux/signal/</a></li><li class=post-copyright-license><strong>版权声明：</strong>
本博客所有文章除特别声明外，均采用 <i class="fab fa-fw fa-creative-commons"></i><a target=_blank href=https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh>BY-NC-SA</a> 许可协议。转载请注明出处！</li></ul></div><div class=post-nav><div class="post-nav-next post-nav-item"><a href=/post/computer-science/application/jekyll/install_publish/ rel=next title="使用 Jekyll 和 GitHub Pages 搭建站点"><i class="fa fa-chevron-left"></i> 使用 Jekyll 和 GitHub Pages 搭建站点</a></div><div class="post-nav-prev post-nav-item"><a href=/post/computer-science/operating-system/windows/hosts/ rel=prev title="hosts 文件">hosts 文件
<i class="fa fa-chevron-right"></i></a></div></div></footer></article></div></div></main><footer class=footer><div class=footer-inner><div class=copyright>&copy;
<span itemprop=copyrightYear>2020 - 2023</span>
<span class=with-love><i class="fa fa-heart"></i></span>
<span class=author itemprop=copyrightHolder>西柊慧音</span></div><div class=powered-by>由 <a href=https://gohugo.io title=0.103.1 target=_blank>Hugo</a> & <a href=https://github.com/hugo-next/hugo-theme-next title=4.4.1 target=_blank>Hugo NexT.Gemini</a> 强力驱动</div></div></footer><script type=text/javascript src=https://cdn.staticfile.org/animejs/3.2.1/anime.min.js defer></script>
<script type=text/javascript src=https://cdn.staticfile.org/viewerjs/1.11.0/viewer.min.js defer></script>
<script class=next-config data-name=main type=application/json>{"bookmark":{"color":"#222","enable":true,"save":"manual"},"busuanzi":{"pageview":true},"copybtn":true,"darkmode":false,"giscus":{"cfg":{"category":"Comments","categoryid":null,"emit":false,"inputposition":"top","mapping":"title","reactions":false,"repo":"username/repo-name","repoid":null,"theme":"preferred_color_scheme"},"js":"https://giscus.app/client.js"},"hostname":"/","i18n":{"ds_day":" 天前","ds_days":" 天 ","ds_hour":" 小时前","ds_hours":" 小时 ","ds_just":"刚刚","ds_min":" 分钟前","ds_mins":" 分钟","ds_month":" 个月前","ds_years":" 年 ","empty":"没有找到任何搜索结果：${query}","hits":"","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","placeholder":"搜索..."},"lang":"zh-CN","lazyload":false,"localSearch":{"enable":true,"path":"/searchindexes.xml","preload":false,"topnperarticle":-1,"trigger":"auto","unescape":false},"motion":{"async":true,"enable":true,"transition":{"collheader":"fadeInLeft","postblock":"fadeIn","postbody":"fadeInDown","postheader":"fadeInDown","sidebar":"fadeInUp"}},"root":"/","scheme":"Gemini","sidebar":{"display":"post","offset":12,"padding":18,"position":"left","width":256},"statis":{"enable":false,"plugin":"busuanzi"},"vendor":{"plugins":"qiniu","router":"https://cdn.staticfile.org"},"version":"4.4.1","waline":{"cfg":{"comment":true,"emoji":false,"imguploader":false,"pageview":false,"placeholder":"请文明发言哟 ヾ(≧▽≦*)o","reaction":true,"reactiontext":["点赞","踩一下","得意","不屑","尴尬","睡觉"],"reactiontitle":"你认为这篇文章怎么样？","requiredmeta":["nick","mail"],"serverurl":null,"sofa":"快来发表你的意见吧 (≧∀≦)ゞ","wordlimit":200},"css":{"alias":"waline","file":"dist/waline.css","name":"@waline/client","version":"2.13.0"},"js":{"alias":"waline","file":"dist/waline.js","name":"@waline/client","version":"2.13.0"}}}</script><script type=text/javascript src=/js/main.min.c997eeae723f2fcee19ae5066fcc64a49cefb92ddb75904efdb69a223e5a6740.js defer></script></body></html>